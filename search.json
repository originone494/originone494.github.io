[{"title":"热更新中AB包的上传和下载（一）","url":"/2025/12/31/AssetBundle/","content":"一、热更新流程\n在资源需要变化时，向资源服务器（FTP、HTTP等）上传AB包和资源对比文件。\n每次通过游戏客户端进入时：\n\n下载服务器上的资源对比文件\n用下载下来的资源对比文件和本地文件进行对比，记录需要进行更新的AB包\n将需要更新的AB包进行更新，再更新资源对比文件\n完成后，正式进入游戏\n\n二、准备打包AB包的脚本\n在github上下载AssetBundles Browser\n可以通过url在包管理器里添加，也可以直接在https://github.com/Unity-Technologies/AssetBundles-Browser直接下载压缩包。\n如果是直接在github上下载压缩包，需要将里面的Test文件删除，不然直接在unity里会报错\n\n删除以后，就可以直接将压缩包里面的文件粘贴到Unity项目的Packages文件夹下\n\n添加后，在Unity按下Ctrl+R即可刷新，包就导入到项目中了\n接着就能在窗口选项里面找到AssetBundle Browser的选项\n\n点开后得到这样的界面：\n\n三、准备需要打包的内容\n在场景中创建简单的立方体、球体和圆柱体，用来模拟需要打包的内容。\n将创建好的物体拖到自己创建好的Assets/ArtRes/Prefab文件夹下。\n\n同时，创建好Assets/ArtRes/Lua文件夹用来存放lua脚本。\n打开Assets/ArtRes/Lua文件夹的资源管理器，在里面新建两个txt文本用来模拟lua脚本\n\n将三个刚刚创建的预制体添加到model包（自己创建）里\n\n接着，我们就可以在AssetBundle Browser视窗看到我们model包下的物体了\n\n也可以通过直接在AssetBundle Browser视窗，直接新建一个包\n\n这里新建一个lua包，用来装lua脚本\n\n将之前新建的用来模拟lua脚本的txt文件放入lua包中\n\n四、进行打包\n点击build按钮，来到build界面。\n\n我们需要新建Assets/ArtRes/AB/PC文件夹来存储build的输出结果\n\n将路径Assets/ArtRes/AB/PC放到Output Path中\n\n在高级设置里，只需要将压缩方式改为LZ4方式，是一种比较好的压缩方式，其他的选项都不用动\n\n最终设置为：\n\n点击Build，等待，然后就可以在Assets/ArtRes/AB/PC文件夹下看到打包出来的资源\n\n五、获取AB包文件的MD5码\n\nMD5码是什么\n\nMD5是信息摘要算法的简称，是一种广泛使用的密码散列函数，可以生成一个16字节的散列值，用于确保信息的完整一致性\n当我们把数据经过MD5算法计算后，不管我们传入的数据有多大，都会生成一个固定长度的MD5码\n相同的数据，经过MD5算法计算后的结果是一样的\n如果数据发生变化，MD5码会发生变化\n因此，我们通过MD5码作为文件的唯一标识，通过其判断文件内容是否发生变化\n\n编写获得MD5码的脚本\n\n流程：根据文件路径获得文件流信息-&gt;利用MOD加密服务提供商（通过MD5CryptoServiceProvider新建一个）对象，根据流信息，计算出MD5码-&gt;将字节数组形式的MD5码转为16进制字符串\n完整代码：\nusing System.IO;using System.Security.Cryptography;using System.Text;using UnityEngine;public class GetMD5 : MonoBehaviour&#123;    // Start is called before the first frame update    void Start()    &#123;        print(getfileMd5(Application.dataPath + &quot;/ArtRes/AB/PC/lua&quot;));    &#125;    // Update is called once per frame    void Update()    &#123;            &#125;    private string getfileMd5(string filePath)    &#123;        //将文件以流的形式打开        using(FileStream file = new FileStream(filePath, FileMode.Open))        &#123;            MD5 md5 = new MD5CryptoServiceProvider();//声明一个MD5对象            byte[] md5Info = md5.ComputeHash(file);//获得数据MD5码 16个字节的数组            //关闭文件流            file.Close();            StringBuilder sb = new StringBuilder();            for(int i = 0;i &lt; md5Info.Length; i++)            &#123;                sb.Append(md5Info[i].ToString(&quot;x2&quot;));//转换成16进制字符串            &#125;            return sb.ToString();        &#125;    &#125;&#125;\n运行后，可以正确得到lua包的MD5码\n\n当我们改变lua包里面的内容时，比如在lua包里新增一个lua脚本的txt文件，那么lua包的MD5码就会发生改变\n六、生成AB包资源对比文件\n功能：\n\n在菜单栏添加一个按钮，点击后能够生成AB包资源对比文件\n遍历AB包文件夹，获取所有AB包文件信息（文件名、大小、MD5码），将其存入资源对比文件\n\n首先在Assets文件夹下新建Editor文件夹，此文件夹下的代码不需要在游戏中使用，只在Unity编辑器中使用，因此放在此文件夹下使其不会被打包出去。\n并在Editor文件夹下新建CreateABCompare脚本，用来实现对应功能\n\n完整代码：\nusing System.IO;using System.Security.Cryptography;using System.Text;using UnityEditor;using UnityEngine;public class CreateABCompare&#123;    [MenuItem(&quot;Tool/创建AB包对比文件&quot;)]    public static void CreateABCompareFile()    &#123;        //获取文件夹信息        DirectoryInfo directory = Directory.CreateDirectory(            Application.dataPath + &quot;/ArtRes/AB/PC&quot;);        //获取该目录下所有文件        FileInfo[] files = directory.GetFiles();        //用于存储信息的字符串        string abCompareInfo = &quot;&quot;;                foreach (FileInfo file in files)        &#123;            //没有后缀的是AB包            if(file.Extension == &quot;&quot;)            &#123;                abCompareInfo += file.Name + &quot; &quot; + file.Length + &quot; &quot; + getfileMd5(file.FullName);                abCompareInfo += &quot;|&quot;;            &#125;        &#125;        //循环完毕后，截取最后一个“|”        abCompareInfo = abCompareInfo.Substring(0,abCompareInfo.Length - 1);        //存储信息        File.WriteAllText(Application.dataPath + &quot;/ArtRes/AB/PC/ABCompareInfo.txt&quot;,abCompareInfo);        AssetDatabase.Refresh();    &#125;    private static string getfileMd5(string filePath)    &#123;        //将文件以流的形式打开        using (FileStream file = new FileStream(filePath, FileMode.Open))        &#123;            MD5 md5 = new MD5CryptoServiceProvider();//声明一个MD5对象            byte[] md5Info = md5.ComputeHash(file);//获得数据MD5码 16个字节的数组            //关闭文件流            file.Close();            StringBuilder sb = new StringBuilder();            for (int i = 0; i &lt; md5Info.Length; i++)            &#123;                sb.Append(md5Info[i].ToString(&quot;x2&quot;));//转换成16进制字符串            &#125;            return sb.ToString();        &#125;    &#125;&#125;\n可以得到以下结果：\n左上角出现了tool栏，tool栏有创建AB包对比文件的选项\n\n点击该按钮后，可以看到生成的文件\n\n以及文件的内容\n\n七、搭建FTP服务器\n用于模拟资源服务器，用于存储资源和资源对比文件\n\n\n下载Serv-U\n可以通过这个网址下载：\nhttps://www.yxtown.com/my/course/65/material?type=material&amp;page=2\n\n\n注册上传账号和下载账号（匿名）\n\n\n是否定义新域，点击是\n\n名称随便填一个\n\n下一步\n\n下一步\n\n勾选单向加密，点完成\n\n接着会弹出这个界面，点是\n\n随便填，下一步\n\n随便，下一步\n\n设置根目录，之后上传的文件会放在这里\n\n选择完全访问，点击完成\n\n接下来需要一个匿名用户，点击向导\n\n登录ID输入 Anonvmous，点下一步\n\n密码为空，匿名账号不需要密码，点下一步\n\n根目录和之前一样\n\n选择只读访问，点完成\n\n最终会出现两个账号\n\n\n验证\n在资源管理器输入ftp://127.0.0.1\n\n\n可以看到文件夹为空\n在之前设置的根目录中随便新建一个文件\n\n可以看到ftp服务器上多出了一个文件\n\n八、上传AB包和资源对比文件\n新建脚本UploadAB，用来向资源服务器上传AB包和资源对比文件\n完整代码：\nusing System;using System.IO;using System.Net;using System.Threading.Tasks;using UnityEditor;using UnityEngine;public class UploadAB&#123;    [MenuItem(&quot;Tool/上传AB包和对比文件&quot;)]    private static void UploadAllABFile()    &#123;        //获取文件夹信息        DirectoryInfo directory = Directory.CreateDirectory(            Application.dataPath + &quot;/ArtRes/AB/PC&quot;);        //获取该目录下所有文件        FileInfo[] files = directory.GetFiles();        foreach (FileInfo file in files)        &#123;            if (file.Extension == &quot;&quot; || file.Extension == &quot;.txt&quot;)            &#123;                FtpUploadFile(file.FullName, file.Name);            &#125;        &#125;    &#125;    private static async void FtpUploadFile(string filePath, string fileName)    &#123;        //异步处理，在上传文件时，不会卡住主线程        await Task.Run(() =&gt;        &#123;            try            &#123;                //1.创建FTP连接用于上传                FtpWebRequest req = FtpWebRequest.Create(new Uri(&quot;ftp://127.0.0.1/AB/PC/&quot; + fileName)) as FtpWebRequest;                //2.设置一个通信凭证，这样才能上传                NetworkCredential n = new NetworkCredential(&quot;qwe&quot;, &quot;123000&quot;);                req.Credentials = n;                //3.其他设置                req.Proxy = null;//设置代理为空                req.KeepAlive = false;//请求完毕后，是否关闭控制连接                req.Method = WebRequestMethods.Ftp.UploadFile;//操作命令-上传                req.UseBinary = true;//指定传输的类型-2进制                //4.上传文件                Stream upLoadStream = req.GetRequestStream();//ftp的流对象                                                             //读取文件信息，写入该流对象                using (FileStream file = File.OpenRead(filePath))                &#123;                    //一点一点上传                    byte[] bytes = new byte[2048];                    //读取了多少字节                    int contentLength = file.Read(bytes, 0, bytes.Length);                    //循环上传文件                    while (contentLength != 0)                    &#123;                        //写入到上传流中                        upLoadStream.Write(bytes, 0, contentLength);                        //写完再读                        contentLength = file.Read(bytes, 0, bytes.Length);                    &#125;                    //循环完毕后，上传完毕                    file.Close();                    upLoadStream.Close();                &#125;            &#125;            catch (Exception ex)            &#123;                Debug.Log(&quot;上传失败 &quot; + ex.Message);            &#125;            Debug.Log(fileName + &quot;上传成功&quot;);        &#125;        );    &#125;&#125;\n运行Tool选项里面的上传按钮后，会在资源服务器里看到上传的结果\n要注意因为上传的路径是ftp://127.0.0.1/AB/PC/，因此如果资源服务器里没有/AB/PC文件夹的话，会发生报错，因为程序只负责上传，不会自动创建新文件夹\n\n","categories":["Unity"]},{"title":"行为树","url":"/2025/12/30/BehaviorTree/","content":"完整代码\n一、Base部分\n\nBehaviorTree.cs\n\npublic class BehaviorTree&#123;    public bool HaveRoot =&gt; root != null;    private BtBehaviour root;//根节点    public BehaviorTree(BtBehaviour root)    &#123;        this.root = root;    &#125;    public void Tick()    &#123;        root.Tick();    &#125;    public void SetRoot(BtBehaviour root)    &#123;        this.root = root;    &#125;&#125;\n\nBtActionNode.cs\n\npublic class BtActionNode : BtBehaviour&#123;    protected EnemyController enemyController;    protected Func&lt;EStatus&gt; action;    public BtActionNode(EnemyController enemyController, Func&lt;EStatus&gt; action)    &#123;        this.enemyController = enemyController;        this.action = action;    &#125;    protected override EStatus OnUpdate()    &#123;        return action();    &#125;&#125;\n\nBtBehaviour.cs\n\npublic enum EStatus&#123;    //失败，成功，运行中，中断，无效    Failure, Success, Running, Aborted, Invalid&#125;public abstract class BtBehaviour&#123;    public bool IsTerminated =&gt; IsSuccess || IsFailure;//是否运行结束    public bool IsSuccess =&gt; status == EStatus.Success;//是否成功    public bool IsFailure =&gt; status == EStatus.Failure;//是否失败    public bool IsRunning =&gt; status == EStatus.Running;//是否正在运行    protected EStatus status;//运行状态    public BtBehaviour()    &#123;        status = EStatus.Invalid;    &#125;    protected virtual void OnInitialize()    &#123; &#125;    protected abstract EStatus OnUpdate();    protected virtual void OnTerminate()    &#123; &#125;    public EStatus Tick()    &#123;        if (!IsRunning)            OnInitialize();        status = OnUpdate();        if (!IsRunning)            OnTerminate();        return status;    &#125;    public virtual void AddChild(BtBehaviour child)    &#123; &#125;    public void Reset()    &#123;        status = EStatus.Invalid;    &#125;    public void Abort()    &#123;        OnTerminate();        status = EStatus.Aborted;    &#125;&#125;\n\nBtComposite.cs\n\npublic abstract class BtComposite : BtBehaviour&#123;    protected LinkedList&lt;BtBehaviour&gt; children;    public BtComposite()    &#123;        children = new LinkedList&lt;BtBehaviour&gt;();    &#125;    //移除指定子节点    public virtual void RemoveChild(BtBehaviour child)    &#123;        children.Remove(child);    &#125;    public void ClearChildren()//清空子节点列表    &#123;        children.Clear();    &#125;    public override void AddChild(BtBehaviour child)//添加子节点    &#123;        //默认是尾插入，如：0插入「1，2，3」中，就会变成「1，2，3，0」        children.AddLast(child);    &#125;&#125;\n\nBtDecorator.cs\n\npublic abstract class BtDecorator : BtBehaviour&#123;    protected BtBehaviour child;    public override void AddChild(BtBehaviour child)    &#123;        this.child = child;    &#125;&#125;\n二、Composite\n\nBtActiveSelector.cs\n\npublic class BtActiveSelector : BtSelector&#123;    protected override EStatus OnUpdate()    &#123;        var prev = currentChild;        base.OnInitialize();//注意这里，currentChild 会被赋值为 children.First        var res = base.OnUpdate();//按Selector的OnUpdate执行，顺序遍历选择        /*        只要不是遍历结束或可执行节点不变，都应该中断上一次执行的节点，无论优先是高是低。        因为如果当前优先级比之前的高，理应中断之前的；        而如果比之前的低，那就证明之前高优先级的行为无法继续了，        否则怎么会等到现在的低优先级的行为呢？所以也应中断它。        */        if (prev != null &amp;&amp; currentChild != prev)            prev.Value.Abort();        return res;    &#125;&#125;\n\nBtFilter.cs\n\n  public class BtFilter : BtSequence&#123;    public BtFilter(BtBehaviour condition)    &#123;        AddCondition(condition);    &#125;    public BtFilter(BtBehaviour condition1, BtBehaviour condition2)    &#123;        AddCondition(condition1);        AddCondition(condition2);    &#125;    public BtFilter()    &#123;    &#125;    public void AddCondition(BtBehaviour condition)//添加条件，就用头插入    &#123;        children.AddFirst(condition);    &#125;    public void AddAction(BtBehaviour action)//添加动作，就用尾插入    &#123;        children.AddLast(action);    &#125;&#125;\n\nBtMonitor.cs\n\npublic class BtMonitor : BtParallel&#123;    public BtMonitor(Policy mSuccessPolicy, Policy mFailurePolicy) : base(mSuccessPolicy, mFailurePolicy)    &#123;    &#125;    public void AddCondition(BtBehaviour condition)    &#123;        children.AddFirst(condition);    &#125;    public void AddAction(BtBehaviour action)    &#123;        children.AddLast(action);    &#125;&#125;\n\nBtParallel.cs\n\npublic class BtParallel : BtComposite&#123;    protected Policy mSuccessPolicy;//成功的标准    protected Policy mFailurePolicy;//失败的标准    /// &lt;summary&gt;    /// Parallel节点成功与失败的要求，是全部成功/失败，还是一个成功/失败    /// &lt;/summary&gt;    public enum Policy    &#123;        RequireOne, RequireAll,    &#125;    //构造函数初始化时，会要求给定成功和失败的标准    public BtParallel(Policy mSuccessPolicy, Policy mFailurePolicy)    &#123;        this.mSuccessPolicy = mSuccessPolicy;        this.mFailurePolicy = mFailurePolicy;    &#125;    protected override EStatus OnUpdate()    &#123;        int successCount = 0, failureCount = 0;//记录执行成功和执行失败的节点数        var b = children.First;//从第一个子节点开始        var size = children.Count;        for (int i = 0; i &lt; size; ++i)        &#123;            var bh = b.Value;            if (!bh.IsTerminated)//如果该子节点还没运行结束，就运行它                bh.Tick();            b = b.Next;            if (bh.IsSuccess)//该子节点运行结束后，如果运行成功了            &#123;                ++successCount;//成功执行的节点数+1                               //如果是「只要有一个」标准的话，那就可以返回结果了                if (mSuccessPolicy == Policy.RequireOne)                    return EStatus.Success;            &#125;            if (bh.IsFailure)//该子节点运行失败的情况同理            &#123;                ++failureCount;                if (mFailurePolicy == Policy.RequireOne)                    return EStatus.Failure;            &#125;        &#125;        //如果是「全都」标准的话，就需要比对当前成功/失败个数与总子节点数        if (mFailurePolicy == Policy.RequireAll &amp;&amp; failureCount == size)            return EStatus.Failure;        if (mSuccessPolicy == Policy.RequireAll &amp;&amp; successCount == size)            return EStatus.Success;        return EStatus.Running;    &#125;    //结束函数，只要简单地把所有子节点设为「中断」就可以了    protected override void OnTerminate()    &#123;        foreach (var b in children)        &#123;            if (b.IsRunning)                b.Abort();        &#125;    &#125;&#125;\n\nBtSelector.cs\n\npublic class BtSelector : BtSequence&#123;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            var s = currentChild.Value.Tick();            if (s != EStatus.Failure)                return s;            currentChild = currentChild.Next;            if (currentChild == null)                return EStatus.Failure;        &#125;    &#125;&#125;\n6.BtSequence.cs\nusing System.Collections.Generic;public class BtSequence : BtComposite&#123;    protected LinkedListNode&lt;BtBehaviour&gt; currentChild;//当前运行的子节点    protected override void OnInitialize()    &#123;        currentChild = children.First;//从第一个子节点开始    &#125;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            var s = currentChild.Value.Tick();//记录子节点运行返回的结果状态            /*            如果子节点运行，还没有成功，就直接返回该结果。            是「运行中」那就表明本节点也是运行中，有记录当前节点，下次还会继续执行；            是「失败」就表明本节点也运行失败了，下次会再经历OnInitialize，从头开始。            */            if (s != EStatus.Success)                return s;            //如果运行成功，就换到下一个子节点            currentChild = currentChild.Next;            //如果全都成功运行完了，就返回「成功」            if (currentChild == null)                return EStatus.Success;        &#125;    &#125;&#125;## 三、Decorator1. BtInverter.cs```C#public class BtInverter : BtDecorator&#123;    protected override EStatus OnUpdate()    &#123;        child.Tick();        if (child.IsFailure)            return EStatus.Success;        if (child.IsSuccess)            return EStatus.Failure;        return EStatus.Running;    &#125;&#125;\n\nBtRepeat.cs\n\npublic class BtRepeat : BtDecorator&#123;    private int conunter;//当前重复次数    private int limit;//重复限度    public BtRepeat(int limit)    &#123;        this.limit = limit;    &#125;    protected override void OnInitialize()    &#123;        conunter = 0;//进入时，将次数清零    &#125;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            child.Tick();            if (child.IsRunning)                return EStatus.Running;            if (child.IsFailure)                return EStatus.Failure;            //子节点执行成功，就增加一次计算，达到设定限度才返回成功            if (++conunter &gt;= limit)                return EStatus.Success;        &#125;    &#125;&#125;\n三、BehaviorTreeBuilder.cs(主要使用这个类来构建和控制行为属)\npublic class BehaviorTreeBuilder&#123;    private readonly Stack&lt;BtBehaviour&gt; nodeStack;//构建树结构用的栈    private readonly BehaviorTree bhTree;//构建的树    public BehaviorTreeBuilder()    &#123;        bhTree = new BehaviorTree(null);//构造一个没有根的树        nodeStack = new Stack&lt;BtBehaviour&gt;();//初始化构建栈    &#125;    public BehaviorTreeBuilder AddBehavior(BtBehaviour behavior)    &#123;        if (bhTree.HaveRoot)//有根节点时，加入构建栈        &#123;            nodeStack.Peek().AddChild(behavior);        &#125;        else //当树没根时，新增得节点视为根节点        &#123;            bhTree.SetRoot(behavior);        &#125;        //只有组合节点和修饰节点需要进构建堆        if (behavior is BtComposite || behavior is BtDecorator)        &#123;            nodeStack.Push(behavior);        &#125;        return this;    &#125;    public void TreeTick()    &#123;        bhTree.Tick();    &#125;    public BehaviorTreeBuilder Back()    &#123;        nodeStack.Pop();        return this;    &#125;    public BehaviorTree End()    &#123;        nodeStack.Clear();        return bhTree;    &#125;    //---------包装各节点---------    public BehaviorTreeBuilder Sequence()    &#123;        var tp = new BtSequence();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Seletctor()    &#123;        var tp = new BtSelector();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Filter()    &#123;        var tp = new BtFilter();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Parallel(BtParallel.Policy success, BtParallel.Policy failure)    &#123;        var tp = new BtParallel(success, failure);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Monitor(BtParallel.Policy success, BtParallel.Policy failure)    &#123;        var tp = new BtMonitor(success, failure);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder ActiveSelector()    &#123;        var tp = new BtActiveSelector();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Repeat(int limit)    &#123;        var tp = new BtRepeat(limit);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Inverter()    &#123;        var tp = new BtInverter();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder DebugNode(string word)    &#123;        var node = new DebugNode(word);        AddBehavior(node);        return this;    &#125;    public void OnDisable()    &#123;        nodeStack.Clear();    &#125;&#125;\n构建行为树和行为树的使用\nprivate void Awake()&#123;    builder = new BehaviorTreeBuilder();    //行为树    BtBehaviour IsFindPlayerCondition = new BtActionNode(this, IsFindPlayer);    BtBehaviour EnterAtkDisCondition = new BtActionNode(this, EnterAtkDis);    BtBehaviour EnterDashDisCondition = new BtActionNode(this, EnterDashDis);    BtBehaviour EnterLAtkDisCondition = new BtActionNode(this, EnterLtkDis);    BtBehaviour EnterObeservehDisCondition = new BtActionNode(this, EnterObeservehDis);    BtBehaviour CanAttackCondition = new BtActionNode(this, CanAttack);    BtBehaviour CanDodgeCondition = new BtActionNode(this, CanDodge);    BtBehaviour CanSkillCondition = new BtActionNode(this, CanSkill);    BtBehaviour CanSkillACondition = new BtActionNode(this, CanSkillA);    BtBehaviour CanSkillBCondition = new BtActionNode(this, CanSkillB);    BtBehaviour BeAttackCondition = new BtActionNode(this, IsBeAttacked);    BtBehaviour NearPlayerAciton = new BtActionNode(this, NearPlayer);    BtBehaviour AttackPlayerAction = new BtActionNode(this, AttackPlayer);    BtBehaviour RollBackwardsAction = new BtActionNode(this, RollBackwards);    BtBehaviour ObservePlayerAction = new BtActionNode(this, ObservePlayer);    BtBehaviour BackOffAction = new BtActionNode(this, BackOff);    BtBehaviour DashSkillAction = new BtActionNode(this, UseDashSkill);    BtBehaviour CloseSkillAction = new BtActionNode(this, UseCloseSkill);    BtBehaviour IdleAction = new BtActionNode(this, Idle);    BtBehaviour BeAttackAcion = new BtActionNode(this, BeAttacked);    builder        .Seletctor()//1            .Sequence()                .AddBehavior(BeAttackCondition)                .AddBehavior(BeAttackAcion)            .Back()            .Sequence()//11                .AddBehavior(IsFindPlayerCondition)//111                    .Seletctor()//112                        .Sequence()//1121                            .Sequence()                                .Inverter()                                .AddBehavior(EnterAtkDisCondition)                                .Back()                            .Back()                            .Seletctor()                                .Sequence()//1121121                                    .AddBehavior(EnterDashDisCondition)                                    .AddBehavior(CanSkillCondition)                                    .AddBehavior(CanSkillACondition)                                    .AddBehavior(DashSkillAction)                                .Back()                                .Seletctor()                                    .Seletctor()                                        .Sequence()                                            .AddBehavior(CanAttackCondition)                                            .AddBehavior(NearPlayerAciton)                                        .Back()                                        .Sequence()                                            .AddBehavior(EnterObeservehDisCondition)                                            .AddBehavior(ObservePlayerAction)                                        .Back()                                    .Back()                                .Back()                            .Back()                        .Back()                        .Sequence()//1122                            .AddBehavior(EnterAtkDisCondition)                                .Seletctor()                                    .Sequence()//是否能够攻击                                        .AddBehavior(CanAttackCondition)                                        .AddBehavior(AttackPlayerAction)                                        .Back()                                    .Seletctor()                                        .Sequence()//能否使用近战技能                                            .AddBehavior(CanSkillCondition)                                            .AddBehavior(CanSkillBCondition)                                            .AddBehavior(CloseSkillAction)                                        .Back()                                        .Seletctor()                                            .Sequence()//翻滚                                                .AddBehavior(CanDodgeCondition)                                                .AddBehavior(RollBackwardsAction)                                            .Back()                                            .AddBehavior(BackOffAction)                                        .Back()                                    .Back()                                .Back()                        .Back()//1122                    .Back()//112            .Back()//11            .Sequence()//12                .Sequence()                    .Inverter()                    .AddBehavior(IsFindPlayerCondition)                    .Back()                .Back()                .AddBehavior(IdleAction)            .Back()//12        .Back()//1    .End();&#125;\n参考内容\nhttps://developer.unity.cn/projects/6569d98aedbc2a0a165f740e\n","categories":["Unity"]},{"title":"摄像机控制脚本","url":"/2025/12/30/CameraController/","content":"简单介绍\n拥有调节灵敏度、检测碰撞、锁定敌人的功能。\n完整代码\nusing UnityEngine;public class CameraMoveController : MonoBehaviour&#123;    private PlayerInputSystem _playerInput;    [SerializeField] private Transform LookAttarGet;    private Transform playerCamera;    [Range(0.1f, 1.0f), SerializeField, Header(&quot;鼠标灵敏度&quot;)] public float mouseInputSpeed;    [SerializeField, Header(&quot;相机对于玩家&quot;)] private float normalRadius;    [SerializeField] private float currentRadius;    private Vector2 ClmpCameraRang = new Vector2(-85f, 70f);    [SerializeField, Header(&quot;锁敌&quot;)] private bool isLockOn = false;    private Transform currentEnemy;    private float escapeDistance;    [SerializeField, Header(&quot;滑轮&quot;)] private float zoomSpeed = 1f;    [SerializeField] private Vector2 minMaxZoom = new Vector2(4f, 7f);    private float zoom = 1f;    [SerializeField, Header(&quot;相机碰撞&quot;)] public LayerMask collisionLayer;    private Vector3 rotationSmoothVelocity;    private float yaw;    private float pitch;    private void Start()    &#123;        normalRadius = 5f;        playerCamera = Camera.main.transform;        _playerInput = LookAttarGet.transform.root.GetComponent&lt;PlayerInputSystem&gt;();    &#125;    private void ControllerCamera()    &#123;        //相机缩放        if (zoom != 0)        &#123;            normalRadius -= zoom * normalRadius;            normalRadius = Mathf.Clamp(normalRadius, minMaxZoom.x, minMaxZoom.y);        &#125;        //相机旋转        if (!isLockOn)        &#123;            Quaternion targetRotation = Quaternion.Euler(new Vector3(pitch, yaw));            transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, 0.4f);            if (pitch &lt; -8f)            &#123;                currentRadius = Mathf.Lerp(currentRadius, normalRadius / 2f, 0.1f);            &#125;            else            &#123;                currentRadius = Mathf.Lerp(currentRadius, normalRadius, 0.1f);            &#125;        &#125;        //相机碰撞检测        Vector3 fanlePos = Vector3.zero;        if (Physics.Linecast(LookAttarGet.position + Vector3.up, playerCamera.position + (-playerCamera.forward.normalized), out var hit, collisionLayer))        &#123;            float currentDistance = Vector3.Distance(hit.point, LookAttarGet.position);            //Debug.Log(&quot;发生碰撞 &quot; + currentDistance);            if (currentDistance &lt;= minMaxZoom.y)            &#123;                currentRadius = currentDistance * 0.95f;            &#125;        &#125;        //相机跟踪        fanlePos = LookAttarGet.position - transform.forward * currentRadius;        transform.position = Vector3.Lerp(transform.position, fanlePos, 0.8f);    &#125;    private void GetCameraControllerInput()    &#123;        if (isLockOn) return;        yaw += _playerInput.cameraLook.x * mouseInputSpeed;        pitch -= _playerInput.cameraLook.y * mouseInputSpeed;        pitch = Mathf.Clamp(pitch, ClmpCameraRang.x, ClmpCameraRang.y);        zoom = Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * zoomSpeed;    &#125;    private void CameraLockOnTarget()    &#123;        if (!isLockOn) return;        Vector3 EnemyDir = ((currentEnemy.position + currentEnemy.transform.up * 0.3f) - transform.position).normalized;        Quaternion lookRotation = Quaternion.LookRotation(EnemyDir.normalized);        transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, 0.2f);    &#125;    private void LockEnemy()    &#123;        if (_playerInput.playerLockEnemy)        &#123;            Debug.Log(&quot;锁定敌人&quot;);            if (currentEnemy == null)            &#123;                Vector3 tempPosition = LookAttarGet.transform.position;                Vector3 center = tempPosition + new Vector3(0, 1.0f, 0) + transform.forward * 5.0f;                Collider[] col = Physics.OverlapBox(center, new Vector3(10f, 5f, 10f), transform.rotation, LayerMask.GetMask(&quot;Enemy&quot;));                if (col.Length != 0)                &#123;                    currentEnemy = col[0].transform;                    isLockOn = true;                &#125;            &#125;            else            &#123;                UnLock();            &#125;        &#125;        //距离太远，自动解除锁定        if (currentEnemy != null)        &#123;            if (Vector3.Distance(LookAttarGet.position, currentEnemy.position) &gt; escapeDistance)            &#123;                UnLock();            &#125;        &#125;    &#125;    private void UnLock()    &#123;        currentEnemy = null;        isLockOn = false;    &#125;    private void OnDrawGizmos()    &#123;        //Vector3 tempPosition = LookAttarGet.transform.position;        //Vector3 center = tempPosition + new Vector3(0, 1.0f, 0) + transform.forward * 5.0f;        //Gizmos.DrawCube(center, new Vector3(10f, 5f, 10f));    &#125;    private void Update()    &#123;        GetCameraControllerInput();//计算        LockEnemy();//选择锁定的敌人    &#125;    private void LateUpdate()    &#123;        ControllerCamera();//移动摄像头        CameraLockOnTarget();//锁定敌人    &#125;&#125;\n","categories":["Unity"]},{"title":"热更新中AB包的上传和下载（二）","url":"/2026/01/01/AssetBundle2/","content":"九、下载资源服务器的资源对比文件和AB包\n先创建Main脚本，挂载到场景的空物体上，这个脚本会在游戏开始执行Start()函数\n然后创建ABUpdateMgr脚本，ABUpdateMgr是单例类，让其里面的函数可以被Main脚本调用\nABUpdateMgr用来实现下载资源服务器上的资源对比文件和AB包\nMain脚本代码：\nusing UnityEngine;public class Main : MonoBehaviour&#123;    // Start is called before the first frame update    private void Start()    &#123;        ABUpdateMgr.Instance.DownLoadABCompareFile();        ABUpdateMgr.Instance.DownLoadABFile((isOver) =&gt;        &#123;            if (isOver)            &#123;                print(&quot;所有AB包下载结束&quot;);            &#125;            else            &#123;                print(&quot;AB包下载过程中出现错误&quot;);            &#125;        &#125;,        (nowNum, maxNum) =&gt;        &#123;            print(&quot;下载进度：&quot; + nowNum + &quot;/&quot; + maxNum);        &#125;        );        print(&quot;AB相关函数执行完毕&quot;);    &#125;    // Update is called once per frame    private void Update()    &#123;    &#125;&#125;\nABUpdateMgr脚本代码：\nusing JetBrains.Annotations;using System;using System.Collections.Generic;using System.IO;using System.Net;using System.Threading.Tasks;using UnityEngine;using UnityEngine.Events;public class ABUpdateMgr : MonoBehaviour&#123;    private static ABUpdateMgr instance;    private Dictionary&lt;string, ABInfo&gt; remoteABInfo = new Dictionary&lt;string, ABInfo&gt;();    private List&lt;string&gt; downLoadList = new List&lt;string&gt;();//待下载的AB包文件名字列表    public static ABUpdateMgr Instance    &#123;        get        &#123;            if (instance == null)            &#123;                GameObject obj = new GameObject(&quot;ABUpdateMgr&quot;);                instance = obj.AddComponent&lt;ABUpdateMgr&gt;();            &#125;            return instance;        &#125;    &#125;    public void DownLoadABCompareFile()    &#123;        print(Application.persistentDataPath);        //1.从资源服务器下载资源对比文件        DownLoadFile(&quot;ABCompareInfo.txt&quot;, Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;);        //2.获取资源对比文件，进行字符串进行拆分        string info = File.ReadAllText(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;);        string[] strs = info.Split(&#x27;|&#x27;);        string[] infos = null;        for (int i = 0; i &lt; strs.Length; i++)        &#123;            infos = strs[i].Split(&#x27; &#x27;);            //记录每一个远端AB包的信息            remoteABInfo.Add(infos[0], new ABInfo(infos[0], infos[1], infos[2]));        &#125;    &#125;    //存储远端AB包，之后和本地进行对比    public async void DownLoadABFile(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;int, int&gt; UpdatePro)    &#123;        //1.遍历字典的键，根据文件名，下载AB包到本地        foreach (string name in remoteABInfo.Keys)        &#123;            downLoadList.Add(name);        &#125;        //本地存储路径，由于多线程不能访问Unity相关的一些内容，所以放在外部        string localPath = Application.persistentDataPath + &quot;/&quot;;        //记录下载成功的文件名的列表        List&lt;string&gt; tempList = new List&lt;string&gt;();        //是否下载成功        bool isOver = false;        //重新下载的最大次数        int downloadNum = 5;        //下载成功的文件数量        int downLoadOverNum = 0;        //这一次需要下载的文件总数量        int downLoadMaxNum = downLoadList.Count;        while (downLoadList.Count &gt; 0 &amp;&amp; downloadNum &gt; 0)        &#123;            for (int i = 0; i &lt; downLoadList.Count; i++)            &#123;                await Task.Run(() =&gt;                &#123;                    isOver = DownLoadFile(downLoadList[i], localPath + downLoadList[i]);                &#125;                );                if (isOver)                &#123;                    UpdatePro(++downLoadOverNum, downLoadMaxNum);                    tempList.Add(downLoadList[i]);                &#125;            &#125;            //把下载成功的文件名从下载列表中移除            //也可以让倒着遍历下载列表，下载一个就移除一个，就不需要临时列表的辅助            for (int i = 0; i &lt; tempList.Count; i++) downLoadList.Remove(tempList[i]);            downloadNum--;        &#125;        overCallBack(downLoadList.Count == 0);//告诉外部，下载成功    &#125;    private bool DownLoadFile(string fileName, string localPath)    &#123;        try        &#123;            //1.创建FTP连接用于下载            FtpWebRequest req = FtpWebRequest.Create(new Uri(&quot;ftp://127.0.0.1/AB/PC/&quot; + fileName)) as FtpWebRequest;            //2.设置一个通信凭证，这样才能下载            //如果有匿名账号，可以不设置凭证，但实际开发中，不要使用匿名账号，不然有安全隐患            NetworkCredential n = new NetworkCredential(&quot;qwe&quot;, &quot;123000&quot;);            req.Credentials = n;            //3.其他设置            req.Proxy = null;//设置代理为空            req.KeepAlive = false;//请求完毕后，是否关闭控制连接            req.Method = WebRequestMethods.Ftp.DownloadFile;//操作命令-上传            req.UseBinary = true;//指定传输的类型-2进制            //4.下载文件            FtpWebResponse res = req.GetResponse() as FtpWebResponse;            Stream downFileStream = res.GetResponseStream();//ftp的流对象            using (FileStream file = File.Create(localPath))            &#123;                //一点一点下载                byte[] bytes = new byte[2048];                //读取了多少字节                int contentLength = downFileStream.Read(bytes, 0, bytes.Length);                //循环下载文件                while (contentLength != 0)                &#123;                    //写入到本地文件流中                    file.Write(bytes, 0, contentLength);                    //写完再读                    contentLength = downFileStream.Read(bytes, 0, bytes.Length);                &#125;                //循环完毕后，下载完毕                file.Close();                downFileStream.Close();                res.Close();            &#125;            return true;        &#125;        catch (Exception ex)        &#123;            Debug.Log(fileName + &quot;下载失败 &quot; + ex.Message);            return false;        &#125;        return true;    &#125;    private void OnDestroy()    &#123;        instance = null;    &#125;    //AB包信息类    private class ABInfo    &#123;        public string md5;        public string name;        public long size;        public ABInfo(string name, string size, string md5)        &#123;            this.name = name;            this.size = long.Parse(size);            this.md5 = md5;        &#125;    &#125;&#125;\n运行游戏后，可以看到资源对比文件下载成功的信息，以及文件的路径\n\n十、设置默认资源\n选择ArtRes/PC/AB中的文件夹的文件，加入StreamingAssets文件夹(需自己创建)，作为默认资源，并生成本地资源对比文件\n新建脚本MoveABToSA\n完整代码：\nusing System.IO;using UnityEditor;using UnityEngine;public class MoveABToSA&#123;    [MenuItem(&quot;Tool/移动选中资源到StreamingAssets&quot;)]    private static void MoveABToStreamingAssets()    &#123;        //通过Selction类的方法，获取选中的资源        Object[] selectedAssets = Selection.GetFiltered(typeof(Object), SelectionMode.DeepAssets);        if (selectedAssets.Length == 0) return;        string abCompareInfo = &quot;&quot;;        foreach (Object assset in selectedAssets)        &#123;            //通过AssetDatabase类获取资源的路径            string assetPath = AssetDatabase.GetAssetPath(assset);            //截取路径当中的文件名，用于作为StreamingAssets中的文件名            string fileName = assetPath.Substring(assetPath.LastIndexOf(&#x27;/&#x27;));            //判断是否有.符号，如果有，证明有后缀，不处理            if (fileName.IndexOf(&#x27;.&#x27;) != -1) continue;            //利用AssetDatabase类的方法，复制文件到StreamingAssets目录下            AssetDatabase.CopyAsset(assetPath, &quot;Assets/StreamingAssets/&quot; + fileName);            //获取拷贝到StreamingAssets文件下的文件的信息            FileInfo fileInfo = new FileInfo(Application.streamingAssetsPath + &quot;/&quot; + fileName);            abCompareInfo += fileInfo.Name + &quot; &quot; + fileInfo.Length + &quot; &quot; + CreateABCompare.getfileMd5(fileInfo.FullName);            abCompareInfo += &quot;|&quot;;        &#125;        abCompareInfo = abCompareInfo.Substring(0, abCompareInfo.Length - 1);        File.WriteAllText(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;, abCompareInfo);        AssetDatabase.Refresh();    &#125;&#125;\n选中默认资源，然后点击Tool下方的按钮\n\n之后可以在StreamingAssets文件夹下看到移动的文件和生成的本地资源对比文件\n\n十一、默认资源转存问题\n已知：\nStreamingAssetsPath中有默认的AB包资源（只读路径）\npersistentDataPath中有下载的最新AB包资源（可读可写路径）\nAB包的资源管理器的逻辑有两种实现方法：\n\n若资源都从可读写路径中加载，则需要转存，如果默认资源很多的话，会浪费玩家的硬盘存储空间\n若可读写路径中没有资源，则去只读路径中加载，这么做就不会浪费玩家空间\n\n\n进入游戏后热更新流程：\n\n第一次进入游戏，有默认资源：读取默认资源（只读路径里的内容）的对比文件和远端的对比文件，进行对比，下载指定AB包，然后将远端的对比文件存储到可读写路径中\n第一次进入游戏，没有默认资源：将下载所有远端对比文件中的AB包，存储到可读写路径\n非第一次进入游戏：从可读写路径中获取对比文件，与远端的对比文件进行对比，然后更新可读写路径中的文件\n\n\n十二、获取远端对比文件信息\n之前写的获取远端对比文件的代码不够完善，要保证获取资源服务器对比文件信息，但不覆盖本地的资源对比文件，因此需要修改\n有两种做法：\n\n保存到临时文件，待AB包下载完成后，再用该临时文件覆盖本地对比文件\n压根不保存文件，直接通过下载流取出字节数组转为字符串，待AB包下载完后再保存为本地资源对比文件\n这里使用做法1，我们需要修改ABUpdateMgr脚本的DownLoadABCompareFile函数\n\npublic void DownLoadABCompareFile()&#123;    print(Application.persistentDataPath);    //1.从资源服务器下载资源对比文件    DownLoadFile(&quot;ABCompareInfo.txt&quot;, Application.persistentDataPath + &quot;/ABCompareInfo_TMP.txt&quot;);    //2.获取资源对比文件，进行字符串进行拆分    string info = File.ReadAllText(Application.persistentDataPath + &quot;/ABCompareInfo_TMP.txt&quot;);    string[] strs = info.Split(&#x27;|&#x27;);    string[] infos = null;    for (int i = 0; i &lt; strs.Length; i++)    &#123;        infos = strs[i].Split(&#x27; &#x27;);        //记录每一个远端AB包的信息        remoteABInfo.Add(infos[0], new ABInfo(infos[0], infos[1], infos[2]));    &#125;&#125;\n十三、获取本地对比文件信息\n完整代码：\npublic void GetLocalABCompareFileInfo(UnityAction&lt;bool&gt; overCallBack)&#123;    //Application.persistentDataPath;    //Application.streamingAssetsPath;    //如果可读写文件夹中存在对比文件，说明之前下载更新过了    if (File.Exists(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;))    &#123;        StartCoroutine(GetLocalABCompareFileInfo(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;, overCallBack));    &#125;    //只有当可读写文件夹中没有对比文件时，才去读取默认资源文件夹中的对比文件（第一次进入游戏时发生）    else if (File.Exists(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;))    &#123;        StartCoroutine(GetLocalABCompareFileInfo(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;, overCallBack));    &#125;//如果两个都不满足，说明游戏第一次进入，且没有默认资源    else    &#123;        overCallBack(false);    &#125;    //StartCoroutine(GetLocalABCompareFileInfo);&#125;private IEnumerator GetLocalABCompareFileInfo(string filePath, UnityAction&lt;bool&gt; overCallBack)&#123;    //通过UnityWebRequest获取本地的AB对比文件    UnityWebRequest req = UnityWebRequest.Get(filePath);    yield return req.SendWebRequest();    //获取文件成功，继续往下执行    //print(req.downloadHandler.text);    if (req.result == UnityWebRequest.Result.Success)    &#123;        GetABCompareFIleInfo(req.downloadHandler.text, localABInfo);        overCallBack(true);    &#125;    else    &#123;        overCallBack(false);    &#125;&#125;\n根据十一提到的逻辑，获取本地的对比文件。如果可读写文件夹中存在对比文件，说明之前下载更新过了，那么直接获取可读写文件夹内对比文件的信息。\n只有当可读写文件夹中没有对比文件时，说明第一次进入游戏，去读取默认资源文件夹中的对比文件。\nGetABCompareFIleInfo函数的功能是获取对比文件的信息，而是否是远端还是本地，函数内部不做区分。\npublic void GetABCompareFIleInfo(string info, Dictionary&lt;string, ABInfo&gt; ABInfo)&#123;    //2.获取资源对比文件，进行字符串进行拆分    string[] strs = info.Split(&#x27;|&#x27;);    string[] infos = null;    for (int i = 0; i &lt; strs.Length; i++)    &#123;        infos = strs[i].Split(&#x27; &#x27;);        //记录每一个远端AB包的信息        ABInfo.Add(infos[0], new ABInfo(infos[0], infos[1], infos[2]));    &#125;&#125;\nDownLoadABCompareFile函数原本分为第一步：从资源服务器下载资源对比文件，和第二步：获取资源对比文件，进行字符串进行拆分。\nGetABCompareFIleInfo函数已经负责实现了第二步，因此DownLoadABCompareFile函数的逻辑需要进行修改。\npublic async void DownLoadABCompareFile(UnityAction&lt;bool&gt; overCallBack)&#123;    //1.从资源服务器下载资源对比文件    // www UnityWebRequest ftp相关api    print(Application.persistentDataPath);    bool isOver = false;    int reDownLoadMaxNum = 5;    //不能在子线程中访问Unity主线程的 Application 所以 在外面声明    string localPath = Application.persistentDataPath;    while (!isOver &amp;&amp; reDownLoadMaxNum &gt; 0)    &#123;        await Task.Run(() =&gt;        &#123;            isOver = DownLoadFile(&quot;ABCompareInfo.txt&quot;, localPath + &quot;/ABCompareInfo_TMP.txt&quot;);        &#125;);        --reDownLoadMaxNum;    &#125;    //告诉外部成功与否    overCallBack?.Invoke(isOver);&#125;\n接着，我们新建一个函数CheckUpdate，用于外部调用，外部只需要调用这个函数即可完成热更新。\npublic void CheckUpdate(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; updateInfoCallBack)&#123;    DownLoadABCompareFile((isOver1) =&gt;    &#123;        updateInfoCallBack(&quot;开始更新资源&quot;);        if (isOver1)        &#123;            //1.加载远端资源对比文件            updateInfoCallBack(&quot;对比文件下载结束&quot;);            string remoteInfo = File.ReadAllText(Application.persistentDataPath + &quot;/ABCompareInfo_TMP.txt&quot;);            updateInfoCallBack(&quot;解析远端对比文件&quot;);            GetABCompareFIleInfo(remoteInfo, remoteABInfo);            updateInfoCallBack(&quot;解析远端对比文件完成&quot;);            //2.加载本地资源对比文件            GetLocalABCompareFileInfo((isOver2) =&gt;            &#123;                if (isOver2)                &#123;                    updateInfoCallBack(&quot;解析本地对比文件完成&quot;);                    //3.对比两个文件，进行AB包的下载                &#125;                else                &#123;                    overCallBack(false);                &#125;            &#125;);        &#125;        else        &#123;            overCallBack(false);        &#125;    &#125;);&#125;\n同时，我们在Main脚本中进行修改\nusing UnityEngine;public class Main : MonoBehaviour&#123;    // Start is called before the first frame update    private void Start()    &#123;        ABUpdateMgr.Instance.CheckUpdate((isOver) =&gt;        &#123;            if (isOver)            &#123;                print(&quot;检测更新结束&quot;);            &#125;            else            &#123;                print(&quot;网络出错&quot;);            &#125;        &#125;, (str) =&gt;        &#123;            print(str);        &#125;);    &#125;    // Update is called once per frame    private void Update()    &#123;    &#125;&#125;\n游戏开始时，挂载在空物体上的Main脚本会运行Start函数，然后运行ABUpdateMgr单例类的CheckUpdate函数，进行热更新。\n十四、进行本地对比文件信息与远端对比文件信息之间的对比\n热更新的内容已经基本完成，接下来，我们还需要处理远端对比文件信息和本地对比文件信息之间的比较，然后根据比较的信息，下载需要更新的AB包。\n我们已经有了类型为Dictionary&lt;string, ABInfo&gt;的两个字典，remoteABInfo和localABInfo，分别存储远端对比文件信息和本地对比文件信息。\n需要进行三个步骤：\n\n判断哪些资源是新的，记录，之后用于下载；\n判断哪些资源需要更新，记录，然后用于下载；\n判断哪些资源需要删除\n\n我们需要修改DownLoadABFile函数\n这个函数的功能是根据downList列表来下载AB包\npublic async void DownLoadABFile(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; UpdatePro)&#123;    //1.遍历字典的键，根据文件名，下载AB包到本地    /*    foreach (string name in remoteABInfo.Keys)    &#123;        downLoadList.Add(name);    &#125;*/    //本地存储路径，由于多线程不能访问Unity相关的一些内容，所以放在外部    string localPath = Application.persistentDataPath + &quot;/&quot;;    //记录下载成功的文件名的列表    List&lt;string&gt; tempList = new List&lt;string&gt;();    //是否下载成功    bool isOver = false;    //重新下载的最大次数    int downloadNum = 5;    //下载成功的文件数量    int downLoadOverNum = 0;    //这一次需要下载的文件总数量    int downLoadMaxNum = downLoadList.Count;    while (downLoadList.Count &gt; 0 &amp;&amp; downloadNum &gt; 0)    &#123;        for (int i = 0; i &lt; downLoadList.Count; i++)        &#123;            await Task.Run(() =&gt;            &#123;                isOver = DownLoadFile(downLoadList[i], localPath + downLoadList[i]);            &#125;            );            if (isOver)            &#123;                UpdatePro(++downLoadOverNum + &quot;/&quot; + downLoadMaxNum);                tempList.Add(downLoadList[i]);            &#125;        &#125;        //把下载成功的文件名从下载列表中移除        //也可以让倒着遍历下载列表，下载一个就移除一个，就不需要临时列表的辅助        for (int i = 0; i &lt; tempList.Count; i++) downLoadList.Remove(tempList[i]);        downloadNum--;    &#125;    overCallBack(downLoadList.Count == 0);//告诉外部，下载成功&#125;\n接下来我们补充CheckUpdate函数的内容\npublic void CheckUpdate(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; updateInfoCallBack)&#123;    remoteABInfo.Clear();    localABInfo.Clear();    downLoadList.Clear();    DownLoadABCompareFile((isOver1) =&gt;    &#123;        updateInfoCallBack(&quot;开始更新资源&quot;);        if (isOver1)        &#123;            //1.加载远端资源对比文件            updateInfoCallBack(&quot;对比文件下载结束&quot;);            string remoteInfo = File.ReadAllText(Application.persistentDataPath + &quot;/ABCompareInfo_TMP.txt&quot;);            updateInfoCallBack(&quot;解析远端对比文件&quot;);            GetABCompareFIleInfo(remoteInfo, remoteABInfo);            updateInfoCallBack(&quot;解析远端对比文件完成&quot;);            //2.加载本地资源对比文件            GetLocalABCompareFileInfo((isOver2) =&gt;            &#123;                if (isOver2)                &#123;                    updateInfoCallBack(&quot;解析本地对比文件完成&quot;);                    //3.对比两个文件，进行AB包的下载                    updateInfoCallBack(&quot;开始对比&quot;);                    foreach (var abName in remoteABInfo.Keys)                    &#123;                        //3.1判断哪些资源是新的，记录，之后用于下载                        //如果本地没有对应的AB包，则加入待下载列表                        if (!localABInfo.ContainsKey(abName))                        &#123;                            downLoadList.Add(abName);                        &#125;                        //3.2判断哪些资源需要更新，记录，然后用于下载                        //本地有同名的AB包，判断是否需要更新                        else                        &#123;                            //如果本地有对应的AB包，则对比MD5值                            if (localABInfo[abName].md5 != remoteABInfo[abName].md5)                            &#123;                                downLoadList.Add(abName);                            &#125;                            //3.3判断哪些资源需要删除                            localABInfo.Remove(abName);//把已经对比过的，从本地字典中移除，剩下的就是需要删除的                        &#125;                    &#125;                    updateInfoCallBack(&quot;对比完成，删除无用的AB包文件&quot;);                    //对比完后，先删除没用的内容                    foreach (var abName in localABInfo.Keys)                    &#123;                        if (File.Exists(Application.persistentDataPath + &quot;/&quot; + abName))                        &#123;                            File.Delete(Application.persistentDataPath + &quot;/&quot; + abName);                        &#125;                    &#125;                    updateInfoCallBack(&quot;下载和更新AB包文件&quot;);                    DownLoadABFile((isOver3) =&gt;                    &#123;                        if (isOver3)                        &#123;                            //在下载完AB包后                            //把本地的AB包对比文件更新为最新                            //把之前读取的远端信息写到文件                            File.WriteAllText(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;, remoteInfo);                        &#125;                        overCallBack(isOver3);                    &#125;, updateInfoCallBack);                &#125;                else                &#123;                    overCallBack(false);                &#125;            &#125;);        &#125;        else        &#123;            overCallBack(false);        &#125;    &#125;);&#125;\nDownLoadABFile函数也做了修改，将UnityAction&lt;int,int&gt;改为了UnityAction，用来显示下载进度\npublic async void DownLoadABFile(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; UpdatePro)&#123;    //1.遍历字典的键，根据文件名，下载AB包到本地    /*    foreach (string name in remoteABInfo.Keys)    &#123;        downLoadList.Add(name);    &#125;*/    //本地存储路径，由于多线程不能访问Unity相关的一些内容，所以放在外部    string localPath = Application.persistentDataPath + &quot;/&quot;;    //记录下载成功的文件名的列表    List&lt;string&gt; tempList = new List&lt;string&gt;();    //是否下载成功    bool isOver = false;    //重新下载的最大次数    int downloadNum = 5;    //下载成功的文件数量    int downLoadOverNum = 0;    //这一次需要下载的文件总数量    int downLoadMaxNum = downLoadList.Count;    while (downLoadList.Count &gt; 0 &amp;&amp; downloadNum &gt; 0)    &#123;        for (int i = 0; i &lt; downLoadList.Count; i++)        &#123;            await Task.Run(() =&gt;            &#123;                isOver = DownLoadFile(downLoadList[i], localPath + downLoadList[i]);            &#125;            );            if (isOver)            &#123;                UpdatePro(++downLoadOverNum + &quot;/&quot; + downLoadMaxNum);                tempList.Add(downLoadList[i]);            &#125;        &#125;        //把下载成功的文件名从下载列表中移除        //也可以让倒着遍历下载列表，下载一个就移除一个，就不需要临时列表的辅助        for (int i = 0; i &lt; tempList.Count; i++) downLoadList.Remove(tempList[i]);        downloadNum--;    &#125;    overCallBack(downLoadList.Count == 0);//告诉外部，下载成功&#125;\n到此，热更新的主要逻辑已经完成。\n十五、完整代码\nUnity里的内容如下：\n\nCreateABCompare.cs\n创建AB对比文件\nusing System.IO;using System.Security.Cryptography;using System.Text;using UnityEditor;using UnityEngine;public class CreateABCompare&#123;    [MenuItem(&quot;Tool/创建AB包对比文件&quot;)]    public static void CreateABCompareFile()    &#123;        //获取文件夹信息        DirectoryInfo directory = Directory.CreateDirectory(            Application.dataPath + &quot;/ArtRes/AB/PC&quot;);        //获取该目录下所有文件        FileInfo[] files = directory.GetFiles();        //用于存储信息的字符串        string abCompareInfo = &quot;&quot;;        foreach (FileInfo file in files)        &#123;            //没有后缀的是AB包            if (file.Extension == &quot;&quot;)            &#123;                abCompareInfo += file.Name + &quot; &quot; + file.Length + &quot; &quot; + getfileMd5(file.FullName);                abCompareInfo += &quot;|&quot;;            &#125;        &#125;        //循环完毕后，截取最后一个“|”        abCompareInfo = abCompareInfo.Substring(0, abCompareInfo.Length - 1);        //存储信息        File.WriteAllText(Application.dataPath + &quot;/ArtRes/AB/PC/ABCompareInfo.txt&quot;, abCompareInfo);        AssetDatabase.Refresh();    &#125;    public static string getfileMd5(string filePath)    &#123;        //将文件以流的形式打开        using (FileStream file = new FileStream(filePath, FileMode.Open))        &#123;            MD5 md5 = new MD5CryptoServiceProvider();//声明一个MD5对象            byte[] md5Info = md5.ComputeHash(file);//获得数据MD5码 16个字节的数组            //关闭文件流            file.Close();            StringBuilder sb = new StringBuilder();            for (int i = 0; i &lt; md5Info.Length; i++)            &#123;                sb.Append(md5Info[i].ToString(&quot;x2&quot;));//转换成16进制字符串            &#125;            return sb.ToString();        &#125;    &#125;&#125;\nMoveABToSA.cs\n将AB包移动StreamingAssets文件夹作为默认资源\nusing System.IO;using UnityEditor;using UnityEngine;public class MoveABToSA&#123;    [MenuItem(&quot;Tool/移动选中资源到StreamingAssets&quot;)]    private static void MoveABToStreamingAssets()    &#123;        //通过Selction类的方法，获取选中的资源        Object[] selectedAssets = Selection.GetFiltered(typeof(Object), SelectionMode.DeepAssets);        if (selectedAssets.Length == 0) return;        string abCompareInfo = &quot;&quot;;        foreach (Object assset in selectedAssets)        &#123;            //通过AssetDatabase类获取资源的路径            string assetPath = AssetDatabase.GetAssetPath(assset);            //截取路径当中的文件名，用于作为StreamingAssets中的文件名            string fileName = assetPath.Substring(assetPath.LastIndexOf(&#x27;/&#x27;));            //判断是否有.符号，如果有，证明有后缀，不处理            if (fileName.IndexOf(&#x27;.&#x27;) != -1) continue;            //利用AssetDatabase类的方法，复制文件到StreamingAssets目录下            AssetDatabase.CopyAsset(assetPath, &quot;Assets/StreamingAssets/&quot; + fileName);            //获取拷贝到StreamingAssets文件下的文件的信息            FileInfo fileInfo = new FileInfo(Application.streamingAssetsPath + &quot;/&quot; + fileName);            abCompareInfo += fileInfo.Name + &quot; &quot; + fileInfo.Length + &quot; &quot; + CreateABCompare.getfileMd5(fileInfo.FullName);            abCompareInfo += &quot;|&quot;;        &#125;        abCompareInfo = abCompareInfo.Substring(0, abCompareInfo.Length - 1);        File.WriteAllText(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;, abCompareInfo);        AssetDatabase.Refresh();    &#125;&#125;\nUploadAB.cs\n上传AB包到资源服务器\nusing System;using System.IO;using System.Net;using System.Threading.Tasks;using UnityEditor;using UnityEngine;public class UploadAB&#123;    [MenuItem(&quot;Tool/上传AB包和对比文件&quot;)]    private static void UploadAllABFile()    &#123;        //获取文件夹信息        DirectoryInfo directory = Directory.CreateDirectory(            Application.dataPath + &quot;/ArtRes/AB/PC&quot;);        //获取该目录下所有文件        FileInfo[] files = directory.GetFiles();        foreach (FileInfo file in files)        &#123;            //Debug.Log(file.Name + &quot; &quot; + file.Extension);            if (file.Extension == &quot;&quot; || file.Extension == &quot;.txt&quot;)            &#123;                FtpUploadFile(file.FullName, file.Name);            &#125;        &#125;    &#125;    private static async void FtpUploadFile(string filePath, string fileName)    &#123;        //异步处理，在上传文件时，不会卡住主线程        await Task.Run(() =&gt;        &#123;            try            &#123;                //1.创建FTP连接用于上传                FtpWebRequest req = FtpWebRequest.Create(new Uri(&quot;ftp://127.0.0.1/AB/PC/&quot; + fileName)) as FtpWebRequest;                //2.设置一个通信凭证，这样才能上传                NetworkCredential n = new NetworkCredential(&quot;qwe&quot;, &quot;123000&quot;);                req.Credentials = n;                //3.其他设置                req.Proxy = null;//设置代理为空                req.KeepAlive = false;//请求完毕后，是否关闭控制连接                req.Method = WebRequestMethods.Ftp.UploadFile;//操作命令-上传                req.UseBinary = true;//指定传输的类型-2进制                //4.上传文件                Stream upLoadStream = req.GetRequestStream();//ftp的流对象                                                             //读取文件信息，写入该流对象                using (FileStream file = File.OpenRead(filePath))                &#123;                    //一点一点上传                    byte[] bytes = new byte[2048];                    //读取了多少字节                    int contentLength = file.Read(bytes, 0, bytes.Length);                    //循环上传文件                    while (contentLength != 0)                    &#123;                        //写入到上传流中                        upLoadStream.Write(bytes, 0, contentLength);                        //写完再读                        contentLength = file.Read(bytes, 0, bytes.Length);                    &#125;                    //循环完毕后，上传完毕                    file.Close();                    upLoadStream.Close();                &#125;            &#125;            catch (Exception ex)            &#123;                Debug.Log(&quot;上传失败 &quot; + ex.Message);            &#125;            Debug.Log(fileName + &quot;上传成功&quot;);        &#125;        );    &#125;&#125;\nABUpdateMgr.cs\n单例类，完成热更新的逻辑\nusing System;using System.Collections;using System.Collections.Generic;using System.IO;using System.Net;using System.Threading.Tasks;using UnityEngine;using UnityEngine.Events;using UnityEngine.Networking;public class ABUpdateMgr : MonoBehaviour&#123;    private static ABUpdateMgr instance;    private Dictionary&lt;string, ABInfo&gt; remoteABInfo = new Dictionary&lt;string, ABInfo&gt;();//存储远端AB包信息的字典    private Dictionary&lt;string, ABInfo&gt; localABInfo = new Dictionary&lt;string, ABInfo&gt;();//存储本地AB包信息的字典    private List&lt;string&gt; downLoadList = new List&lt;string&gt;();//待下载的AB包文件名字列表    public static ABUpdateMgr Instance    &#123;        get        &#123;            if (instance == null)            &#123;                GameObject obj = new GameObject(&quot;ABUpdateMgr&quot;);                instance = obj.AddComponent&lt;ABUpdateMgr&gt;();            &#125;            return instance;        &#125;    &#125;    public void CheckUpdate(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; updateInfoCallBack)    &#123;        remoteABInfo.Clear();        localABInfo.Clear();        downLoadList.Clear();        DownLoadABCompareFile((isOver1) =&gt;        &#123;            updateInfoCallBack(&quot;开始更新资源&quot;);            if (isOver1)            &#123;                //1.加载远端资源对比文件                updateInfoCallBack(&quot;对比文件下载结束&quot;);                string remoteInfo = File.ReadAllText(Application.persistentDataPath + &quot;/ABCompareInfo_TMP.txt&quot;);                updateInfoCallBack(&quot;解析远端对比文件&quot;);                GetABCompareFIleInfo(remoteInfo, remoteABInfo);                updateInfoCallBack(&quot;解析远端对比文件完成&quot;);                //2.加载本地资源对比文件                GetLocalABCompareFileInfo((isOver2) =&gt;                &#123;                    if (isOver2)                    &#123;                        updateInfoCallBack(&quot;解析本地对比文件完成&quot;);                        //3.对比两个文件，进行AB包的下载                        updateInfoCallBack(&quot;开始对比&quot;);                        foreach (var abName in remoteABInfo.Keys)                        &#123;                            //3.1判断哪些资源是新的，记录，之后用于下载                            //如果本地没有对应的AB包，则加入待下载列表                            if (!localABInfo.ContainsKey(abName))                            &#123;                                downLoadList.Add(abName);                            &#125;                            //3.2判断哪些资源需要更新，记录，然后用于下载                            //本地有同名的AB包，判断是否需要更新                            else                            &#123;                                //如果本地有对应的AB包，则对比MD5值                                if (localABInfo[abName].md5 != remoteABInfo[abName].md5)                                &#123;                                    downLoadList.Add(abName);                                &#125;                                //3.3判断哪些资源需要删除                                localABInfo.Remove(abName);//把已经对比过的，从本地字典中移除，剩下的就是需要删除的                            &#125;                        &#125;                        updateInfoCallBack(&quot;对比完成，删除无用的AB包文件&quot;);                        //对比完后，先删除没用的内容                        foreach (var abName in localABInfo.Keys)                        &#123;                            if (File.Exists(Application.persistentDataPath + &quot;/&quot; + abName))                            &#123;                                File.Delete(Application.persistentDataPath + &quot;/&quot; + abName);                            &#125;                        &#125;                        updateInfoCallBack(&quot;下载和更新AB包文件&quot;);                        DownLoadABFile((isOver3) =&gt;                        &#123;                            if (isOver3)                            &#123;                                //在下载完AB包后                                //把本地的AB包对比文件更新为最新                                //把之前读取的远端信息写到文件                                File.WriteAllText(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;, remoteInfo);                            &#125;                            overCallBack(isOver3);                        &#125;, updateInfoCallBack);                    &#125;                    else                    &#123;                        overCallBack(false);                    &#125;                &#125;);            &#125;            else            &#123;                overCallBack(false);            &#125;        &#125;);    &#125;    public async void DownLoadABCompareFile(UnityAction&lt;bool&gt; overCallBack)    &#123;        //1.从资源服务器下载资源对比文件        // www UnityWebRequest ftp相关api        print(Application.persistentDataPath);        bool isOver = false;        int reDownLoadMaxNum = 5;        //不能在子线程中访问Unity主线程的 Application 所以 在外面声明        string localPath = Application.persistentDataPath;        while (!isOver &amp;&amp; reDownLoadMaxNum &gt; 0)        &#123;            await Task.Run(() =&gt;            &#123;                isOver = DownLoadFile(&quot;ABCompareInfo.txt&quot;, localPath + &quot;/ABCompareInfo_TMP.txt&quot;);            &#125;);            --reDownLoadMaxNum;        &#125;        //告诉外部成功与否        overCallBack?.Invoke(isOver);    &#125;    public void GetABCompareFIleInfo(string info, Dictionary&lt;string, ABInfo&gt; ABInfo)    &#123;        //2.获取资源对比文件，进行字符串进行拆分        string[] strs = info.Split(&#x27;|&#x27;);        string[] infos = null;        for (int i = 0; i &lt; strs.Length; i++)        &#123;            infos = strs[i].Split(&#x27; &#x27;);            //记录每一个远端AB包的信息            ABInfo.Add(infos[0], new ABInfo(infos[0], infos[1], infos[2]));        &#125;    &#125;    public void GetLocalABCompareFileInfo(UnityAction&lt;bool&gt; overCallBack)    &#123;        //Application.persistentDataPath;        //Application.streamingAssetsPath;        //如果可读写文件夹中存在对比文件，说明之前下载更新过了        if (File.Exists(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;))        &#123;            StartCoroutine(GetLocalABCompareFileInfo(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;, overCallBack));        &#125;        //只有当可读写文件夹中没有对比文件时，才去读取默认资源文件夹中的对比文件（第一次进入游戏时发生）        else if (File.Exists(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;))        &#123;            StartCoroutine(GetLocalABCompareFileInfo(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;, overCallBack));        &#125;//如果两个都不满足，说明游戏第一次进入，且没有默认资源        else        &#123;            overCallBack(false);        &#125;        //StartCoroutine(GetLocalABCompareFileInfo);    &#125;    private IEnumerator GetLocalABCompareFileInfo(string filePath, UnityAction&lt;bool&gt; overCallBack)    &#123;        //通过UnityWebRequest获取本地的AB对比文件        UnityWebRequest req = UnityWebRequest.Get(filePath);        yield return req.SendWebRequest();        //获取文件成功，继续往下执行        //print(req.downloadHandler.text);        if (req.result == UnityWebRequest.Result.Success)        &#123;            GetABCompareFIleInfo(req.downloadHandler.text, localABInfo);            overCallBack(true);        &#125;        else        &#123;            overCallBack(false);        &#125;    &#125;    //存储远端AB包，之后和本地进行对比    public async void DownLoadABFile(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; UpdatePro)    &#123;        //1.遍历字典的键，根据文件名，下载AB包到本地        /*        foreach (string name in remoteABInfo.Keys)        &#123;            downLoadList.Add(name);        &#125;*/        //本地存储路径，由于多线程不能访问Unity相关的一些内容，所以放在外部        string localPath = Application.persistentDataPath + &quot;/&quot;;        //记录下载成功的文件名的列表        List&lt;string&gt; tempList = new List&lt;string&gt;();        //是否下载成功        bool isOver = false;        //重新下载的最大次数        int downloadNum = 5;        //下载成功的文件数量        int downLoadOverNum = 0;        //这一次需要下载的文件总数量        int downLoadMaxNum = downLoadList.Count;        while (downLoadList.Count &gt; 0 &amp;&amp; downloadNum &gt; 0)        &#123;            for (int i = 0; i &lt; downLoadList.Count; i++)            &#123;                await Task.Run(() =&gt;                &#123;                    isOver = DownLoadFile(downLoadList[i], localPath + downLoadList[i]);                &#125;                );                if (isOver)                &#123;                    UpdatePro(++downLoadOverNum + &quot;/&quot; + downLoadMaxNum);                    tempList.Add(downLoadList[i]);                &#125;            &#125;            //把下载成功的文件名从下载列表中移除            //也可以让倒着遍历下载列表，下载一个就移除一个，就不需要临时列表的辅助            for (int i = 0; i &lt; tempList.Count; i++) downLoadList.Remove(tempList[i]);            downloadNum--;        &#125;        overCallBack(downLoadList.Count == 0);//告诉外部，下载成功    &#125;    private bool DownLoadFile(string fileName, string localPath)    &#123;        try        &#123;            //1.创建FTP连接用于下载            FtpWebRequest req = FtpWebRequest.Create(new Uri(&quot;ftp://127.0.0.1/AB/PC/&quot; + fileName)) as FtpWebRequest;            //2.设置一个通信凭证，这样才能下载            //如果有匿名账号，可以不设置凭证，但实际开发中，不要使用匿名账号，不然有安全隐患            NetworkCredential n = new NetworkCredential(&quot;qwe&quot;, &quot;123000&quot;);            req.Credentials = n;            //3.其他设置            req.Proxy = null;//设置代理为空            req.KeepAlive = false;//请求完毕后，是否关闭控制连接            req.Method = WebRequestMethods.Ftp.DownloadFile;//操作命令-上传            req.UseBinary = true;//指定传输的类型-2进制            //4.下载文件            FtpWebResponse res = req.GetResponse() as FtpWebResponse;            Stream downFileStream = res.GetResponseStream();//ftp的流对象            using (FileStream file = File.Create(localPath))            &#123;                //一点一点下载                byte[] bytes = new byte[2048];                //读取了多少字节                int contentLength = downFileStream.Read(bytes, 0, bytes.Length);                //循环下载文件                while (contentLength != 0)                &#123;                    //写入到本地文件流中                    file.Write(bytes, 0, contentLength);                    //写完再读                    contentLength = downFileStream.Read(bytes, 0, bytes.Length);                &#125;                //循环完毕后，下载完毕                file.Close();                downFileStream.Close();                res.Close();            &#125;            return true;        &#125;        catch (Exception ex)        &#123;            Debug.Log(fileName + &quot;下载失败 &quot; + ex.Message);            return false;        &#125;    &#125;    private void OnDestroy()    &#123;        instance = null;    &#125;    //AB包信息类    public class ABInfo    &#123;        public string md5;        public string name;        public long size;        public ABInfo(string name, string size, string md5)        &#123;            this.name = name;            this.size = long.Parse(size);            this.md5 = md5;        &#125;    &#125;&#125;\nMain.cs\nusing UnityEngine;public class Main : MonoBehaviour&#123;    // Start is called before the first frame update    private void Start()    &#123;        ABUpdateMgr.Instance.CheckUpdate((isOver) =&gt;        &#123;            if (isOver)            &#123;                print(&quot;检测更新结束&quot;);            &#125;            else            &#123;                print(&quot;网络出错&quot;);            &#125;        &#125;, (str) =&gt;        &#123;            print(str);        &#125;);    &#125;    // Update is called once per frame    private void Update()    &#123;    &#125;&#125;\n参考内容\nhttps://www.bilibili.com/video/BV1VP411G7w2?spm_id_from=333.788.videopod.sections&amp;vd_source=5ddeed13107206194ba5b740648582d3\n","categories":["Unity"]},{"title":"黑板模式","url":"/2025/12/30/BlackBoardMode/","content":"简单介绍\n黑板是一个共享数据的系统，进行游戏系统的不同模块之间的通信，比起将越来越多的变量存在Player类中，不如集中存在一个地方进行集中管理。\n下面的代码是一些我在之前的课程项目中实现的黑板，目的是存储敌人ai的技能cd。\n当ai使用完技能后，就会调用黑板里面的函数，让技能能否使用的布尔变量变为false，并在一段时间后变为true。\n这是比较简单的黑板，如果要实现更复杂的功能，就需要自己写出对应的实现。\n完整代码\n[Serializable]private class BlackBoardTimer&#123;    public float Timer;    public string Key;    public mData Value;    public BlackBoardTimer(float timer, string key, mData value)    &#123;        Timer = timer;        Key = key;        Value = value;    &#125;&#125;[Serializable]private class mData&#123;    public enum Type    &#123; Int, Float, Bool, String, Vector3, Transform &#125;;    public string name;    public Type type;    public int intValue;    public float floatValue;    public bool boolValue;    public string stringValue;    public Vector3 vector3Value;    public Transform transformValue;    public mData(string key, int value)    &#123;        name = key;        type = Type.Int;        intValue = value;    &#125;    public mData(string key, float value)    &#123;        name = key;        type = Type.Float;        floatValue = value;    &#125;    public mData(string key, bool value)    &#123;        name = key;        type = Type.Bool;        boolValue = value;    &#125;    public mData(string key, string value)    &#123;        name = key;        type = Type.String;        stringValue = value;    &#125;    public mData(string key, Vector3 value)    &#123;        name = key;        type = Type.Vector3;        vector3Value = value;    &#125;    public mData(string key, Transform value)    &#123;        name = key;        type = Type.Transform;        transformValue = value;    &#125;&#125;[SerializeField] private SerializedDictionary&lt;string, mData&gt; mDatas = new SerializedDictionary&lt;string, mData&gt;();[SerializeField] private List&lt;BlackBoardTimer&gt; mTimers = new List&lt;BlackBoardTimer&gt;();// 设置数据public void SetValue(string key, bool value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, bool value, float expiredTime, bool expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, int value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, int value, float expiredTime, int expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, float value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, float value, float expiredTime, float expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, string value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Vector3 value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Vector3 value, float expiredTime, Vector3 expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    mDatas[key] = new mData(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, Transform value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Transform value, float expiredTime, Transform expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    mDatas[key] = new mData(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;// 访问数据public int GetInt(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Int)    &#123;        return value.intValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not an int.&quot;);&#125;public float GetFloat(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Float)    &#123;        return value.floatValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a float.&quot;);&#125;public bool GetBool(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Bool)    &#123;        return value.boolValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a bool.&quot;);&#125;public string GetString(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.String)    &#123;        return value.stringValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a string.&quot;);&#125;public Vector3 GetVector3(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Vector3)    &#123;        return value.vector3Value;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a Vector3.&quot;);&#125;public Transform GetTransform(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Transform)    &#123;        return value.transformValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a Transform.&quot;);&#125;private void Update()&#123;    for (int i = mTimers.Count - 1; i &gt;= 0; i--)    &#123;        var timer = mTimers[i];        timer.Timer -= Time.deltaTime / Time.timeScale;        if (timer.Timer &lt;= 0.0f)        &#123;            mDatas[timer.Key] = timer.Value;            mTimers.RemoveAt(i);        &#125;    &#125;&#125;\n参考内容\nhttps://www.cnblogs.com/KillerAery/p/10054558.html\n","categories":["Unity"]},{"title":"如何建立一个博客","url":"/2025/12/29/HowBuildBlog/","content":"一、安装Hexo并初始化博客\n1.安装Hexo\n在安装Hexo之前，需要安装Git，Node.js，具体过程可以直接看https://hexo.io/zh-cn/docs/\n然后在终端中执行命令\nnpm install -g hexo-cli\n2.初始化博客\n\n新建一个文件夹作为博客根目录（我的是D:!myths\\blog）\n在终端中输入命令进入根目录\ncd D:\\!myths\\blog\n执行初始化命令\nnpx hexo init\n安装依赖包\nnpm install\n做完上述步骤后，D:!myths\\blog文件夹中出现以下文件夹：\n\n\n_config.yml：Hexo 全局配置文件（核心，用于配置博客标题、主题、部署信息等）；\nsource/：存放博客原始内容，_posts/ 文件夹用于存放所有博客文章（Markdown 格式）；\nthemes/：存放博客主题，默认主题为 landscape；\npublic/：Hexo 生成的静态网页文件（部署时需上传该目录内容）；\nscaffolds/：文章模板文件，新建文章时会基于模板生成。\n3.本地预览博客\n\n生成静态网页文件\nnpx hexo generate\n或者\nnpx hexo g\n启动本地服务器\nnpx hexo server\n或者\nnpx hexo s\n打开浏览器，访问http://localhost:4000\n\n4.创作博客文章\n\n新建博客文章\nnpx hexo new &quot;blog name&quot;\n使用命令后，文章会生成在source/_posts/目录下\n编辑博客文章\n用Markdown编辑器打开_posts下的md文件\n编辑后执行命令npx hexo clean &amp;&amp; npx hexo generate &amp;&amp; npx hexo deploy，博客里面的内容就会改变\n\n二、在github上配置SSH\n\n打开git bash\n\n\n\n生成秘钥对\nssh-keygen -t rsa -C &quot;你的github邮箱@xxx.com&quot;\n一路回车即可\n查看公钥内容，复制到剪切板上\ncat ~/.ssh/id_rsa.pub\n打开github，新建一个仓库，仓库名为你的名字.github.io\n在上方导航栏点开仓库的Setting，在左侧导航栏找到Deploy keys\n\n\n\n在Deploy Keys界面点击Add deploy key按钮\n\n\n\nTitle随便填，将之前复制的公钥内容粘贴到Key里面，然后点击Add key\n\n\n\n在git bash中输入命令ssh -T git@github.com，如果出现successfully的信息，就代表成功了。\n\n\n三、部署Hexo博客到Github Pages上\n\n记录仓库的SSH地址\n如果上述步骤都没问题的话，那么SSH地址应该是git@github.com:你的github的名字/你的github的名字.github.io.git\n安装Hexo部署插件\n在之前建立的博客根目录中在终端中执行命令\nnpm install hexo-deployer-git\n编辑部署信息\n打开根目录中的_config.yml文件，找到deploy配置项\n\n\n在repo填上仓库的SSH地址，要注意冒号后面有个空格\n\n部署博客到github\n在终端执行命令：\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n之后访问https://你的用户名.github.io，即可公网访问你的博客\n\n四、常用命令\n新建文章：npx hexo new &quot;文章名&quot;\n生成静态文件：npx hexo generate\n启动服务器：npx hexo server\n部署网站：npx hexo deploy\n清除缓存文件：npx hexo clean\n参考资料\nhttps://blog.csdn.net/qq_37294163/article/details/103099424\nhttps://blog.csdn.net/weixin_73527660/article/details/156200825\n","categories":["其他"]},{"title":"UI系统","url":"/2025/12/30/UISystem/","content":"完整代码\n\nBasePanel.cs\n\nusing UnityEngine;public class BasePanel : MonoBehaviour&#123;    protected bool isRemove = false;    protected new string name;    public virtual void OpenPanel(string name)    &#123;        this.name = name;        gameObject.SetActive(true);    &#125;    public virtual void ClosePanel()    &#123;        isRemove = true;        gameObject.SetActive(false);        Destroy(gameObject);        if (UIManager.Instance.panelDict.ContainsKey(name))        &#123;            UIManager.Instance.panelDict.Remove(name);        &#125;    &#125;&#125;\n\nUIManager.cs\n\npublic class UIConst&#123;    public const string MainMenuPanel = &quot;MainMenuPanel&quot;;    public const string SettingPanel = &quot;SettingPanel&quot;;    public const string PlayerStatePanel = &quot;PlayerStateBar&quot;;    public const string EnemyStatePanel = &quot;EnemyStateBar&quot;;    public const string DialoguePanel = &quot;DialoguePanel&quot;;&#125;public class UIManager&#123;    private static UIManager _instance;    private Transform _uiRoot;    private Dictionary&lt;string, string&gt; pathDict;    private Dictionary&lt;string, GameObject&gt; prefabsDict;    public Dictionary&lt;string, BasePanel&gt; panelDict;    public static UIManager Instance    &#123;        get        &#123;            if (_instance == null)            &#123;                _instance = new UIManager();            &#125;            return _instance;        &#125;    &#125;    public Transform UIRoot    &#123;        get        &#123;            if (_uiRoot == null)            &#123;                if (GameObject.Find(&quot;Canvas&quot;))                &#123;                    _uiRoot = GameObject.Find(&quot;Canvas&quot;).transform;                &#125;                else                &#123;                    _uiRoot = new GameObject(&quot;Canvas&quot;).transform;                &#125;            &#125;            return _uiRoot;        &#125;    &#125;    private UIManager()    &#123;        InitDicts();    &#125;    private void InitDicts()    &#123;        prefabsDict = new Dictionary&lt;string, GameObject&gt;();        panelDict = new Dictionary&lt;string, BasePanel&gt;();        pathDict = new Dictionary&lt;string, string&gt;()        &#123;            &#123; UIConst.MainMenuPanel ,UIConst.MainMenuPanel&#125;,            &#123; UIConst.SettingPanel ,UIConst.SettingPanel&#125;,            &#123; UIConst.PlayerStatePanel ,UIConst.PlayerStatePanel&#125;,            &#123; UIConst.EnemyStatePanel ,UIConst.EnemyStatePanel&#125;,            &#123; UIConst.DialoguePanel ,UIConst.DialoguePanel&#125;        &#125;;    &#125;    public BasePanel OpenPanel(string name)    &#123;        BasePanel panel = null;        if (panelDict.TryGetValue(name, out panel))        &#123;            Debug.Log(&quot;界面已打开&quot;);            return null;        &#125;        string path = &quot;&quot;;        if (!pathDict.TryGetValue(name, out path))        &#123;            Debug.Log(&quot;界面名称错误，或未配置路径 &quot; + name);            return null;        &#125;        GameObject panelPrefab = null;        if (!prefabsDict.TryGetValue(name, out panelPrefab))        &#123;            string realPath = &quot;Prefabs/UI/&quot; + path;//需在Resources/Prefabs/UI文件夹下放置UI的预制体            panelPrefab = Resources.Load&lt;GameObject&gt;(realPath) as GameObject;            prefabsDict.Add(name, panelPrefab);        &#125;        GameObject panelObject = GameObject.Instantiate(panelPrefab, UIRoot, false);        panelObject.transform.position = UIRoot.position;        panel = panelObject.GetComponent&lt;BasePanel&gt;();        panelDict.Add(name, panel);        panel.OpenPanel(name);        return panel;    &#125;    public bool ClosePanel(string name)    &#123;        BasePanel panel = null;        if (!panelDict.TryGetValue(name, out panel))        &#123;            Debug.Log(&quot;界面未打开&quot; + name);            return false;        &#125;        panel.ClosePanel();        return true;    &#125;&#125;","categories":["Unity"]},{"title":"单例模式的实现","url":"/2025/12/30/SingletonMode/","content":"完整代码\nusing UnityEngine;public class ClassName : MonoBehaviour&#123;    private static ClassName instance;    public static ClassName Instance    &#123;        get        &#123;            if (instance == null)            &#123;                GameObject obj = new GameObject(&quot;ClassName&quot;);                instance = obj.AddComponent&lt;ClassName&gt;();            &#125;            return instance;        &#125;    &#125;    private void OnDestroy()    &#123;        instance = null;    &#125;&#125;\n如果需要普通类的单例模式，只需要将简单修改即可\npublic class ClassName&#123;    private static ClassName instance;    public static ClassName Instance    &#123;        get        &#123;            if (instance == null)            &#123;                instance =  new ClassName();            &#125;            return instance;        &#125;    &#125;&#125;\n在以上代码的基础上，可以进行一些进阶处理\npublic class Singleton&lt;T&gt; where T : class, new()&#123;    private static T m_instance;    private static readonly object syslock = new object();    public static T Instance    &#123;        get        &#123;            if (m_instance == null)            &#123;                lock (syslock)                &#123;                    if (m_instance == null)                    &#123;                        m_instance = new T();                    &#125;                &#125;            &#125;            return m_instance;        &#125;    &#125;&#125;\n","categories":["Unity"]}]