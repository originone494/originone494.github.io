[{"title":"黑板模式","url":"/2025/12/30/BlackBoardMode/","content":"简单介绍\n黑板是一个共享数据的系统，进行游戏系统的不同模块之间的通信，比起将越来越多的变量存在Player类中，不如集中存在一个地方进行集中管理。\n下面的代码是一些我在之前的课程项目中实现的黑板，目的是存储敌人ai的技能cd。\n当ai使用完技能后，就会调用黑板里面的函数，让技能能否使用的布尔变量变为false，并在一段时间后变为true。\n这是比较简单的黑板，如果要实现更复杂的功能，就需要自己写出对应的实现。\n完整代码\n[Serializable]private class BlackBoardTimer&#123;    public float Timer;    public string Key;    public mData Value;    public BlackBoardTimer(float timer, string key, mData value)    &#123;        Timer = timer;        Key = key;        Value = value;    &#125;&#125;[Serializable]private class mData&#123;    public enum Type    &#123; Int, Float, Bool, String, Vector3, Transform &#125;;    public string name;    public Type type;    public int intValue;    public float floatValue;    public bool boolValue;    public string stringValue;    public Vector3 vector3Value;    public Transform transformValue;    public mData(string key, int value)    &#123;        name = key;        type = Type.Int;        intValue = value;    &#125;    public mData(string key, float value)    &#123;        name = key;        type = Type.Float;        floatValue = value;    &#125;    public mData(string key, bool value)    &#123;        name = key;        type = Type.Bool;        boolValue = value;    &#125;    public mData(string key, string value)    &#123;        name = key;        type = Type.String;        stringValue = value;    &#125;    public mData(string key, Vector3 value)    &#123;        name = key;        type = Type.Vector3;        vector3Value = value;    &#125;    public mData(string key, Transform value)    &#123;        name = key;        type = Type.Transform;        transformValue = value;    &#125;&#125;[SerializeField] private SerializedDictionary&lt;string, mData&gt; mDatas = new SerializedDictionary&lt;string, mData&gt;();[SerializeField] private List&lt;BlackBoardTimer&gt; mTimers = new List&lt;BlackBoardTimer&gt;();// 设置数据public void SetValue(string key, bool value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, bool value, float expiredTime, bool expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, int value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, int value, float expiredTime, int expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, float value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, float value, float expiredTime, float expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, string value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Vector3 value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Vector3 value, float expiredTime, Vector3 expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    mDatas[key] = new mData(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, Transform value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Transform value, float expiredTime, Transform expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    mDatas[key] = new mData(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;// 访问数据public int GetInt(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Int)    &#123;        return value.intValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not an int.&quot;);&#125;public float GetFloat(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Float)    &#123;        return value.floatValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a float.&quot;);&#125;public bool GetBool(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Bool)    &#123;        return value.boolValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a bool.&quot;);&#125;public string GetString(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.String)    &#123;        return value.stringValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a string.&quot;);&#125;public Vector3 GetVector3(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Vector3)    &#123;        return value.vector3Value;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a Vector3.&quot;);&#125;public Transform GetTransform(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Transform)    &#123;        return value.transformValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a Transform.&quot;);&#125;private void Update()&#123;    for (int i = mTimers.Count - 1; i &gt;= 0; i--)    &#123;        var timer = mTimers[i];        timer.Timer -= Time.deltaTime / Time.timeScale;        if (timer.Timer &lt;= 0.0f)        &#123;            mDatas[timer.Key] = timer.Value;            mTimers.RemoveAt(i);        &#125;    &#125;&#125;\n参考内容\nhttps://www.cnblogs.com/KillerAery/p/10054558.html\n","categories":["Unity"]},{"title":"如何建立一个博客","url":"/2025/12/29/HowBuildBlog/","content":"一、安装Hexo并初始化博客\n1.安装Hexo\n在安装Hexo之前，需要安装Git，Node.js，具体过程可以直接看https://hexo.io/zh-cn/docs/\n然后在终端中执行命令\nnpm install -g hexo-cli\n2.初始化博客\n\n新建一个文件夹作为博客根目录（我的是D:!myths\\blog）\n在终端中输入命令进入根目录\ncd D:\\!myths\\blog\n执行初始化命令\nnpx hexo init\n安装依赖包\nnpm install\n做完上述步骤后，D:!myths\\blog文件夹中出现以下文件夹：\n\n\n_config.yml：Hexo 全局配置文件（核心，用于配置博客标题、主题、部署信息等）；\nsource/：存放博客原始内容，_posts/ 文件夹用于存放所有博客文章（Markdown 格式）；\nthemes/：存放博客主题，默认主题为 landscape；\npublic/：Hexo 生成的静态网页文件（部署时需上传该目录内容）；\nscaffolds/：文章模板文件，新建文章时会基于模板生成。\n3.本地预览博客\n\n生成静态网页文件\nnpx hexo generate\n或者\nnpx hexo g\n启动本地服务器\nnpx hexo server\n或者\nnpx hexo s\n打开浏览器，访问http://localhost:4000\n\n4.创作博客文章\n\n新建博客文章\nnpx hexo new &quot;blog name&quot;\n使用命令后，文章会生成在source/_posts/目录下\n编辑博客文章\n用Markdown编辑器打开_posts下的md文件\n编辑后执行命令npx hexo clean &amp;&amp; npx hexo generate &amp;&amp; npx hexo deploy，博客里面的内容就会改变\n\n二、在github上配置SSH\n\n打开git bash\n\n\n\n生成秘钥对\nssh-keygen -t rsa -C &quot;你的github邮箱@xxx.com&quot;\n一路回车即可\n查看公钥内容，复制到剪切板上\ncat ~/.ssh/id_rsa.pub\n打开github，新建一个仓库，仓库名为你的名字.github.io\n在上方导航栏点开仓库的Setting，在左侧导航栏找到Deploy keys\n\n\n\n在Deploy Keys界面点击Add deploy key按钮\n\n\n\nTitle随便填，将之前复制的公钥内容粘贴到Key里面，然后点击Add key\n\n\n\n在git bash中输入命令ssh -T git@github.com，如果出现successfully的信息，就代表成功了。\n\n\n三、部署Hexo博客到Github Pages上\n\n记录仓库的SSH地址\n如果上述步骤都没问题的话，那么SSH地址应该是git@github.com:你的github的名字/你的github的名字.github.io.git\n安装Hexo部署插件\n在之前建立的博客根目录中在终端中执行命令\nnpm install hexo-deployer-git\n编辑部署信息\n打开根目录中的_config.yml文件，找到deploy配置项\n\n\n在repo填上仓库的SSH地址，要注意冒号后面有个空格\n\n部署博客到github\n在终端执行命令：\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n之后访问https://你的用户名.github.io，即可公网访问你的博客\n\n四、常用命令\n新建文章：npx hexo new &quot;文章名&quot;\n生成静态文件：npx hexo generate\n启动服务器：npx hexo server\n部署网站：npx hexo deploy\n清除缓存文件：npx hexo clean\n参考资料\nhttps://blog.csdn.net/qq_37294163/article/details/103099424\nhttps://blog.csdn.net/weixin_73527660/article/details/156200825\n","categories":["其他"]},{"title":"热更新中AB包的上传和下载（二）","url":"/2026/01/01/AssetBundle2/","content":"九、\n","categories":["Unity"]},{"title":"行为树","url":"/2025/12/30/BehaviorTree/","content":"完整代码\n一、Base部分\n\nBehaviorTree.cs\n\npublic class BehaviorTree&#123;    public bool HaveRoot =&gt; root != null;    private BtBehaviour root;//根节点    public BehaviorTree(BtBehaviour root)    &#123;        this.root = root;    &#125;    public void Tick()    &#123;        root.Tick();    &#125;    public void SetRoot(BtBehaviour root)    &#123;        this.root = root;    &#125;&#125;\n\nBtActionNode.cs\n\npublic class BtActionNode : BtBehaviour&#123;    protected EnemyController enemyController;    protected Func&lt;EStatus&gt; action;    public BtActionNode(EnemyController enemyController, Func&lt;EStatus&gt; action)    &#123;        this.enemyController = enemyController;        this.action = action;    &#125;    protected override EStatus OnUpdate()    &#123;        return action();    &#125;&#125;\n\nBtBehaviour.cs\n\npublic enum EStatus&#123;    //失败，成功，运行中，中断，无效    Failure, Success, Running, Aborted, Invalid&#125;public abstract class BtBehaviour&#123;    public bool IsTerminated =&gt; IsSuccess || IsFailure;//是否运行结束    public bool IsSuccess =&gt; status == EStatus.Success;//是否成功    public bool IsFailure =&gt; status == EStatus.Failure;//是否失败    public bool IsRunning =&gt; status == EStatus.Running;//是否正在运行    protected EStatus status;//运行状态    public BtBehaviour()    &#123;        status = EStatus.Invalid;    &#125;    protected virtual void OnInitialize()    &#123; &#125;    protected abstract EStatus OnUpdate();    protected virtual void OnTerminate()    &#123; &#125;    public EStatus Tick()    &#123;        if (!IsRunning)            OnInitialize();        status = OnUpdate();        if (!IsRunning)            OnTerminate();        return status;    &#125;    public virtual void AddChild(BtBehaviour child)    &#123; &#125;    public void Reset()    &#123;        status = EStatus.Invalid;    &#125;    public void Abort()    &#123;        OnTerminate();        status = EStatus.Aborted;    &#125;&#125;\n\nBtComposite.cs\n\npublic abstract class BtComposite : BtBehaviour&#123;    protected LinkedList&lt;BtBehaviour&gt; children;    public BtComposite()    &#123;        children = new LinkedList&lt;BtBehaviour&gt;();    &#125;    //移除指定子节点    public virtual void RemoveChild(BtBehaviour child)    &#123;        children.Remove(child);    &#125;    public void ClearChildren()//清空子节点列表    &#123;        children.Clear();    &#125;    public override void AddChild(BtBehaviour child)//添加子节点    &#123;        //默认是尾插入，如：0插入「1，2，3」中，就会变成「1，2，3，0」        children.AddLast(child);    &#125;&#125;\n\nBtDecorator.cs\n\npublic abstract class BtDecorator : BtBehaviour&#123;    protected BtBehaviour child;    public override void AddChild(BtBehaviour child)    &#123;        this.child = child;    &#125;&#125;\n二、Composite\n\nBtActiveSelector.cs\n\npublic class BtActiveSelector : BtSelector&#123;    protected override EStatus OnUpdate()    &#123;        var prev = currentChild;        base.OnInitialize();//注意这里，currentChild 会被赋值为 children.First        var res = base.OnUpdate();//按Selector的OnUpdate执行，顺序遍历选择        /*        只要不是遍历结束或可执行节点不变，都应该中断上一次执行的节点，无论优先是高是低。        因为如果当前优先级比之前的高，理应中断之前的；        而如果比之前的低，那就证明之前高优先级的行为无法继续了，        否则怎么会等到现在的低优先级的行为呢？所以也应中断它。        */        if (prev != null &amp;&amp; currentChild != prev)            prev.Value.Abort();        return res;    &#125;&#125;\n\nBtFilter.cs\n\n  public class BtFilter : BtSequence&#123;    public BtFilter(BtBehaviour condition)    &#123;        AddCondition(condition);    &#125;    public BtFilter(BtBehaviour condition1, BtBehaviour condition2)    &#123;        AddCondition(condition1);        AddCondition(condition2);    &#125;    public BtFilter()    &#123;    &#125;    public void AddCondition(BtBehaviour condition)//添加条件，就用头插入    &#123;        children.AddFirst(condition);    &#125;    public void AddAction(BtBehaviour action)//添加动作，就用尾插入    &#123;        children.AddLast(action);    &#125;&#125;\n\nBtMonitor.cs\n\npublic class BtMonitor : BtParallel&#123;    public BtMonitor(Policy mSuccessPolicy, Policy mFailurePolicy) : base(mSuccessPolicy, mFailurePolicy)    &#123;    &#125;    public void AddCondition(BtBehaviour condition)    &#123;        children.AddFirst(condition);    &#125;    public void AddAction(BtBehaviour action)    &#123;        children.AddLast(action);    &#125;&#125;\n\nBtParallel.cs\n\npublic class BtParallel : BtComposite&#123;    protected Policy mSuccessPolicy;//成功的标准    protected Policy mFailurePolicy;//失败的标准    /// &lt;summary&gt;    /// Parallel节点成功与失败的要求，是全部成功/失败，还是一个成功/失败    /// &lt;/summary&gt;    public enum Policy    &#123;        RequireOne, RequireAll,    &#125;    //构造函数初始化时，会要求给定成功和失败的标准    public BtParallel(Policy mSuccessPolicy, Policy mFailurePolicy)    &#123;        this.mSuccessPolicy = mSuccessPolicy;        this.mFailurePolicy = mFailurePolicy;    &#125;    protected override EStatus OnUpdate()    &#123;        int successCount = 0, failureCount = 0;//记录执行成功和执行失败的节点数        var b = children.First;//从第一个子节点开始        var size = children.Count;        for (int i = 0; i &lt; size; ++i)        &#123;            var bh = b.Value;            if (!bh.IsTerminated)//如果该子节点还没运行结束，就运行它                bh.Tick();            b = b.Next;            if (bh.IsSuccess)//该子节点运行结束后，如果运行成功了            &#123;                ++successCount;//成功执行的节点数+1                               //如果是「只要有一个」标准的话，那就可以返回结果了                if (mSuccessPolicy == Policy.RequireOne)                    return EStatus.Success;            &#125;            if (bh.IsFailure)//该子节点运行失败的情况同理            &#123;                ++failureCount;                if (mFailurePolicy == Policy.RequireOne)                    return EStatus.Failure;            &#125;        &#125;        //如果是「全都」标准的话，就需要比对当前成功/失败个数与总子节点数        if (mFailurePolicy == Policy.RequireAll &amp;&amp; failureCount == size)            return EStatus.Failure;        if (mSuccessPolicy == Policy.RequireAll &amp;&amp; successCount == size)            return EStatus.Success;        return EStatus.Running;    &#125;    //结束函数，只要简单地把所有子节点设为「中断」就可以了    protected override void OnTerminate()    &#123;        foreach (var b in children)        &#123;            if (b.IsRunning)                b.Abort();        &#125;    &#125;&#125;\n\nBtSelector.cs\n\npublic class BtSelector : BtSequence&#123;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            var s = currentChild.Value.Tick();            if (s != EStatus.Failure)                return s;            currentChild = currentChild.Next;            if (currentChild == null)                return EStatus.Failure;        &#125;    &#125;&#125;\n6.BtSequence.cs\nusing System.Collections.Generic;public class BtSequence : BtComposite&#123;    protected LinkedListNode&lt;BtBehaviour&gt; currentChild;//当前运行的子节点    protected override void OnInitialize()    &#123;        currentChild = children.First;//从第一个子节点开始    &#125;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            var s = currentChild.Value.Tick();//记录子节点运行返回的结果状态            /*            如果子节点运行，还没有成功，就直接返回该结果。            是「运行中」那就表明本节点也是运行中，有记录当前节点，下次还会继续执行；            是「失败」就表明本节点也运行失败了，下次会再经历OnInitialize，从头开始。            */            if (s != EStatus.Success)                return s;            //如果运行成功，就换到下一个子节点            currentChild = currentChild.Next;            //如果全都成功运行完了，就返回「成功」            if (currentChild == null)                return EStatus.Success;        &#125;    &#125;&#125;## 三、Decorator1. BtInverter.cs```C#public class BtInverter : BtDecorator&#123;    protected override EStatus OnUpdate()    &#123;        child.Tick();        if (child.IsFailure)            return EStatus.Success;        if (child.IsSuccess)            return EStatus.Failure;        return EStatus.Running;    &#125;&#125;\n\nBtRepeat.cs\n\npublic class BtRepeat : BtDecorator&#123;    private int conunter;//当前重复次数    private int limit;//重复限度    public BtRepeat(int limit)    &#123;        this.limit = limit;    &#125;    protected override void OnInitialize()    &#123;        conunter = 0;//进入时，将次数清零    &#125;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            child.Tick();            if (child.IsRunning)                return EStatus.Running;            if (child.IsFailure)                return EStatus.Failure;            //子节点执行成功，就增加一次计算，达到设定限度才返回成功            if (++conunter &gt;= limit)                return EStatus.Success;        &#125;    &#125;&#125;\n三、BehaviorTreeBuilder.cs(主要使用这个类来构建和控制行为属)\npublic class BehaviorTreeBuilder&#123;    private readonly Stack&lt;BtBehaviour&gt; nodeStack;//构建树结构用的栈    private readonly BehaviorTree bhTree;//构建的树    public BehaviorTreeBuilder()    &#123;        bhTree = new BehaviorTree(null);//构造一个没有根的树        nodeStack = new Stack&lt;BtBehaviour&gt;();//初始化构建栈    &#125;    public BehaviorTreeBuilder AddBehavior(BtBehaviour behavior)    &#123;        if (bhTree.HaveRoot)//有根节点时，加入构建栈        &#123;            nodeStack.Peek().AddChild(behavior);        &#125;        else //当树没根时，新增得节点视为根节点        &#123;            bhTree.SetRoot(behavior);        &#125;        //只有组合节点和修饰节点需要进构建堆        if (behavior is BtComposite || behavior is BtDecorator)        &#123;            nodeStack.Push(behavior);        &#125;        return this;    &#125;    public void TreeTick()    &#123;        bhTree.Tick();    &#125;    public BehaviorTreeBuilder Back()    &#123;        nodeStack.Pop();        return this;    &#125;    public BehaviorTree End()    &#123;        nodeStack.Clear();        return bhTree;    &#125;    //---------包装各节点---------    public BehaviorTreeBuilder Sequence()    &#123;        var tp = new BtSequence();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Seletctor()    &#123;        var tp = new BtSelector();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Filter()    &#123;        var tp = new BtFilter();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Parallel(BtParallel.Policy success, BtParallel.Policy failure)    &#123;        var tp = new BtParallel(success, failure);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Monitor(BtParallel.Policy success, BtParallel.Policy failure)    &#123;        var tp = new BtMonitor(success, failure);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder ActiveSelector()    &#123;        var tp = new BtActiveSelector();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Repeat(int limit)    &#123;        var tp = new BtRepeat(limit);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Inverter()    &#123;        var tp = new BtInverter();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder DebugNode(string word)    &#123;        var node = new DebugNode(word);        AddBehavior(node);        return this;    &#125;    public void OnDisable()    &#123;        nodeStack.Clear();    &#125;&#125;\n构建行为树和行为树的使用\nprivate void Awake()&#123;    builder = new BehaviorTreeBuilder();    //行为树    BtBehaviour IsFindPlayerCondition = new BtActionNode(this, IsFindPlayer);    BtBehaviour EnterAtkDisCondition = new BtActionNode(this, EnterAtkDis);    BtBehaviour EnterDashDisCondition = new BtActionNode(this, EnterDashDis);    BtBehaviour EnterLAtkDisCondition = new BtActionNode(this, EnterLtkDis);    BtBehaviour EnterObeservehDisCondition = new BtActionNode(this, EnterObeservehDis);    BtBehaviour CanAttackCondition = new BtActionNode(this, CanAttack);    BtBehaviour CanDodgeCondition = new BtActionNode(this, CanDodge);    BtBehaviour CanSkillCondition = new BtActionNode(this, CanSkill);    BtBehaviour CanSkillACondition = new BtActionNode(this, CanSkillA);    BtBehaviour CanSkillBCondition = new BtActionNode(this, CanSkillB);    BtBehaviour BeAttackCondition = new BtActionNode(this, IsBeAttacked);    BtBehaviour NearPlayerAciton = new BtActionNode(this, NearPlayer);    BtBehaviour AttackPlayerAction = new BtActionNode(this, AttackPlayer);    BtBehaviour RollBackwardsAction = new BtActionNode(this, RollBackwards);    BtBehaviour ObservePlayerAction = new BtActionNode(this, ObservePlayer);    BtBehaviour BackOffAction = new BtActionNode(this, BackOff);    BtBehaviour DashSkillAction = new BtActionNode(this, UseDashSkill);    BtBehaviour CloseSkillAction = new BtActionNode(this, UseCloseSkill);    BtBehaviour IdleAction = new BtActionNode(this, Idle);    BtBehaviour BeAttackAcion = new BtActionNode(this, BeAttacked);    builder        .Seletctor()//1            .Sequence()                .AddBehavior(BeAttackCondition)                .AddBehavior(BeAttackAcion)            .Back()            .Sequence()//11                .AddBehavior(IsFindPlayerCondition)//111                    .Seletctor()//112                        .Sequence()//1121                            .Sequence()                                .Inverter()                                .AddBehavior(EnterAtkDisCondition)                                .Back()                            .Back()                            .Seletctor()                                .Sequence()//1121121                                    .AddBehavior(EnterDashDisCondition)                                    .AddBehavior(CanSkillCondition)                                    .AddBehavior(CanSkillACondition)                                    .AddBehavior(DashSkillAction)                                .Back()                                .Seletctor()                                    .Seletctor()                                        .Sequence()                                            .AddBehavior(CanAttackCondition)                                            .AddBehavior(NearPlayerAciton)                                        .Back()                                        .Sequence()                                            .AddBehavior(EnterObeservehDisCondition)                                            .AddBehavior(ObservePlayerAction)                                        .Back()                                    .Back()                                .Back()                            .Back()                        .Back()                        .Sequence()//1122                            .AddBehavior(EnterAtkDisCondition)                                .Seletctor()                                    .Sequence()//是否能够攻击                                        .AddBehavior(CanAttackCondition)                                        .AddBehavior(AttackPlayerAction)                                        .Back()                                    .Seletctor()                                        .Sequence()//能否使用近战技能                                            .AddBehavior(CanSkillCondition)                                            .AddBehavior(CanSkillBCondition)                                            .AddBehavior(CloseSkillAction)                                        .Back()                                        .Seletctor()                                            .Sequence()//翻滚                                                .AddBehavior(CanDodgeCondition)                                                .AddBehavior(RollBackwardsAction)                                            .Back()                                            .AddBehavior(BackOffAction)                                        .Back()                                    .Back()                                .Back()                        .Back()//1122                    .Back()//112            .Back()//11            .Sequence()//12                .Sequence()                    .Inverter()                    .AddBehavior(IsFindPlayerCondition)                    .Back()                .Back()                .AddBehavior(IdleAction)            .Back()//12        .Back()//1    .End();&#125;\n参考内容\nhttps://developer.unity.cn/projects/6569d98aedbc2a0a165f740e\n","categories":["Unity"]},{"title":"摄像机控制脚本","url":"/2025/12/30/CameraController/","content":"简单介绍\n拥有调节灵敏度、检测碰撞、锁定敌人的功能。\n完整代码\nusing UnityEngine;public class CameraMoveController : MonoBehaviour&#123;    private PlayerInputSystem _playerInput;    [SerializeField] private Transform LookAttarGet;    private Transform playerCamera;    [Range(0.1f, 1.0f), SerializeField, Header(&quot;鼠标灵敏度&quot;)] public float mouseInputSpeed;    [SerializeField, Header(&quot;相机对于玩家&quot;)] private float normalRadius;    [SerializeField] private float currentRadius;    private Vector2 ClmpCameraRang = new Vector2(-85f, 70f);    [SerializeField, Header(&quot;锁敌&quot;)] private bool isLockOn = false;    private Transform currentEnemy;    private float escapeDistance;    [SerializeField, Header(&quot;滑轮&quot;)] private float zoomSpeed = 1f;    [SerializeField] private Vector2 minMaxZoom = new Vector2(4f, 7f);    private float zoom = 1f;    [SerializeField, Header(&quot;相机碰撞&quot;)] public LayerMask collisionLayer;    private Vector3 rotationSmoothVelocity;    private float yaw;    private float pitch;    private void Start()    &#123;        normalRadius = 5f;        playerCamera = Camera.main.transform;        _playerInput = LookAttarGet.transform.root.GetComponent&lt;PlayerInputSystem&gt;();    &#125;    private void ControllerCamera()    &#123;        //相机缩放        if (zoom != 0)        &#123;            normalRadius -= zoom * normalRadius;            normalRadius = Mathf.Clamp(normalRadius, minMaxZoom.x, minMaxZoom.y);        &#125;        //相机旋转        if (!isLockOn)        &#123;            Quaternion targetRotation = Quaternion.Euler(new Vector3(pitch, yaw));            transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, 0.4f);            if (pitch &lt; -8f)            &#123;                currentRadius = Mathf.Lerp(currentRadius, normalRadius / 2f, 0.1f);            &#125;            else            &#123;                currentRadius = Mathf.Lerp(currentRadius, normalRadius, 0.1f);            &#125;        &#125;        //相机碰撞检测        Vector3 fanlePos = Vector3.zero;        if (Physics.Linecast(LookAttarGet.position + Vector3.up, playerCamera.position + (-playerCamera.forward.normalized), out var hit, collisionLayer))        &#123;            float currentDistance = Vector3.Distance(hit.point, LookAttarGet.position);            //Debug.Log(&quot;发生碰撞 &quot; + currentDistance);            if (currentDistance &lt;= minMaxZoom.y)            &#123;                currentRadius = currentDistance * 0.95f;            &#125;        &#125;        //相机跟踪        fanlePos = LookAttarGet.position - transform.forward * currentRadius;        transform.position = Vector3.Lerp(transform.position, fanlePos, 0.8f);    &#125;    private void GetCameraControllerInput()    &#123;        if (isLockOn) return;        yaw += _playerInput.cameraLook.x * mouseInputSpeed;        pitch -= _playerInput.cameraLook.y * mouseInputSpeed;        pitch = Mathf.Clamp(pitch, ClmpCameraRang.x, ClmpCameraRang.y);        zoom = Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * zoomSpeed;    &#125;    private void CameraLockOnTarget()    &#123;        if (!isLockOn) return;        Vector3 EnemyDir = ((currentEnemy.position + currentEnemy.transform.up * 0.3f) - transform.position).normalized;        Quaternion lookRotation = Quaternion.LookRotation(EnemyDir.normalized);        transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, 0.2f);    &#125;    private void LockEnemy()    &#123;        if (_playerInput.playerLockEnemy)        &#123;            Debug.Log(&quot;锁定敌人&quot;);            if (currentEnemy == null)            &#123;                Vector3 tempPosition = LookAttarGet.transform.position;                Vector3 center = tempPosition + new Vector3(0, 1.0f, 0) + transform.forward * 5.0f;                Collider[] col = Physics.OverlapBox(center, new Vector3(10f, 5f, 10f), transform.rotation, LayerMask.GetMask(&quot;Enemy&quot;));                if (col.Length != 0)                &#123;                    currentEnemy = col[0].transform;                    isLockOn = true;                &#125;            &#125;            else            &#123;                UnLock();            &#125;        &#125;        //距离太远，自动解除锁定        if (currentEnemy != null)        &#123;            if (Vector3.Distance(LookAttarGet.position, currentEnemy.position) &gt; escapeDistance)            &#123;                UnLock();            &#125;        &#125;    &#125;    private void UnLock()    &#123;        currentEnemy = null;        isLockOn = false;    &#125;    private void OnDrawGizmos()    &#123;        //Vector3 tempPosition = LookAttarGet.transform.position;        //Vector3 center = tempPosition + new Vector3(0, 1.0f, 0) + transform.forward * 5.0f;        //Gizmos.DrawCube(center, new Vector3(10f, 5f, 10f));    &#125;    private void Update()    &#123;        GetCameraControllerInput();//计算        LockEnemy();//选择锁定的敌人    &#125;    private void LateUpdate()    &#123;        ControllerCamera();//移动摄像头        CameraLockOnTarget();//锁定敌人    &#125;&#125;\n","categories":["Unity"]},{"title":"UI系统","url":"/2025/12/30/UISystem/","content":"完整代码\n\nBasePanel.cs\n\nusing UnityEngine;public class BasePanel : MonoBehaviour&#123;    protected bool isRemove = false;    protected new string name;    public virtual void OpenPanel(string name)    &#123;        this.name = name;        gameObject.SetActive(true);    &#125;    public virtual void ClosePanel()    &#123;        isRemove = true;        gameObject.SetActive(false);        Destroy(gameObject);        if (UIManager.Instance.panelDict.ContainsKey(name))        &#123;            UIManager.Instance.panelDict.Remove(name);        &#125;    &#125;&#125;\n\nUIManager.cs\n\npublic class UIConst&#123;    public const string MainMenuPanel = &quot;MainMenuPanel&quot;;    public const string SettingPanel = &quot;SettingPanel&quot;;    public const string PlayerStatePanel = &quot;PlayerStateBar&quot;;    public const string EnemyStatePanel = &quot;EnemyStateBar&quot;;    public const string DialoguePanel = &quot;DialoguePanel&quot;;&#125;public class UIManager&#123;    private static UIManager _instance;    private Transform _uiRoot;    private Dictionary&lt;string, string&gt; pathDict;    private Dictionary&lt;string, GameObject&gt; prefabsDict;    public Dictionary&lt;string, BasePanel&gt; panelDict;    public static UIManager Instance    &#123;        get        &#123;            if (_instance == null)            &#123;                _instance = new UIManager();            &#125;            return _instance;        &#125;    &#125;    public Transform UIRoot    &#123;        get        &#123;            if (_uiRoot == null)            &#123;                if (GameObject.Find(&quot;Canvas&quot;))                &#123;                    _uiRoot = GameObject.Find(&quot;Canvas&quot;).transform;                &#125;                else                &#123;                    _uiRoot = new GameObject(&quot;Canvas&quot;).transform;                &#125;            &#125;            return _uiRoot;        &#125;    &#125;    private UIManager()    &#123;        InitDicts();    &#125;    private void InitDicts()    &#123;        prefabsDict = new Dictionary&lt;string, GameObject&gt;();        panelDict = new Dictionary&lt;string, BasePanel&gt;();        pathDict = new Dictionary&lt;string, string&gt;()        &#123;            &#123; UIConst.MainMenuPanel ,UIConst.MainMenuPanel&#125;,            &#123; UIConst.SettingPanel ,UIConst.SettingPanel&#125;,            &#123; UIConst.PlayerStatePanel ,UIConst.PlayerStatePanel&#125;,            &#123; UIConst.EnemyStatePanel ,UIConst.EnemyStatePanel&#125;,            &#123; UIConst.DialoguePanel ,UIConst.DialoguePanel&#125;        &#125;;    &#125;    public BasePanel OpenPanel(string name)    &#123;        BasePanel panel = null;        if (panelDict.TryGetValue(name, out panel))        &#123;            Debug.Log(&quot;界面已打开&quot;);            return null;        &#125;        string path = &quot;&quot;;        if (!pathDict.TryGetValue(name, out path))        &#123;            Debug.Log(&quot;界面名称错误，或未配置路径 &quot; + name);            return null;        &#125;        GameObject panelPrefab = null;        if (!prefabsDict.TryGetValue(name, out panelPrefab))        &#123;            string realPath = &quot;Prefabs/UI/&quot; + path;//需在Resources/Prefabs/UI文件夹下放置UI的预制体            panelPrefab = Resources.Load&lt;GameObject&gt;(realPath) as GameObject;            prefabsDict.Add(name, panelPrefab);        &#125;        GameObject panelObject = GameObject.Instantiate(panelPrefab, UIRoot, false);        panelObject.transform.position = UIRoot.position;        panel = panelObject.GetComponent&lt;BasePanel&gt;();        panelDict.Add(name, panel);        panel.OpenPanel(name);        return panel;    &#125;    public bool ClosePanel(string name)    &#123;        BasePanel panel = null;        if (!panelDict.TryGetValue(name, out panel))        &#123;            Debug.Log(&quot;界面未打开&quot; + name);            return false;        &#125;        panel.ClosePanel();        return true;    &#125;&#125;","categories":["Unity"]},{"title":"热更新中AB包的上传和下载（一）","url":"/2025/12/31/AssetBundle/","content":"一、热更新流程\n在资源需要变化时，向资源服务器（FTP、HTTP等）上传AB包和资源对比文件。\n每次通过游戏客户端进入时：\n\n下载服务器上的资源对比文件\n用下载下来的资源对比文件和本地文件进行对比，记录需要进行更新的AB包\n将需要更新的AB包进行更新，再更新资源对比文件\n完成后，正式进入游戏\n\n二、准备打包AB包的脚本\n在github上下载AssetBundles Browser\n可以通过url在包管理器里添加，也可以直接在https://github.com/Unity-Technologies/AssetBundles-Browser直接下载压缩包。\n如果是直接在github上下载压缩包，需要将里面的Test文件删除，不然直接在unity里会报错\n\n删除以后，就可以直接将压缩包里面的文件粘贴到Unity项目的Packages文件夹下\n\n添加后，在Unity按下Ctrl+R即可刷新，包就导入到项目中了\n接着就能在窗口选项里面找到AssetBundle Browser的选项\n\n点开后得到这样的界面：\n\n三、准备需要打包的内容\n在场景中创建简单的立方体、球体和圆柱体，用来模拟需要打包的内容。\n将创建好的物体拖到自己创建好的Assets/ArtRes/Prefab文件夹下。\n\n同时，创建好Assets/ArtRes/Lua文件夹用来存放lua脚本。\n打开Assets/ArtRes/Lua文件夹的资源管理器，在里面新建两个txt文本用来模拟lua脚本\n\n将三个刚刚创建的预制体添加到model包（自己创建）里\n\n接着，我们就可以在AssetBundle Browser视窗看到我们model包下的物体了\n\n也可以通过直接在AssetBundle Browser视窗，直接新建一个包\n\n这里新建一个lua包，用来装lua脚本\n\n将之前新建的用来模拟lua脚本的txt文件放入lua包中\n\n四、进行打包\n点击build按钮，来到build界面。\n\n我们需要新建Assets/ArtRes/AB/PC文件夹来存储build的输出结果\n\n将路径Assets/ArtRes/AB/PC放到Output Path中\n\n在高级设置里，只需要将压缩方式改为LZ4方式，是一种比较好的压缩方式，其他的选项都不用动\n\n最终设置为：\n\n点击Build，等待，然后就可以在Assets/ArtRes/AB/PC文件夹下看到打包出来的资源\n\n五、获取AB包文件的MD5码\n\nMD5码是什么\n\nMD5是信息摘要算法的简称，是一种广泛使用的密码散列函数，可以生成一个16字节的散列值，用于确保信息的完整一致性\n当我们把数据经过MD5算法计算后，不管我们传入的数据有多大，都会生成一个固定长度的MD5码\n相同的数据，经过MD5算法计算后的结果是一样的\n如果数据发生变化，MD5码会发生变化\n因此，我们通过MD5码作为文件的唯一标识，通过其判断文件内容是否发生变化\n\n编写获得MD5码的脚本\n\n流程：根据文件路径获得文件流信息-&gt;利用MOD加密服务提供商（通过MD5CryptoServiceProvider新建一个）对象，根据流信息，计算出MD5码-&gt;将字节数组形式的MD5码转为16进制字符串\n完整代码：\nusing System.IO;using System.Security.Cryptography;using System.Text;using UnityEngine;public class GetMD5 : MonoBehaviour&#123;    // Start is called before the first frame update    void Start()    &#123;        print(getfileMd5(Application.dataPath + &quot;/ArtRes/AB/PC/lua&quot;));    &#125;    // Update is called once per frame    void Update()    &#123;            &#125;    private string getfileMd5(string filePath)    &#123;        //将文件以流的形式打开        using(FileStream file = new FileStream(filePath, FileMode.Open))        &#123;            MD5 md5 = new MD5CryptoServiceProvider();//声明一个MD5对象            byte[] md5Info = md5.ComputeHash(file);//获得数据MD5码 16个字节的数组            //关闭文件流            file.Close();            StringBuilder sb = new StringBuilder();            for(int i = 0;i &lt; md5Info.Length; i++)            &#123;                sb.Append(md5Info[i].ToString(&quot;x2&quot;));//转换成16进制字符串            &#125;            return sb.ToString();        &#125;    &#125;&#125;\n运行后，可以正确得到lua包的MD5码\n\n当我们改变lua包里面的内容时，比如在lua包里新增一个lua脚本的txt文件，那么lua包的MD5码就会发生改变\n六、生成AB包资源对比文件\n功能：\n\n在菜单栏添加一个按钮，点击后能够生成AB包资源对比文件\n遍历AB包文件夹，获取所有AB包文件信息（文件名、大小、MD5码），将其存入资源对比文件\n\n首先在Assets文件夹下新建Editor文件夹，此文件夹下的代码不需要在游戏中使用，只在Unity编辑器中使用，因此放在此文件夹下使其不会被打包出去。\n并在Editor文件夹下新建CreateABCompare脚本，用来实现对应功能\n\n完整代码：\nusing System.IO;using System.Security.Cryptography;using System.Text;using UnityEditor;using UnityEngine;public class CreateABCompare&#123;    [MenuItem(&quot;Tool/创建AB包对比文件&quot;)]    public static void CreateABCompareFile()    &#123;        //获取文件夹信息        DirectoryInfo directory = Directory.CreateDirectory(            Application.dataPath + &quot;/ArtRes/AB/PC&quot;);        //获取该目录下所有文件        FileInfo[] files = directory.GetFiles();        //用于存储信息的字符串        string abCompareInfo = &quot;&quot;;                foreach (FileInfo file in files)        &#123;            //没有后缀的是AB包            if(file.Extension == &quot;&quot;)            &#123;                abCompareInfo += file.Name + &quot; &quot; + file.Length + &quot; &quot; + getfileMd5(file.FullName);                abCompareInfo += &quot;|&quot;;            &#125;        &#125;        //循环完毕后，截取最后一个“|”        abCompareInfo = abCompareInfo.Substring(0,abCompareInfo.Length - 1);        //存储信息        File.WriteAllText(Application.dataPath + &quot;/ArtRes/AB/PC/ABCompareInfo.txt&quot;,abCompareInfo);        AssetDatabase.Refresh();    &#125;    private static string getfileMd5(string filePath)    &#123;        //将文件以流的形式打开        using (FileStream file = new FileStream(filePath, FileMode.Open))        &#123;            MD5 md5 = new MD5CryptoServiceProvider();//声明一个MD5对象            byte[] md5Info = md5.ComputeHash(file);//获得数据MD5码 16个字节的数组            //关闭文件流            file.Close();            StringBuilder sb = new StringBuilder();            for (int i = 0; i &lt; md5Info.Length; i++)            &#123;                sb.Append(md5Info[i].ToString(&quot;x2&quot;));//转换成16进制字符串            &#125;            return sb.ToString();        &#125;    &#125;&#125;\n可以得到以下结果：\n左上角出现了tool栏，tool栏有创建AB包对比文件的选项\n\n点击该按钮后，可以看到生成的文件\n\n以及文件的内容\n\n七、搭建FTP服务器\n用于模拟资源服务器，用于存储资源和资源对比文件\n\n\n下载Serv-U\n可以通过这个网址下载：\nhttps://www.yxtown.com/my/course/65/material?type=material&amp;page=2\n\n\n注册上传账号和下载账号（匿名）\n\n\n是否定义新域，点击是\n\n名称随便填一个\n\n下一步\n\n下一步\n\n勾选单向加密，点完成\n\n接着会弹出这个界面，点是\n\n随便填，下一步\n\n随便，下一步\n\n设置根目录，之后上传的文件会放在这里\n\n选择完全访问，点击完成\n\n接下来需要一个匿名用户，点击向导\n\n登录ID输入 Anonvmous，点下一步\n\n密码为空，匿名账号不需要密码，点下一步\n\n根目录和之前一样\n\n选择只读访问，点完成\n\n最终会出现两个账号\n\n\n验证\n在资源管理器输入ftp://127.0.0.1\n\n\n可以看到文件夹为空\n在之前设置的根目录中随便新建一个文件\n\n可以看到ftp服务器上多出了一个文件\n\n八、上传AB包和资源对比文件\n新建脚本UploadAB，用来向资源服务器上传AB包和资源对比文件\n完整代码：\nusing System;using System.IO;using System.Net;using System.Threading.Tasks;using UnityEditor;using UnityEngine;public class UploadAB&#123;    [MenuItem(&quot;Tool/上传AB包和对比文件&quot;)]    private static void UploadAllABFile()    &#123;        //获取文件夹信息        DirectoryInfo directory = Directory.CreateDirectory(            Application.dataPath + &quot;/ArtRes/AB/PC&quot;);        //获取该目录下所有文件        FileInfo[] files = directory.GetFiles();        foreach (FileInfo file in files)        &#123;            if (file.Extension == &quot;&quot; || file.Extension == &quot;txt&quot;)            &#123;                FtpUploadFile(file.FullName, file.Name);            &#125;        &#125;    &#125;    private static async void FtpUploadFile(string filePath, string fileName)    &#123;        //异步处理，在上传文件时，不会卡住主线程        await Task.Run(() =&gt;        &#123;            try            &#123;                //1.创建FTP连接用于上传                FtpWebRequest req = FtpWebRequest.Create(new Uri(&quot;ftp://127.0.0.1/AB/PC/&quot; + fileName)) as FtpWebRequest;                //2.设置一个通信凭证，这样才能上传                NetworkCredential n = new NetworkCredential(&quot;qwe&quot;, &quot;123000&quot;);                req.Credentials = n;                //3.其他设置                req.Proxy = null;//设置代理为空                req.KeepAlive = false;//请求完毕后，是否关闭控制连接                req.Method = WebRequestMethods.Ftp.UploadFile;//操作命令-上传                req.UseBinary = true;//指定传输的类型-2进制                //4.上传文件                Stream upLoadStream = req.GetRequestStream();//ftp的流对象                                                             //读取文件信息，写入该流对象                using (FileStream file = File.OpenRead(filePath))                &#123;                    //一点一点上传                    byte[] bytes = new byte[2048];                    //读取了多少字节                    int contentLength = file.Read(bytes, 0, bytes.Length);                    //循环上传文件                    while (contentLength != 0)                    &#123;                        //写入到上传流中                        upLoadStream.Write(bytes, 0, contentLength);                        //写完再读                        contentLength = file.Read(bytes, 0, bytes.Length);                    &#125;                    //循环完毕后，上传完毕                    file.Close();                    upLoadStream.Close();                &#125;            &#125;            catch (Exception ex)            &#123;                Debug.Log(&quot;上传失败 &quot; + ex.Message);            &#125;            Debug.Log(fileName + &quot;上传成功&quot;);        &#125;        );    &#125;&#125;\n运行Tool选项里面的上传按钮后，会在资源服务器里看到上传的结果\n要注意因为上传的路径是ftp://127.0.0.1/AB/PC/，因此如果资源服务器里没有/AB/PC文件夹的话，会发生报错，因为程序只负责上传，不会自动创建新文件夹\n\n参考内容\nhttps://www.bilibili.com/video/BV1VP411G7w2?spm_id_from=333.788.videopod.sections&amp;vd_source=5ddeed13107206194ba5b740648582d3\n","categories":["Unity"]},{"title":"单例模式的实现","url":"/2025/12/30/SingletonMode/","content":"\n  199a6f646875bc968ed2e8fce1f8969a76aec7468095a50651a1101816bdd53c27ab59d535c7fdbecc4568eeecb7554e62184f866e881899e1ec76024eb17051f4107b041d8f01359e3a3142b6fac35beb525022cf8e09d2260f17b4b76649d7a348f7077cfcb7b84d16a48282a2d1fd5f07c561962751ca0a338219f0a36877d4d3505d6a688d261bd4c0fe324872179d4b6f37390a7ab7ca46eabf9e3156b27c10a3504a007826f359b000bd8941c3ba61ebc7589a0e38136692a5c7b60597bb0ef28e8eddcb331e528cb84499ea9fb7434476a165fecc3dd1fd7e024e62dce89cb080af63dd449ff58a543a9044cf4ccd28a4e729c59fe2431508ebaddfe4b231e5c71e2c2355961a044e61a57c6fdeebda634109f17cc8e8dcb4c16f655d976bb5f949ec423f485a01a395527ea533fb436d41f33fa6bc320ce07420e7f87ca6fb273118932810dd0a8381364a58ee910a93f1b111777170b8bcfbd372ac60c2f0b938bc617bc233312578f7aab0a2f85734bc2e0c9d6ffbea9cf08f90581e265abafc89786d70b3ccef7dcf527f6c52b584dbdd516f6ccf1e873f4309287af543cc24c8507498b80e445280c549448b366c2a27da2f59cda40246712549c41b610e888792a91861b3f7abdab03ac165751fea46424c1716b1e6cfb15b5c4c2f25c5178a899b81b7165050d5c472bd84afc4c9474bd6e86a26de442c7e354da202da23d9de01601326fe1eb05641f738c5b202a1b510373a812fde6ee8077a5acfca75dcc23bf651ce5807b5e96cfe8f3af8d41e893a9099b0d2024bc819a7338ac393ea772c378bbd6eb4772362911702370ca2be4c5930c31a7ee026267b030a43baf4b6eb916a4c19c4891edc6dfed00de8ac70531b9af79afb1bee26621bab4b7302aece2c71e464fce518a723c3e4d1b7701785c65c364395d3f57010759bad176a565f78e24116df7e2e8b2bfb681f1a54ce9a1d0396accb854811e2b384c913671b7bc5b12f562a9cc3686809f9787a200a3f6337cdddb81e4933888f9d8371b7119155f73e759886d9c00d9f16ce2a346228aa360de8c9de677539d5ee71144ee060c8a7ec9b8655909535b5e83118a436c38d0324da0759814d9c0be8f9e80ab0e878591aa3966cd35ec77421184a00a50b7202eb431b7f8eac08799976b1ea6c3f2ea9ae6d2beaef4a1e4703055012866fef69733867d6cb7795cc1ee19d04791ae05a592430d351dd3426fa3d4d0f28e963edb89e46fc386c16ade2b680eeb1d3b199b9a9ec061a9beb56f679e0e4acab75df9bfae0ff8b6273df289e4a2d68da36104b9af23ab35ed72afabb787d2309148fa75afd461e529bd1fbe7574553cdb1d16ce841011b94808470822afc691253d9935a09a52518c0d41ea2a69961e5835e3b7fd0a2e9a74a54d477952b7f9719d598e032db734b49326932b171903bc3031226433714291470bfba48d5ea57784274a359d0017340d1f9a7bdadc0edc0fe7872812a252e53ca1e71f3ed5d3c0e140437709e060cf492af0fa0dde2188299c50610cdb131b98164583677250519bda62e6e82b2c38fead25695142b3ffd3a2e01aaf32ceb5a39ddf72d37930f452830ad25640048e79dbad6083a6b7f5222d644ca6dc6bcc67beabe7e38b6d9f1d703da1e567d15d7db0f33cb06b0245a926d7178f27f3153d5a4d659e95f12dc43d19a8baa61d1921787c14232653d32c696862e8b51c3e8c216071e13a2bdc3c64c68a163f85cfb5e944b7b0531317178fed5b3fb169c5e1ee39a662cd4c5c4380a1900c6a399f26312f853516eefb6caff15b0fdd7a9eb239006fb5b38dfa8a7953948f9596f1f88399d74ee78ee1a065e2a4be80414218829b6f1dce007006154515d5fc7d0f609162c1d4eecd649b32e6307698bcd823f1a3e33abec04d11d4ec5dc944ee54f0b0da071307fc43e27227162faebafdae1c2e1369d585ffad3db2accf4994fa9d5c569e222b1261fa64cc96af15739751c61afa441a8890a40ee218d7ce9b879435ef868019e0b2d7a0d0502da2dba1927fcc5d3a1ff8c58588d3b0fa6fe5e8d513ec521805f4e7924aa7b8e4ee60b60110ed00f5183fb0ff3f8194f8682c24a8418f26af4a6ee795461e6f2a616c3e1719c557f350dedd937e2b09855b8db38f63ef89e21e2e5144a4b5228bf53549d53d2961a27fc4cb26395472c6b5af1ce566400834a54b46cce69379fd5da19a60f7fd51164d68a8597ba0075ce7e551229315b313eebe75d66aaa4f647dc0835e2d7483458529ed80b7d3be75feffa825406ab4f732f36be4620b1bde7a18edcf3588840476ebb6e4959b05d0e5dcd5763ff9d9597b11445ee2728d8c2b5812c375f12e7607f5bea93518ec451ab31785ecf712967ef1f1d21a0d82962fd9d36ecf76c20f5fa2294203ff4297b34525ca16bbe347f8f60ce578fd1aecfaf0cae1bcf13a87de0d4b8f1a7e001309cbc03627a4af1d22e946f237f6d2b4be800b7876dbea1c102a6a06450154f8b7644cb7de3ab34dca5a06e0d8dbf0107f0c91c87c5ee4cddb332feeb9e0d0cf305d1e45884cf27c8c9a3c09e5b5cff41bb6cd639eaa51f8b76ed6549b35328aac82603c4ff0dfb918ff4c0a4f5b99e3c3c6114286e49b41317bf8261960f70d29d1fa765ac7b929f5a2307418f097f887e76574aa03fe10a4909baa57753cdf7997811f0c9d30927c3be5ce0bcaca332c12bd02260ebec41b4f64a963b244f26b741ddf312e8f1e388267778a181fb5e9ed4f5d1770586aba7bdf59757c37baf639625a7299100624d340c4f04ec1dd30628f1bc2c0d2f327f8abb3342b169a80f3fddfa99f034ce173ec71f4e6c82b40647553c18a8e97849e37b05ede02ccbe7c9311a285549c4a0e8491e426d24db48827d817950a910ef9c4c7e07d998c8a54c207fcf0fdf1bd9a729318f50ac30eb3b58a741f4d59a0903041cd9dab593735e8c106e3e1a3cf924d9b6b8c8d090ba6020ea092efd0bfa42a38fb3db8f60104993804038b9623be10f74f851985ae588a5478b0b9325f56ecaa0bcca5a600a33d54bbc485461b48dffe3c3f21d0ac86043e68add98b984a726cb824a76dcb6709faed4e311a7d88b3d00b840e6b58e424c25c5506d72d8afe4391d3b0a3bdd413971630f0071110763872a10ad19b252003d6c584a6ea5a6dfa7b847167eef61cd5eecc0d8f79994bc4811f7b1c73381c9374037dbd0ef2dc80b02134b9be0bf61a98b31094dec03a83e1a130f6d2075408836a71c98f60eb9df96864ffafb6cbf77635a5d43f71bb457b28973b0dd8bce4eedf502c0f5cdec41522653d899648cae5f08e59a27903fa0412038c65fe8e8141897133587be344fd2d3e5f6120969233c3c42d14d94a3255735038309e0e0fc88add929f7f93a9d853147e14505aa2845f25607657a9df2324ef8f9377ce4ef0f3ef51e174ad7e39fdc03572916c4200f675e75d50d67acc85b208fce3e448e2d9fba5a1fb408f7bb03bd904990057dcb5f7490c88dccba6b9202ba0385b95e54cfabd16279b71113dca69e8cca525deffdf3b4f8522bbd8ca716fd33c768891b4e318af11d361b9a327aa7113d266c8c7143091847e4898cd051d1d6e9df866d85f22d2f7cccfbfd0b161d9d9f25e3f65846f2bf2d6e726297860df45af3099eadc91db5498318a71fff7a390c36f7e7bbfcd72c03ad6743cbc6b1bce2801730484ff9e27bdc64012130daa55466fcaefeab6742b3a95d9f1dc75a55a471f4368d8c78ada205c80a60e0380db14e797a1a8f8030ed873dfc912536aa69d446145f3137b5c64d00d0a9a51470c4f62c09fc11ec0ee03e0f7583a075033fcbd96e712d5dbe701a08dee86ab4f4f88c6e93f68a53809ac45a5a5b7f799874220b1d68f9d8672a68b1edae8ca757a9826c229bb7fafac161a32d7969254aecccad26ca05e3978392ff8ab6a1f5b0bed7b6342b2c7e77ded096abcab8120b8fb79c8688bc89e28150ca4c1a1730836665890e37c6b3d12a62dd61854000f93fc54bf7dcf1b0ca8023b99028a6009cd9c0b3d66ec08d6277cb067621544ac3e874b7b2c69868faf057ca83f863d21b0984e236a059ed9b819a769d8c27577df74b0ba097b5de959893b77b44b433734a8c7ccdf8322b46ac5f6e6479ead5850535bd2e22b039f180b6da19986c0aefc0ad7098196683cbd81deccb57e4b6a76b7e2fa5093d1fa4cd74908705121330cb4a7e88568fa7c0f68d2c5e5ff5b8dccc6e0877d6af736ab7b987edd274fb4cb4c15813e4b9cf34ceb0a570d61a507fc75cf16a60e91063714a953a83b2cf4fcfaf018fc2ec8949517aef535b212e7c5d9a3199671335ef147f7dff1ec9f65dc6af25bbec98f8484dc09ea43d9896023fa70d75a6de0be027887e347d3dc420d4a475b336602bde84eca456b5bcb1b16c3e4f05c1a5f3417f86c653b9c5815da6858f4f9401be4ea5d65e3f3419dccee29314f56e0e7f3de3730cc32a6a274bc89ac25a703e8472433ad08c7330a43636182714277841eee9398d0883e2a2edb52c73aac2fbd75f013ed28fa4f507379d60a15f8e50f5306ab1710397a0c73ba71f215f521f11719ee2be6eb9e2b12ddc873966257427f0af308a2a085d77897abb7ce6f3724944365436be48e22424fca1cb5e884b5498b28d68c7715fa27a586946e3635553272ff6c2bf77cef6aba9318537cb821b36484b917167b1626b23704b3cb11cfb892766495bbc61c5d8f8cae70750b3f60ce367de9b2711aed963f3071b913e48c5917ccea5569c2c17707920ee29235d131a46cfb4b6fd7c11e4df3c89a63cd5419fb39b87148ec8766e250eb6a36a2bcab6cfbf2661d2ac7eb74be1c9435aeba9e87c28a700a930e6e7313a229f388d5271a2d29a196f2129048eb8dcec454185ee1dc4d7aeec6cb23a4970c95a3dc9b14631078b0ecc7f46bea150d220321a11ece31b453c3a42a8c084c496c3cfacdfd7d7e4ec1b453f3ed56598171252a66b96a2428fcad1cfec9628f92dadb7b79f46ea533fc79574bdded9abad882b7bb4e55371d8528cc4678c5d22762527619682d7f19939e44a933522cb8635af0b01bfafc4057d197e6fceaebab9673029fbdbff33c71ff6dfaf98c72e023687d032ca78168ee2fa1209d807aea47f7269bb15cb8cfccca55021498843a64c1cb23410c881a1b501fdccac6ae40992414bea246afd3651ba3d662ccb6b22585dfc9048546a68519ba93042469594bf733b7a95ae8b4df8b10dbfe72ecab18aecb6f8d581728ecf2beb4656ce0bfa4bbcecd6b31fec39f5698fbb1de3717842d64ddb8e5bcc6a06fcbd94ff811f2c36d066465d2d8fbc9ff499883b2999147d573bcc8b9d18e506f1155cd7490b5c92b03582490d8410d4306c1f30cd39fd9630c6353e8a9f0451481ff2c53c49e993c8df1856711e168214cc38d20eac31a3c77eaca86b827676252bf7ca6d190f841a1758fd543ccfb4ef3cecb9a17a581e149f1c90f3fa560eb8635d4807af80adb45fc06f25c3f2a84580a6120c41f0c92d7f03c93d6ae62de6b556b4c058270beb17d4030b5b31af512dca64722223357f3bdc2ae3b27371ac7cd37ac26790f488a71a0162f036316d554c98ad8687902703d2e8fbb4b7aa8a056a685524f2683c706d92293f16145a4dbcdd3ca95ef212834a67d55664b40e3cfca068853546b2192d84f6c3643f062b4f32c252a20175dca69fcfc89e77e8877c3237ff207b26025aaf84d7a66bff03afef3735d669f7722b16b16bf216e009d00c630c571eeaa3f524a43dc25104abaf08abd58dd3947736b8572e840850fe081ddc677b9248f3ae839a20890ae3b9d267800e7c970fa5a74ae96be6c6deeab82c2f9475e7178ac4b342ff1f0807474d8d1139109d166274ad4056cbc21bed6e7546798915499651b1a99063ac7282fa072a9eb9a6a4e945f5a6a6c01e1d4c351209be64d7c82b689cc2200eed37cfdd1c9681346610d56d6bd7a4bd5fa69c9a15b9facf97f6a4a73d4062a3bb3087855b2c4968db593c6a5959f0b233dfecd4eb110be014f474e6013803b5eb1f39bd0e6f3a8caa4d6431337ff94d1dc244303c020a8b853b818ffc8b25eb57f31f3dc3f35031c52dfcaa6d8b228543470b46d38e575f2b7cce8f662f10a78c12d9ee10b741223edb6d65ca83282878a054131dd8d9fa05a9823a2026cf1a26e760eff8ff55566dd6d27d114d13f2a5acc08bf1d30f8323fac3d74689cd556176353aecda205b99153fffcb55b5255e6d31958a263d81d8ecee8ec936803409431c4d870370bf7115f94d41dea83512a7f757af0cc7a890a7769570be66023b0f88b1d6824a3fec0ce398c9ebc116f0fa26afbb42191156e1d50c21ba1e75219dea6171a9b8be6468a224b33698edc9aeb41aaa8664bab436437f89b0bff1c1390a2710b143def02610057caa08ab825e601b4aab8df99b81d38b876eac0418bb9c12c00c0c7576a2a008472c7995c757c04d27afdfa3bc986d417a2d5ace1d2e4b034541675e96730e44d73b22526fd758b5239ab2acaca30f72d3fe4fbcbffa35c7a1e152be4786754de77c78ebcaac002d01e1379c719d6a7b972bdac7cffdc8e7191646b5f5649286caa2b5e43283c719842e47987cc828430916782e11b494a5a0752e743df3e2666fb4f65536ad9e9060d2c3f556c3c90e71ebbaf5a2fd40ea1f0a37da9c4ec7dca57d7890c9fe4d29461e86d02157a4523831fc42e1e7186e8cd8932699611310af8e69ecdb58ef8c01e44d57cab660c3b544c77830f833fc4f964795e10e53815454e0274f13ecc0eb11f6f59f0a445950c1043f077133c84080113b782d9785b50dfeb06df80b0b257197050f764fc38639fb64f0569eecefb5e62cc970262a169b16b597eb795c967d4eec3d2b05e8fa4990ad4cb57c0db0ab65e9ce0debe094d82b44d5ed7925956eaff1e74c6b64d042411dd5573a1398490de550819d3d4bf672f945592fc2e1c81183126ae2252e533b52a488e530d4d5add6264d5533df6b59c7b8eb49cc8720a2750f0caa5639f5c847718ee436bb81a6a302223961c01b6e3a4d1595e48ca7902fa9f1821ffcd94c9019d6875c5510bc1dcd54aa14923ba36b71bc6a67d20f0a61eec5be169fe52c3ef4e86b2c7a4b2a20b2700e0ae9dc3123062534d3148e31aa134f247326e34db8fecaf30f6dc4e1bdbeca0c5f4d1a6ef6a55f6d5ac46bf80f09d408250404c96fc02871d4a9dcc76f06241576dcc22ec1b405a623a5c868ddffebb46459d379cbe1afc6ab8f80a2c8796eca9f146ee1dbb18e3f88d847b50f327920d5ce918e8cc1c54291105793b4e41a63e6f45c277d2a5feb273c4605b8e6df20c079fcfd8ac651c8e24fd86936866b852c7836a08e52b35a6838e61bb00b9bc7f3e235e5f6f62e889f80966f0f3523b1386552ca00c94f45fe73d1360dee2708558422e9c57de8cad7612da267c77d94d0ec9824bdb94cd9e11b33b6657937e4b333b5dc87146db1cd63d388434d16382d72ba73078b496a40230cf8db7aa009b137029b97ffef6a0ff563f34db2f1cb7e0076b08a311bd0f0fdd9fbdb272dc914529faa67a57d259cd5e4ed719a6e35dfff924043c5b2df5249cdd4cfd8729ccc6e72a426d14e6fe61e3fbb8c28b8c9bb1c4eaf3609b2c624736981cac3b34246f3c1debee745dbc3a2fedbf8739d99155b54885beb222aed1e432c84ea8db563a16d30444c8efcc1836b3bf6878cb38658c497104778e181a46275ecf5eb460cef5d5471ab07ecd218750bf15ffb8bb0723c0ad6bf5166c7b5e6391d6b3c88c5a472ca2fda3d35bcbfd2455b3ee559b183393f7cdda88005608bd1f68f5e56562db2b2870c273cafd29eaf1f89da09db25ee9ba0d47c92a49808747b7ead373599550039a32798c5333c3e02acecd50295f15783e578c2a3aea0669d18ecd96cadfd80784a359fec9f6cf06137242e28e92805e16e57ac13c62b900b408bda4df955a4fd6cac86b02f92538b48c1467613990722c0f877c9b3487f3538d9724048b75099aad85e53dec52026220fd572ab6ab984492ff4bf2de22d44cae68b35357d2aa4b63786c98383be91d574e763c6b0bda5346df9358bc9d97df13b6f03f612480ba28089fe3b196672d55ea0499dad174af0743d8ea4ee29f0a40bc840c816c8932e1823b4a244eb410566dacf518eac0b993b597df03c920be98e27dc9528ddaa2cbe1814e431e931e672e622dda332f17b0f1838ce029bf09a7072c85f0a1112865c7afdff719cb8bad2bf698c76f02703673d1d385d44e2ccc18b8c6183c967d07832ed60cf0a54b8b3568e5f5df25ca7b479e8836ab3e8c3957c37b1b174d033b4dd90e87d7e8c0d66697c1bb9241425433be742113fda92271fd7082f6113ae88cb6d754a9965b7d4f25fd5cf7b6060e475a3fcbc34639f5ed0624777fa441d1e8e30f67910d6a21f938b833d1c64092f5dd956ef045a07985d8219a370d20a582ff51e4b94f146876b5d205814159c4bc86c7d09e6e6c4515c927926919f966fc2bbbd64c3e23a8c09d567da961a06df071ee8b7c0fe8aa21512959d1697973c0f21cb9a4bee9499d14fdd396232373b5cde55357af35b188c7f872998255bf1a9392282524e4741aabae3b4e016b30571a89148a8dd13c274686aa2cd93a88cafe66bc9653cbd2f8c80418db0d08f8fbaa3a93ac37ce732ea1e96c6a0b301abdad307e432098362b8bd1a57d3eda73a7759d1372af33f5dfb77dfeac405b988b412c3e417b878b056c2e60cf58c852ad88a33736ea1da709b509d53bb074f258b7296e4309a27894098a85bb095bf0fb48df09dd99025a6a7629d7a244419b759a9ba2605c903ad2d73b9b46aeb5c594ce9147e735ec57c798a72e5b62066b22e85cc7a9579aa46eb6b37c46a378588c924e93cb6b5a4c2add073acd7fed390e08e77687c86d549971cd377e83424dcbcb87417b37193239ea8833f93f7c7ddbb7a83ad68ead93561e8ebe051ca110552e47dd5f8502730ca2efe90e64f164bf53bf243e49e1dc0baedb72d65490ada50423ab3ac41ee36c4f99fa64735d49d3d4b85d18059fbb905f0d0207ccb7c93c2d21a223a11b121bd064524083d70e5ae1849b0ccc5df130d2369c58c6915eca7d1bce7ba707b28827ed8c9504093b1e182ba751563cb9392c27e4926c697c5cc791b1bb933190c0b3859e3d18132e87850e35e4d0ec1b02e6ed330628de34cd0de19857987a66cf3d42f3a6c7b9f43473679594e0360197662cf8f68546cdf756332d668d25b22b5ac85e54f7853070d2101b3d4c55b37da9a70f05e3ee72729549de2f644616d81b4d3046b05d92f4307d8bb8848dbf9303a50e266af3aed78ae70705f2213d975d9baeb076f15b4d3a13a3bc8b3d42f52f729b9270c354dc7ea3ce8cc68a7e3026c61d9479493d24170ecea994b528cc07a3e9e9be3bfc0580977f539b57565bdf72f03cec73a3468c90c3a2d1c4a5c8b0f433ac45b34c6a390e079179a3415699041dd380d59e15ebd156edf963175cd0ae71e827392b89a0a5427b4aeb9a97bfd2e27bda9a2c70b8797ffd7fb9ee4c89381432b8ac79c89642597d3a09b53c9f844a53786c66d2c6f7c11ef4e1072bf45dbd28931e8510c5ac3a1131b964791eaa65acb31ace8f8108d2bd831220c8d0e02f0720db869577ac4498eaff9f9f0efbef3ef47e39cfd9484ce8a361dfb880430dfb52959baf8f9630598ca19451d8db3ae4d1cddc3b1698779ba326f0d2930ea38024ce8d1409452372e6d8803a4419a599ddf07609b1f31d880a4c356125572d061798b4562b81fd931d77ebd34b0c4cd0964a503e23767e4be8968645f5f9573eed19e901dc58f5a821aab65dafe39006255d0acddb57810574afe5c81017b3df2a7c62d334ebe8e59debdda264aa408781fd21d33295fedb4858bae93ab5c8da3f58dce40df0664810c1fe33822468d66858c2303ed501da4a5b77b8bab9884bc3ad47ce7248b883791ae45c5cf712195a13536cac7df93a72bd48098cceada0aa62f3ba663f53cfadf930daee07d07fd355b6225a447c1f7fcd75c519fc57b14668094326ee8187fb0a49a0dbe034e5432a88e8dc3784262ae8de5bdd2d3c32d1cdc2e25fa66a7d49be5962da17ee9bd23d641b51785d4198594329b92ea49ee209c24682012cb06ce1768f901509640c649b59dcddc222b95902df87ac6998580c7131ec744cc4c61c73561f04771e5ea2349ec3958ac98f5ed52ae1c7bbb62f8e046805e8d04131c30a8c4d0715c24a61a704c113c84496f553fa68284c0cf4b1d14549ab25105235b4a99c5f69159d4ec8a058065d273b93aaa7683fd9090b8de8e9e9a2a6d602fd817c89e5fc4f65fe01c5179a0172c0285e8579a81054640adf3b386c071f74bced75832fd489b5840d701e18fc2e0aa5372feb0f75165f29635268d0f44f1a9342c30a2ee20cff746dcdbca4b453c6c1da17db64fb8348251b0cc3dab285ac24de72975ee523b12aceba4e8d3f77448bb1c6ae32df85a4b9c1a31604d\n  \n    \n      \n      \n        请输入密码查看本文。\n      \n    \n  \n\n","categories":["Unity"]}]