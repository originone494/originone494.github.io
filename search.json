[{"title":"行为树","url":"/2025/12/30/BehaviorTree/","content":"完整代码\n一、Base部分\n\nBehaviorTree.cs\n\npublic class BehaviorTree&#123;    public bool HaveRoot =&gt; root != null;    private BtBehaviour root;//根节点    public BehaviorTree(BtBehaviour root)    &#123;        this.root = root;    &#125;    public void Tick()    &#123;        root.Tick();    &#125;    public void SetRoot(BtBehaviour root)    &#123;        this.root = root;    &#125;&#125;\n\nBtActionNode.cs\n\npublic class BtActionNode : BtBehaviour&#123;    protected EnemyController enemyController;    protected Func&lt;EStatus&gt; action;    public BtActionNode(EnemyController enemyController, Func&lt;EStatus&gt; action)    &#123;        this.enemyController = enemyController;        this.action = action;    &#125;    protected override EStatus OnUpdate()    &#123;        return action();    &#125;&#125;\n\nBtBehaviour.cs\n\npublic enum EStatus&#123;    //失败，成功，运行中，中断，无效    Failure, Success, Running, Aborted, Invalid&#125;public abstract class BtBehaviour&#123;    public bool IsTerminated =&gt; IsSuccess || IsFailure;//是否运行结束    public bool IsSuccess =&gt; status == EStatus.Success;//是否成功    public bool IsFailure =&gt; status == EStatus.Failure;//是否失败    public bool IsRunning =&gt; status == EStatus.Running;//是否正在运行    protected EStatus status;//运行状态    public BtBehaviour()    &#123;        status = EStatus.Invalid;    &#125;    protected virtual void OnInitialize()    &#123; &#125;    protected abstract EStatus OnUpdate();    protected virtual void OnTerminate()    &#123; &#125;    public EStatus Tick()    &#123;        if (!IsRunning)            OnInitialize();        status = OnUpdate();        if (!IsRunning)            OnTerminate();        return status;    &#125;    public virtual void AddChild(BtBehaviour child)    &#123; &#125;    public void Reset()    &#123;        status = EStatus.Invalid;    &#125;    public void Abort()    &#123;        OnTerminate();        status = EStatus.Aborted;    &#125;&#125;\n\nBtComposite.cs\n\npublic abstract class BtComposite : BtBehaviour&#123;    protected LinkedList&lt;BtBehaviour&gt; children;    public BtComposite()    &#123;        children = new LinkedList&lt;BtBehaviour&gt;();    &#125;    //移除指定子节点    public virtual void RemoveChild(BtBehaviour child)    &#123;        children.Remove(child);    &#125;    public void ClearChildren()//清空子节点列表    &#123;        children.Clear();    &#125;    public override void AddChild(BtBehaviour child)//添加子节点    &#123;        //默认是尾插入，如：0插入「1，2，3」中，就会变成「1，2，3，0」        children.AddLast(child);    &#125;&#125;\n\nBtDecorator.cs\n\npublic abstract class BtDecorator : BtBehaviour&#123;    protected BtBehaviour child;    public override void AddChild(BtBehaviour child)    &#123;        this.child = child;    &#125;&#125;\n二、Composite\n\nBtActiveSelector.cs\n\npublic class BtActiveSelector : BtSelector&#123;    protected override EStatus OnUpdate()    &#123;        var prev = currentChild;        base.OnInitialize();//注意这里，currentChild 会被赋值为 children.First        var res = base.OnUpdate();//按Selector的OnUpdate执行，顺序遍历选择        /*        只要不是遍历结束或可执行节点不变，都应该中断上一次执行的节点，无论优先是高是低。        因为如果当前优先级比之前的高，理应中断之前的；        而如果比之前的低，那就证明之前高优先级的行为无法继续了，        否则怎么会等到现在的低优先级的行为呢？所以也应中断它。        */        if (prev != null &amp;&amp; currentChild != prev)            prev.Value.Abort();        return res;    &#125;&#125;\n\nBtFilter.cs\n\n  public class BtFilter : BtSequence&#123;    public BtFilter(BtBehaviour condition)    &#123;        AddCondition(condition);    &#125;    public BtFilter(BtBehaviour condition1, BtBehaviour condition2)    &#123;        AddCondition(condition1);        AddCondition(condition2);    &#125;    public BtFilter()    &#123;    &#125;    public void AddCondition(BtBehaviour condition)//添加条件，就用头插入    &#123;        children.AddFirst(condition);    &#125;    public void AddAction(BtBehaviour action)//添加动作，就用尾插入    &#123;        children.AddLast(action);    &#125;&#125;\n\nBtMonitor.cs\n\npublic class BtMonitor : BtParallel&#123;    public BtMonitor(Policy mSuccessPolicy, Policy mFailurePolicy) : base(mSuccessPolicy, mFailurePolicy)    &#123;    &#125;    public void AddCondition(BtBehaviour condition)    &#123;        children.AddFirst(condition);    &#125;    public void AddAction(BtBehaviour action)    &#123;        children.AddLast(action);    &#125;&#125;\n\nBtParallel.cs\n\npublic class BtParallel : BtComposite&#123;    protected Policy mSuccessPolicy;//成功的标准    protected Policy mFailurePolicy;//失败的标准    /// &lt;summary&gt;    /// Parallel节点成功与失败的要求，是全部成功/失败，还是一个成功/失败    /// &lt;/summary&gt;    public enum Policy    &#123;        RequireOne, RequireAll,    &#125;    //构造函数初始化时，会要求给定成功和失败的标准    public BtParallel(Policy mSuccessPolicy, Policy mFailurePolicy)    &#123;        this.mSuccessPolicy = mSuccessPolicy;        this.mFailurePolicy = mFailurePolicy;    &#125;    protected override EStatus OnUpdate()    &#123;        int successCount = 0, failureCount = 0;//记录执行成功和执行失败的节点数        var b = children.First;//从第一个子节点开始        var size = children.Count;        for (int i = 0; i &lt; size; ++i)        &#123;            var bh = b.Value;            if (!bh.IsTerminated)//如果该子节点还没运行结束，就运行它                bh.Tick();            b = b.Next;            if (bh.IsSuccess)//该子节点运行结束后，如果运行成功了            &#123;                ++successCount;//成功执行的节点数+1                               //如果是「只要有一个」标准的话，那就可以返回结果了                if (mSuccessPolicy == Policy.RequireOne)                    return EStatus.Success;            &#125;            if (bh.IsFailure)//该子节点运行失败的情况同理            &#123;                ++failureCount;                if (mFailurePolicy == Policy.RequireOne)                    return EStatus.Failure;            &#125;        &#125;        //如果是「全都」标准的话，就需要比对当前成功/失败个数与总子节点数        if (mFailurePolicy == Policy.RequireAll &amp;&amp; failureCount == size)            return EStatus.Failure;        if (mSuccessPolicy == Policy.RequireAll &amp;&amp; successCount == size)            return EStatus.Success;        return EStatus.Running;    &#125;    //结束函数，只要简单地把所有子节点设为「中断」就可以了    protected override void OnTerminate()    &#123;        foreach (var b in children)        &#123;            if (b.IsRunning)                b.Abort();        &#125;    &#125;&#125;\n\nBtSelector.cs\n\npublic class BtSelector : BtSequence&#123;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            var s = currentChild.Value.Tick();            if (s != EStatus.Failure)                return s;            currentChild = currentChild.Next;            if (currentChild == null)                return EStatus.Failure;        &#125;    &#125;&#125;\n6.BtSequence.cs\nusing System.Collections.Generic;public class BtSequence : BtComposite&#123;    protected LinkedListNode&lt;BtBehaviour&gt; currentChild;//当前运行的子节点    protected override void OnInitialize()    &#123;        currentChild = children.First;//从第一个子节点开始    &#125;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            var s = currentChild.Value.Tick();//记录子节点运行返回的结果状态            /*            如果子节点运行，还没有成功，就直接返回该结果。            是「运行中」那就表明本节点也是运行中，有记录当前节点，下次还会继续执行；            是「失败」就表明本节点也运行失败了，下次会再经历OnInitialize，从头开始。            */            if (s != EStatus.Success)                return s;            //如果运行成功，就换到下一个子节点            currentChild = currentChild.Next;            //如果全都成功运行完了，就返回「成功」            if (currentChild == null)                return EStatus.Success;        &#125;    &#125;&#125;## 三、Decorator1. BtInverter.cs```C#public class BtInverter : BtDecorator&#123;    protected override EStatus OnUpdate()    &#123;        child.Tick();        if (child.IsFailure)            return EStatus.Success;        if (child.IsSuccess)            return EStatus.Failure;        return EStatus.Running;    &#125;&#125;\n\nBtRepeat.cs\n\npublic class BtRepeat : BtDecorator&#123;    private int conunter;//当前重复次数    private int limit;//重复限度    public BtRepeat(int limit)    &#123;        this.limit = limit;    &#125;    protected override void OnInitialize()    &#123;        conunter = 0;//进入时，将次数清零    &#125;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            child.Tick();            if (child.IsRunning)                return EStatus.Running;            if (child.IsFailure)                return EStatus.Failure;            //子节点执行成功，就增加一次计算，达到设定限度才返回成功            if (++conunter &gt;= limit)                return EStatus.Success;        &#125;    &#125;&#125;\n三、BehaviorTreeBuilder.cs(主要使用这个类来构建和控制行为属)\npublic class BehaviorTreeBuilder&#123;    private readonly Stack&lt;BtBehaviour&gt; nodeStack;//构建树结构用的栈    private readonly BehaviorTree bhTree;//构建的树    public BehaviorTreeBuilder()    &#123;        bhTree = new BehaviorTree(null);//构造一个没有根的树        nodeStack = new Stack&lt;BtBehaviour&gt;();//初始化构建栈    &#125;    public BehaviorTreeBuilder AddBehavior(BtBehaviour behavior)    &#123;        if (bhTree.HaveRoot)//有根节点时，加入构建栈        &#123;            nodeStack.Peek().AddChild(behavior);        &#125;        else //当树没根时，新增得节点视为根节点        &#123;            bhTree.SetRoot(behavior);        &#125;        //只有组合节点和修饰节点需要进构建堆        if (behavior is BtComposite || behavior is BtDecorator)        &#123;            nodeStack.Push(behavior);        &#125;        return this;    &#125;    public void TreeTick()    &#123;        bhTree.Tick();    &#125;    public BehaviorTreeBuilder Back()    &#123;        nodeStack.Pop();        return this;    &#125;    public BehaviorTree End()    &#123;        nodeStack.Clear();        return bhTree;    &#125;    //---------包装各节点---------    public BehaviorTreeBuilder Sequence()    &#123;        var tp = new BtSequence();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Seletctor()    &#123;        var tp = new BtSelector();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Filter()    &#123;        var tp = new BtFilter();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Parallel(BtParallel.Policy success, BtParallel.Policy failure)    &#123;        var tp = new BtParallel(success, failure);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Monitor(BtParallel.Policy success, BtParallel.Policy failure)    &#123;        var tp = new BtMonitor(success, failure);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder ActiveSelector()    &#123;        var tp = new BtActiveSelector();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Repeat(int limit)    &#123;        var tp = new BtRepeat(limit);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Inverter()    &#123;        var tp = new BtInverter();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder DebugNode(string word)    &#123;        var node = new DebugNode(word);        AddBehavior(node);        return this;    &#125;    public void OnDisable()    &#123;        nodeStack.Clear();    &#125;&#125;\n构建行为树和行为树的使用\nprivate void Awake()&#123;    builder = new BehaviorTreeBuilder();    //行为树    BtBehaviour IsFindPlayerCondition = new BtActionNode(this, IsFindPlayer);    BtBehaviour EnterAtkDisCondition = new BtActionNode(this, EnterAtkDis);    BtBehaviour EnterDashDisCondition = new BtActionNode(this, EnterDashDis);    BtBehaviour EnterLAtkDisCondition = new BtActionNode(this, EnterLtkDis);    BtBehaviour EnterObeservehDisCondition = new BtActionNode(this, EnterObeservehDis);    BtBehaviour CanAttackCondition = new BtActionNode(this, CanAttack);    BtBehaviour CanDodgeCondition = new BtActionNode(this, CanDodge);    BtBehaviour CanSkillCondition = new BtActionNode(this, CanSkill);    BtBehaviour CanSkillACondition = new BtActionNode(this, CanSkillA);    BtBehaviour CanSkillBCondition = new BtActionNode(this, CanSkillB);    BtBehaviour BeAttackCondition = new BtActionNode(this, IsBeAttacked);    BtBehaviour NearPlayerAciton = new BtActionNode(this, NearPlayer);    BtBehaviour AttackPlayerAction = new BtActionNode(this, AttackPlayer);    BtBehaviour RollBackwardsAction = new BtActionNode(this, RollBackwards);    BtBehaviour ObservePlayerAction = new BtActionNode(this, ObservePlayer);    BtBehaviour BackOffAction = new BtActionNode(this, BackOff);    BtBehaviour DashSkillAction = new BtActionNode(this, UseDashSkill);    BtBehaviour CloseSkillAction = new BtActionNode(this, UseCloseSkill);    BtBehaviour IdleAction = new BtActionNode(this, Idle);    BtBehaviour BeAttackAcion = new BtActionNode(this, BeAttacked);    builder        .Seletctor()//1            .Sequence()                .AddBehavior(BeAttackCondition)                .AddBehavior(BeAttackAcion)            .Back()            .Sequence()//11                .AddBehavior(IsFindPlayerCondition)//111                    .Seletctor()//112                        .Sequence()//1121                            .Sequence()                                .Inverter()                                .AddBehavior(EnterAtkDisCondition)                                .Back()                            .Back()                            .Seletctor()                                .Sequence()//1121121                                    .AddBehavior(EnterDashDisCondition)                                    .AddBehavior(CanSkillCondition)                                    .AddBehavior(CanSkillACondition)                                    .AddBehavior(DashSkillAction)                                .Back()                                .Seletctor()                                    .Seletctor()                                        .Sequence()                                            .AddBehavior(CanAttackCondition)                                            .AddBehavior(NearPlayerAciton)                                        .Back()                                        .Sequence()                                            .AddBehavior(EnterObeservehDisCondition)                                            .AddBehavior(ObservePlayerAction)                                        .Back()                                    .Back()                                .Back()                            .Back()                        .Back()                        .Sequence()//1122                            .AddBehavior(EnterAtkDisCondition)                                .Seletctor()                                    .Sequence()//是否能够攻击                                        .AddBehavior(CanAttackCondition)                                        .AddBehavior(AttackPlayerAction)                                        .Back()                                    .Seletctor()                                        .Sequence()//能否使用近战技能                                            .AddBehavior(CanSkillCondition)                                            .AddBehavior(CanSkillBCondition)                                            .AddBehavior(CloseSkillAction)                                        .Back()                                        .Seletctor()                                            .Sequence()//翻滚                                                .AddBehavior(CanDodgeCondition)                                                .AddBehavior(RollBackwardsAction)                                            .Back()                                            .AddBehavior(BackOffAction)                                        .Back()                                    .Back()                                .Back()                        .Back()//1122                    .Back()//112            .Back()//11            .Sequence()//12                .Sequence()                    .Inverter()                    .AddBehavior(IsFindPlayerCondition)                    .Back()                .Back()                .AddBehavior(IdleAction)            .Back()//12        .Back()//1    .End();&#125;\n参考内容\nhttps://developer.unity.cn/projects/6569d98aedbc2a0a165f740e\n","categories":["Unity"]},{"title":"黑板模式","url":"/2025/12/30/BlackBoardMode/","content":"简单介绍\n黑板是一个共享数据的系统，进行游戏系统的不同模块之间的通信，比起将越来越多的变量存在Player类中，不如集中存在一个地方进行集中管理。\n下面的代码是一些我在之前的课程项目中实现的黑板，目的是存储敌人ai的技能cd。\n当ai使用完技能后，就会调用黑板里面的函数，让技能能否使用的布尔变量变为false，并在一段时间后变为true。\n这是比较简单的黑板，如果要实现更复杂的功能，就需要自己写出对应的实现。\n完整代码\n[Serializable]private class BlackBoardTimer&#123;    public float Timer;    public string Key;    public mData Value;    public BlackBoardTimer(float timer, string key, mData value)    &#123;        Timer = timer;        Key = key;        Value = value;    &#125;&#125;[Serializable]private class mData&#123;    public enum Type    &#123; Int, Float, Bool, String, Vector3, Transform &#125;;    public string name;    public Type type;    public int intValue;    public float floatValue;    public bool boolValue;    public string stringValue;    public Vector3 vector3Value;    public Transform transformValue;    public mData(string key, int value)    &#123;        name = key;        type = Type.Int;        intValue = value;    &#125;    public mData(string key, float value)    &#123;        name = key;        type = Type.Float;        floatValue = value;    &#125;    public mData(string key, bool value)    &#123;        name = key;        type = Type.Bool;        boolValue = value;    &#125;    public mData(string key, string value)    &#123;        name = key;        type = Type.String;        stringValue = value;    &#125;    public mData(string key, Vector3 value)    &#123;        name = key;        type = Type.Vector3;        vector3Value = value;    &#125;    public mData(string key, Transform value)    &#123;        name = key;        type = Type.Transform;        transformValue = value;    &#125;&#125;[SerializeField] private SerializedDictionary&lt;string, mData&gt; mDatas = new SerializedDictionary&lt;string, mData&gt;();[SerializeField] private List&lt;BlackBoardTimer&gt; mTimers = new List&lt;BlackBoardTimer&gt;();// 设置数据public void SetValue(string key, bool value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, bool value, float expiredTime, bool expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, int value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, int value, float expiredTime, int expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, float value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, float value, float expiredTime, float expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, string value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Vector3 value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Vector3 value, float expiredTime, Vector3 expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    mDatas[key] = new mData(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, Transform value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Transform value, float expiredTime, Transform expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    mDatas[key] = new mData(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;// 访问数据public int GetInt(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Int)    &#123;        return value.intValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not an int.&quot;);&#125;public float GetFloat(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Float)    &#123;        return value.floatValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a float.&quot;);&#125;public bool GetBool(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Bool)    &#123;        return value.boolValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a bool.&quot;);&#125;public string GetString(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.String)    &#123;        return value.stringValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a string.&quot;);&#125;public Vector3 GetVector3(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Vector3)    &#123;        return value.vector3Value;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a Vector3.&quot;);&#125;public Transform GetTransform(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Transform)    &#123;        return value.transformValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a Transform.&quot;);&#125;private void Update()&#123;    for (int i = mTimers.Count - 1; i &gt;= 0; i--)    &#123;        var timer = mTimers[i];        timer.Timer -= Time.deltaTime / Time.timeScale;        if (timer.Timer &lt;= 0.0f)        &#123;            mDatas[timer.Key] = timer.Value;            mTimers.RemoveAt(i);        &#125;    &#125;&#125;\n参考内容\nhttps://www.cnblogs.com/KillerAery/p/10054558.html\n","categories":["Unity"]},{"title":"摄像机控制脚本","url":"/2025/12/30/CameraController/","content":"简单介绍\n拥有调节灵敏度、检测碰撞、锁定敌人的功能。\n完整代码\nusing UnityEngine;public class CameraMoveController : MonoBehaviour&#123;    private PlayerInputSystem _playerInput;    [SerializeField] private Transform LookAttarGet;    private Transform playerCamera;    [Range(0.1f, 1.0f), SerializeField, Header(&quot;鼠标灵敏度&quot;)] public float mouseInputSpeed;    [SerializeField, Header(&quot;相机对于玩家&quot;)] private float normalRadius;    [SerializeField] private float currentRadius;    private Vector2 ClmpCameraRang = new Vector2(-85f, 70f);    [SerializeField, Header(&quot;锁敌&quot;)] private bool isLockOn = false;    private Transform currentEnemy;    private float escapeDistance;    [SerializeField, Header(&quot;滑轮&quot;)] private float zoomSpeed = 1f;    [SerializeField] private Vector2 minMaxZoom = new Vector2(4f, 7f);    private float zoom = 1f;    [SerializeField, Header(&quot;相机碰撞&quot;)] public LayerMask collisionLayer;    private Vector3 rotationSmoothVelocity;    private float yaw;    private float pitch;    private void Start()    &#123;        normalRadius = 5f;        playerCamera = Camera.main.transform;        _playerInput = LookAttarGet.transform.root.GetComponent&lt;PlayerInputSystem&gt;();    &#125;    private void ControllerCamera()    &#123;        //相机缩放        if (zoom != 0)        &#123;            normalRadius -= zoom * normalRadius;            normalRadius = Mathf.Clamp(normalRadius, minMaxZoom.x, minMaxZoom.y);        &#125;        //相机旋转        if (!isLockOn)        &#123;            Quaternion targetRotation = Quaternion.Euler(new Vector3(pitch, yaw));            transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, 0.4f);            if (pitch &lt; -8f)            &#123;                currentRadius = Mathf.Lerp(currentRadius, normalRadius / 2f, 0.1f);            &#125;            else            &#123;                currentRadius = Mathf.Lerp(currentRadius, normalRadius, 0.1f);            &#125;        &#125;        //相机碰撞检测        Vector3 fanlePos = Vector3.zero;        if (Physics.Linecast(LookAttarGet.position + Vector3.up, playerCamera.position + (-playerCamera.forward.normalized), out var hit, collisionLayer))        &#123;            float currentDistance = Vector3.Distance(hit.point, LookAttarGet.position);            //Debug.Log(&quot;发生碰撞 &quot; + currentDistance);            if (currentDistance &lt;= minMaxZoom.y)            &#123;                currentRadius = currentDistance * 0.95f;            &#125;        &#125;        //相机跟踪        fanlePos = LookAttarGet.position - transform.forward * currentRadius;        transform.position = Vector3.Lerp(transform.position, fanlePos, 0.8f);    &#125;    private void GetCameraControllerInput()    &#123;        if (isLockOn) return;        yaw += _playerInput.cameraLook.x * mouseInputSpeed;        pitch -= _playerInput.cameraLook.y * mouseInputSpeed;        pitch = Mathf.Clamp(pitch, ClmpCameraRang.x, ClmpCameraRang.y);        zoom = Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * zoomSpeed;    &#125;    private void CameraLockOnTarget()    &#123;        if (!isLockOn) return;        Vector3 EnemyDir = ((currentEnemy.position + currentEnemy.transform.up * 0.3f) - transform.position).normalized;        Quaternion lookRotation = Quaternion.LookRotation(EnemyDir.normalized);        transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, 0.2f);    &#125;    private void LockEnemy()    &#123;        if (_playerInput.playerLockEnemy)        &#123;            Debug.Log(&quot;锁定敌人&quot;);            if (currentEnemy == null)            &#123;                Vector3 tempPosition = LookAttarGet.transform.position;                Vector3 center = tempPosition + new Vector3(0, 1.0f, 0) + transform.forward * 5.0f;                Collider[] col = Physics.OverlapBox(center, new Vector3(10f, 5f, 10f), transform.rotation, LayerMask.GetMask(&quot;Enemy&quot;));                if (col.Length != 0)                &#123;                    currentEnemy = col[0].transform;                    isLockOn = true;                &#125;            &#125;            else            &#123;                UnLock();            &#125;        &#125;        //距离太远，自动解除锁定        if (currentEnemy != null)        &#123;            if (Vector3.Distance(LookAttarGet.position, currentEnemy.position) &gt; escapeDistance)            &#123;                UnLock();            &#125;        &#125;    &#125;    private void UnLock()    &#123;        currentEnemy = null;        isLockOn = false;    &#125;    private void OnDrawGizmos()    &#123;        //Vector3 tempPosition = LookAttarGet.transform.position;        //Vector3 center = tempPosition + new Vector3(0, 1.0f, 0) + transform.forward * 5.0f;        //Gizmos.DrawCube(center, new Vector3(10f, 5f, 10f));    &#125;    private void Update()    &#123;        GetCameraControllerInput();//计算        LockEnemy();//选择锁定的敌人    &#125;    private void LateUpdate()    &#123;        ControllerCamera();//移动摄像头        CameraLockOnTarget();//锁定敌人    &#125;&#125;\n"},{"title":"如何建立一个博客","url":"/2025/12/29/HowBuildBlog/","content":"一、安装Hexo并初始化博客\n1.安装Hexo\n在安装Hexo之前，需要安装Git，Node.js，具体过程可以直接看https://hexo.io/zh-cn/docs/\n然后在终端中执行命令\nnpm install -g hexo-cli\n2.初始化博客\n\n新建一个文件夹作为博客根目录（我的是D:!myths\\blog）\n在终端中输入命令进入根目录\ncd D:\\!myths\\blog\n执行初始化命令\nnpx hexo init\n安装依赖包\nnpm install\n做完上述步骤后，D:!myths\\blog文件夹中出现以下文件夹：\n\n\n_config.yml：Hexo 全局配置文件（核心，用于配置博客标题、主题、部署信息等）；\nsource/：存放博客原始内容，_posts/ 文件夹用于存放所有博客文章（Markdown 格式）；\nthemes/：存放博客主题，默认主题为 landscape；\npublic/：Hexo 生成的静态网页文件（部署时需上传该目录内容）；\nscaffolds/：文章模板文件，新建文章时会基于模板生成。\n3.本地预览博客\n\n生成静态网页文件\nnpx hexo generate\n或者\nnpx hexo g\n启动本地服务器\nnpx hexo server\n或者\nnpx hexo s\n打开浏览器，访问http://localhost:4000\n\n4.创作博客文章\n\n新建博客文章\nnpx hexo new &quot;blog name&quot;\n使用命令后，文章会生成在source/_posts/目录下\n编辑博客文章\n用Markdown编辑器打开_posts下的md文件\n编辑后执行命令npx hexo clean &amp;&amp; npx hexo generate &amp;&amp; npx hexo deploy，博客里面的内容就会改变\n\n二、在github上配置SSH\n\n打开git bash\n\n\n\n生成秘钥对\nssh-keygen -t rsa -C &quot;你的github邮箱@xxx.com&quot;\n一路回车即可\n查看公钥内容，复制到剪切板上\ncat ~/.ssh/id_rsa.pub\n打开github，新建一个仓库，仓库名为你的名字.github.io\n在上方导航栏点开仓库的Setting，在左侧导航栏找到Deploy keys\n\n\n\n在Deploy Keys界面点击Add deploy key按钮\n\n\n\nTitle随便填，将之前复制的公钥内容粘贴到Key里面，然后点击Add key\n\n\n\n在git bash中输入命令ssh -T git@github.com，如果出现successfully的信息，就代表成功了。\n\n\n三、部署Hexo博客到Github Pages上\n\n记录仓库的SSH地址\n如果上述步骤都没问题的话，那么SSH地址应该是git@github.com:你的github的名字/你的github的名字.github.io.git\n安装Hexo部署插件\n在之前建立的博客根目录中在终端中执行命令\nnpm install hexo-deployer-git\n编辑部署信息\n打开根目录中的_config.yml文件，找到deploy配置项\n\n\n在repo填上仓库的SSH地址，要注意冒号后面有个空格\n\n部署博客到github\n在终端执行命令：\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n之后访问https://你的用户名.github.io，即可公网访问你的博客\n\n四、常用命令\n新建文章：npx hexo new &quot;文章名&quot;\n生成静态文件：npx hexo generate\n启动服务器：npx hexo server\n部署网站：npx hexo deploy\n清除缓存文件：npx hexo clean\n参考资料\nhttps://blog.csdn.net/qq_37294163/article/details/103099424\nhttps://blog.csdn.net/weixin_73527660/article/details/156200825\n","categories":["其他"]},{"title":"单例模式的实现","url":"/2025/12/30/SingletonMode/","content":"完整代码\npublic class Singleton&lt;T&gt; where T : class, new()&#123;    private static T m_instance;    private static readonly object syslock = new object();    public static T Instance    &#123;        get        &#123;            if (m_instance == null)            &#123;                lock (syslock)                &#123;                    if (m_instance == null)                    &#123;                        m_instance = new T();                    &#125;                &#125;            &#125;            return m_instance;        &#125;    &#125;&#125;\n使用方法\n\n创建单例类\n\n// 定义你的类，继承自Singleton&lt;T&gt;public class GameManager : Singleton&lt;GameManager&gt;&#123;    public int Score &#123; get; set; &#125;    // 私有构造函数，防止外部实例化    private GameManager()    &#123;    &#125;&#125;2. 访问单例类```C#// 在代码中任何地方都可以这样访问// 它会自动创建实例（第一次访问时）GameManager.Instance.StartGame();GameManager.Instance.Score = 100;"},{"title":"UI系统","url":"/2025/12/30/UISystem/","content":"完整代码\n\nBasePanel.cs\n\nusing UnityEngine;public class BasePanel : MonoBehaviour&#123;    protected bool isRemove = false;    protected new string name;    public virtual void OpenPanel(string name)    &#123;        this.name = name;        gameObject.SetActive(true);    &#125;    public virtual void ClosePanel()    &#123;        isRemove = true;        gameObject.SetActive(false);        Destroy(gameObject);        if (UIManager.Instance.panelDict.ContainsKey(name))        &#123;            UIManager.Instance.panelDict.Remove(name);        &#125;    &#125;&#125;\n\nUIManager.cs\n\npublic class UIConst&#123;    public const string MainMenuPanel = &quot;MainMenuPanel&quot;;    public const string SettingPanel = &quot;SettingPanel&quot;;    public const string PlayerStatePanel = &quot;PlayerStateBar&quot;;    public const string EnemyStatePanel = &quot;EnemyStateBar&quot;;    public const string DialoguePanel = &quot;DialoguePanel&quot;;&#125;public class UIManager&#123;    private static UIManager _instance;    private Transform _uiRoot;    private Dictionary&lt;string, string&gt; pathDict;    private Dictionary&lt;string, GameObject&gt; prefabsDict;    public Dictionary&lt;string, BasePanel&gt; panelDict;    public static UIManager Instance    &#123;        get        &#123;            if (_instance == null)            &#123;                _instance = new UIManager();            &#125;            return _instance;        &#125;    &#125;    public Transform UIRoot    &#123;        get        &#123;            if (_uiRoot == null)            &#123;                if (GameObject.Find(&quot;Canvas&quot;))                &#123;                    _uiRoot = GameObject.Find(&quot;Canvas&quot;).transform;                &#125;                else                &#123;                    _uiRoot = new GameObject(&quot;Canvas&quot;).transform;                &#125;            &#125;            return _uiRoot;        &#125;    &#125;    private UIManager()    &#123;        InitDicts();    &#125;    private void InitDicts()    &#123;        prefabsDict = new Dictionary&lt;string, GameObject&gt;();        panelDict = new Dictionary&lt;string, BasePanel&gt;();        pathDict = new Dictionary&lt;string, string&gt;()        &#123;            &#123; UIConst.MainMenuPanel ,UIConst.MainMenuPanel&#125;,            &#123; UIConst.SettingPanel ,UIConst.SettingPanel&#125;,            &#123; UIConst.PlayerStatePanel ,UIConst.PlayerStatePanel&#125;,            &#123; UIConst.EnemyStatePanel ,UIConst.EnemyStatePanel&#125;,            &#123; UIConst.DialoguePanel ,UIConst.DialoguePanel&#125;        &#125;;    &#125;    public BasePanel OpenPanel(string name)    &#123;        BasePanel panel = null;        if (panelDict.TryGetValue(name, out panel))        &#123;            Debug.Log(&quot;界面已打开&quot;);            return null;        &#125;        string path = &quot;&quot;;        if (!pathDict.TryGetValue(name, out path))        &#123;            Debug.Log(&quot;界面名称错误，或未配置路径 &quot; + name);            return null;        &#125;        GameObject panelPrefab = null;        if (!prefabsDict.TryGetValue(name, out panelPrefab))        &#123;            string realPath = &quot;Prefabs/UI/&quot; + path;//需在Resources/Prefabs/UI文件夹下放置UI的预制体            panelPrefab = Resources.Load&lt;GameObject&gt;(realPath) as GameObject;            prefabsDict.Add(name, panelPrefab);        &#125;        GameObject panelObject = GameObject.Instantiate(panelPrefab, UIRoot, false);        panelObject.transform.position = UIRoot.position;        panel = panelObject.GetComponent&lt;BasePanel&gt;();        panelDict.Add(name, panel);        panel.OpenPanel(name);        return panel;    &#125;    public bool ClosePanel(string name)    &#123;        BasePanel panel = null;        if (!panelDict.TryGetValue(name, out panel))        &#123;            Debug.Log(&quot;界面未打开&quot; + name);            return false;        &#125;        panel.ClosePanel();        return true;    &#125;&#125;"}]