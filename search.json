[{"title":"热更新中AB包的上传和下载（一）","url":"/2025/12/31/AssetBundle/","content":"一、热更新流程\n在资源需要变化时，向资源服务器（FTP、HTTP等）上传AB包和资源对比文件。\n每次通过游戏客户端进入时：\n\n下载服务器上的资源对比文件\n用下载下来的资源对比文件和本地文件进行对比，记录需要进行更新的AB包\n将需要更新的AB包进行更新，再更新资源对比文件\n完成后，正式进入游戏\n\n二、准备打包AB包的脚本\n在github上下载AssetBundles Browser\n可以通过url在包管理器里添加，也可以直接在https://github.com/Unity-Technologies/AssetBundles-Browser直接下载压缩包。\n如果是直接在github上下载压缩包，需要将里面的Test文件删除，不然直接在unity里会报错\n\n删除以后，就可以直接将压缩包里面的文件粘贴到Unity项目的Packages文件夹下\n\n添加后，在Unity按下Ctrl+R即可刷新，包就导入到项目中了\n接着就能在窗口选项里面找到AssetBundle Browser的选项\n\n点开后得到这样的界面：\n\n三、准备需要打包的内容\n在场景中创建简单的立方体、球体和圆柱体，用来模拟需要打包的内容。\n将创建好的物体拖到自己创建好的Assets/ArtRes/Prefab文件夹下。\n\n同时，创建好Assets/ArtRes/Lua文件夹用来存放lua脚本。\n打开Assets/ArtRes/Lua文件夹的资源管理器，在里面新建两个txt文本用来模拟lua脚本\n\n将三个刚刚创建的预制体添加到model包（自己创建）里\n\n接着，我们就可以在AssetBundle Browser视窗看到我们model包下的物体了\n\n也可以通过直接在AssetBundle Browser视窗，直接新建一个包\n\n这里新建一个lua包，用来装lua脚本\n\n将之前新建的用来模拟lua脚本的txt文件放入lua包中\n\n四、进行打包\n点击build按钮，来到build界面。\n\n我们需要新建Assets/ArtRes/AB/PC文件夹来存储build的输出结果\n\n将路径Assets/ArtRes/AB/PC放到Output Path中\n\n在高级设置里，只需要将压缩方式改为LZ4方式，是一种比较好的压缩方式，其他的选项都不用动\n\n最终设置为：\n\n点击Build，等待，然后就可以在Assets/ArtRes/AB/PC文件夹下看到打包出来的资源\n\n五、获取AB包文件的MD5码\n\nMD5码是什么\n\nMD5是信息摘要算法的简称，是一种广泛使用的密码散列函数，可以生成一个16字节的散列值，用于确保信息的完整一致性\n当我们把数据经过MD5算法计算后，不管我们传入的数据有多大，都会生成一个固定长度的MD5码\n相同的数据，经过MD5算法计算后的结果是一样的\n如果数据发生变化，MD5码会发生变化\n因此，我们通过MD5码作为文件的唯一标识，通过其判断文件内容是否发生变化\n\n编写获得MD5码的脚本\n\n流程：根据文件路径获得文件流信息-&gt;利用MOD加密服务提供商（通过MD5CryptoServiceProvider新建一个）对象，根据流信息，计算出MD5码-&gt;将字节数组形式的MD5码转为16进制字符串\n完整代码：\nusing System.IO;using System.Security.Cryptography;using System.Text;using UnityEngine;public class GetMD5 : MonoBehaviour&#123;    // Start is called before the first frame update    void Start()    &#123;        print(getfileMd5(Application.dataPath + &quot;/ArtRes/AB/PC/lua&quot;));    &#125;    // Update is called once per frame    void Update()    &#123;            &#125;    private string getfileMd5(string filePath)    &#123;        //将文件以流的形式打开        using(FileStream file = new FileStream(filePath, FileMode.Open))        &#123;            MD5 md5 = new MD5CryptoServiceProvider();//声明一个MD5对象            byte[] md5Info = md5.ComputeHash(file);//获得数据MD5码 16个字节的数组            //关闭文件流            file.Close();            StringBuilder sb = new StringBuilder();            for(int i = 0;i &lt; md5Info.Length; i++)            &#123;                sb.Append(md5Info[i].ToString(&quot;x2&quot;));//转换成16进制字符串            &#125;            return sb.ToString();        &#125;    &#125;&#125;\n运行后，可以正确得到lua包的MD5码\n\n当我们改变lua包里面的内容时，比如在lua包里新增一个lua脚本的txt文件，那么lua包的MD5码就会发生改变\n六、生成AB包资源对比文件\n功能：\n\n在菜单栏添加一个按钮，点击后能够生成AB包资源对比文件\n遍历AB包文件夹，获取所有AB包文件信息（文件名、大小、MD5码），将其存入资源对比文件\n\n首先在Assets文件夹下新建Editor文件夹，此文件夹下的代码不需要在游戏中使用，只在Unity编辑器中使用，因此放在此文件夹下使其不会被打包出去。\n并在Editor文件夹下新建CreateABCompare脚本，用来实现对应功能\n\n完整代码：\nusing System.IO;using System.Security.Cryptography;using System.Text;using UnityEditor;using UnityEngine;public class CreateABCompare&#123;    [MenuItem(&quot;Tool/创建AB包对比文件&quot;)]    public static void CreateABCompareFile()    &#123;        //获取文件夹信息        DirectoryInfo directory = Directory.CreateDirectory(            Application.dataPath + &quot;/ArtRes/AB/PC&quot;);        //获取该目录下所有文件        FileInfo[] files = directory.GetFiles();        //用于存储信息的字符串        string abCompareInfo = &quot;&quot;;                foreach (FileInfo file in files)        &#123;            //没有后缀的是AB包            if(file.Extension == &quot;&quot;)            &#123;                abCompareInfo += file.Name + &quot; &quot; + file.Length + &quot; &quot; + getfileMd5(file.FullName);                abCompareInfo += &quot;|&quot;;            &#125;        &#125;        //循环完毕后，截取最后一个“|”        abCompareInfo = abCompareInfo.Substring(0,abCompareInfo.Length - 1);        //存储信息        File.WriteAllText(Application.dataPath + &quot;/ArtRes/AB/PC/ABCompareInfo.txt&quot;,abCompareInfo);        AssetDatabase.Refresh();    &#125;    private static string getfileMd5(string filePath)    &#123;        //将文件以流的形式打开        using (FileStream file = new FileStream(filePath, FileMode.Open))        &#123;            MD5 md5 = new MD5CryptoServiceProvider();//声明一个MD5对象            byte[] md5Info = md5.ComputeHash(file);//获得数据MD5码 16个字节的数组            //关闭文件流            file.Close();            StringBuilder sb = new StringBuilder();            for (int i = 0; i &lt; md5Info.Length; i++)            &#123;                sb.Append(md5Info[i].ToString(&quot;x2&quot;));//转换成16进制字符串            &#125;            return sb.ToString();        &#125;    &#125;&#125;\n可以得到以下结果：\n左上角出现了tool栏，tool栏有创建AB包对比文件的选项\n\n点击该按钮后，可以看到生成的文件\n\n以及文件的内容\n\n七、搭建FTP服务器\n用于模拟资源服务器，用于存储资源和资源对比文件\n\n\n下载Serv-U\n可以通过这个网址下载：\nhttps://www.yxtown.com/my/course/65/material?type=material&amp;page=2\n\n\n注册上传账号和下载账号（匿名）\n\n\n是否定义新域，点击是\n\n名称随便填一个\n\n下一步\n\n下一步\n\n勾选单向加密，点完成\n\n接着会弹出这个界面，点是\n\n随便填，下一步\n\n随便，下一步\n\n设置根目录，之后上传的文件会放在这里\n\n选择完全访问，点击完成\n\n接下来需要一个匿名用户(不创建匿名用户也可以)，点击向导\n\n登录ID输入 Anonvmous，点下一步\n\n密码为空，匿名账号不需要密码，点下一步\n\n根目录和之前一样\n\n选择只读访问，点完成\n\n最终会出现两个账号\n\n\n验证\n在资源管理器输入ftp://127.0.0.1\n\n\n可以看到文件夹为空\n在之前设置的根目录中随便新建一个文件\n\n可以看到ftp服务器上多出了一个文件\n\n八、上传AB包和资源对比文件\n新建脚本UploadAB，用来向资源服务器上传AB包和资源对比文件\n完整代码：\nusing System;using System.IO;using System.Net;using System.Threading.Tasks;using UnityEditor;using UnityEngine;public class UploadAB&#123;    [MenuItem(&quot;Tool/上传AB包和对比文件&quot;)]    private static void UploadAllABFile()    &#123;        //获取文件夹信息        DirectoryInfo directory = Directory.CreateDirectory(            Application.dataPath + &quot;/ArtRes/AB/PC&quot;);        //获取该目录下所有文件        FileInfo[] files = directory.GetFiles();        foreach (FileInfo file in files)        &#123;            if (file.Extension == &quot;&quot; || file.Extension == &quot;.txt&quot;)            &#123;                FtpUploadFile(file.FullName, file.Name);            &#125;        &#125;    &#125;    private static async void FtpUploadFile(string filePath, string fileName)    &#123;        //异步处理，在上传文件时，不会卡住主线程        await Task.Run(() =&gt;        &#123;            try            &#123;                //1.创建FTP连接用于上传                FtpWebRequest req = FtpWebRequest.Create(new Uri(&quot;ftp://127.0.0.1/AB/PC/&quot; + fileName)) as FtpWebRequest;                //2.设置一个通信凭证，这样才能上传                NetworkCredential n = new NetworkCredential(&quot;qwe&quot;, &quot;123000&quot;);                req.Credentials = n;                //3.其他设置                req.Proxy = null;//设置代理为空                req.KeepAlive = false;//请求完毕后，是否关闭控制连接                req.Method = WebRequestMethods.Ftp.UploadFile;//操作命令-上传                req.UseBinary = true;//指定传输的类型-2进制                //4.上传文件                Stream upLoadStream = req.GetRequestStream();//ftp的流对象                                                             //读取文件信息，写入该流对象                using (FileStream file = File.OpenRead(filePath))                &#123;                    //一点一点上传                    byte[] bytes = new byte[2048];                    //读取了多少字节                    int contentLength = file.Read(bytes, 0, bytes.Length);                    //循环上传文件                    while (contentLength != 0)                    &#123;                        //写入到上传流中                        upLoadStream.Write(bytes, 0, contentLength);                        //写完再读                        contentLength = file.Read(bytes, 0, bytes.Length);                    &#125;                    //循环完毕后，上传完毕                    file.Close();                    upLoadStream.Close();                &#125;            &#125;            catch (Exception ex)            &#123;                Debug.Log(&quot;上传失败 &quot; + ex.Message);            &#125;            Debug.Log(fileName + &quot;上传成功&quot;);        &#125;        );    &#125;&#125;\n运行Tool选项里面的上传按钮后，会在资源服务器里看到上传的结果\n要注意因为上传的路径是 ftp://127.0.0.1/AB/PC/ ，因此如果资源服务器里没有/AB/PC文件夹的话，会发生报错，因为程序只负责上传，不会自动创建新文件夹\n\n","categories":["Unity"]},{"title":"热更新中AB包的上传和下载（二）","url":"/2026/01/01/AssetBundle2/","content":"九、下载资源服务器的资源对比文件和AB包\n先创建Main脚本，挂载到场景的空物体上，这个脚本会在游戏开始执行Start()函数\n然后创建ABUpdateMgr脚本，ABUpdateMgr是单例类，让其里面的函数可以被Main脚本调用\nABUpdateMgr用来实现下载资源服务器上的资源对比文件和AB包\nMain脚本代码：\nusing UnityEngine;public class Main : MonoBehaviour&#123;    // Start is called before the first frame update    private void Start()    &#123;        ABUpdateMgr.Instance.DownLoadABCompareFile();        ABUpdateMgr.Instance.DownLoadABFile((isOver) =&gt;        &#123;            if (isOver)            &#123;                print(&quot;所有AB包下载结束&quot;);            &#125;            else            &#123;                print(&quot;AB包下载过程中出现错误&quot;);            &#125;        &#125;,        (nowNum, maxNum) =&gt;        &#123;            print(&quot;下载进度：&quot; + nowNum + &quot;/&quot; + maxNum);        &#125;        );        print(&quot;AB相关函数执行完毕&quot;);    &#125;    // Update is called once per frame    private void Update()    &#123;    &#125;&#125;\nABUpdateMgr脚本代码：\nusing JetBrains.Annotations;using System;using System.Collections.Generic;using System.IO;using System.Net;using System.Threading.Tasks;using UnityEngine;using UnityEngine.Events;public class ABUpdateMgr : MonoBehaviour&#123;    private static ABUpdateMgr instance;    private Dictionary&lt;string, ABInfo&gt; remoteABInfo = new Dictionary&lt;string, ABInfo&gt;();    private List&lt;string&gt; downLoadList = new List&lt;string&gt;();//待下载的AB包文件名字列表    public static ABUpdateMgr Instance    &#123;        get        &#123;            if (instance == null)            &#123;                GameObject obj = new GameObject(&quot;ABUpdateMgr&quot;);                instance = obj.AddComponent&lt;ABUpdateMgr&gt;();            &#125;            return instance;        &#125;    &#125;    public void DownLoadABCompareFile()    &#123;        print(Application.persistentDataPath);        //1.从资源服务器下载资源对比文件        DownLoadFile(&quot;ABCompareInfo.txt&quot;, Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;);        //2.获取资源对比文件，进行字符串进行拆分        string info = File.ReadAllText(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;);        string[] strs = info.Split(&#x27;|&#x27;);        string[] infos = null;        for (int i = 0; i &lt; strs.Length; i++)        &#123;            infos = strs[i].Split(&#x27; &#x27;);            //记录每一个远端AB包的信息            remoteABInfo.Add(infos[0], new ABInfo(infos[0], infos[1], infos[2]));        &#125;    &#125;    //存储远端AB包，之后和本地进行对比    public async void DownLoadABFile(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;int, int&gt; UpdatePro)    &#123;        //1.遍历字典的键，根据文件名，下载AB包到本地        foreach (string name in remoteABInfo.Keys)        &#123;            downLoadList.Add(name);        &#125;        //本地存储路径，由于多线程不能访问Unity相关的一些内容，所以放在外部        string localPath = Application.persistentDataPath + &quot;/&quot;;        //记录下载成功的文件名的列表        List&lt;string&gt; tempList = new List&lt;string&gt;();        //是否下载成功        bool isOver = false;        //重新下载的最大次数        int downloadNum = 5;        //下载成功的文件数量        int downLoadOverNum = 0;        //这一次需要下载的文件总数量        int downLoadMaxNum = downLoadList.Count;        while (downLoadList.Count &gt; 0 &amp;&amp; downloadNum &gt; 0)        &#123;            for (int i = 0; i &lt; downLoadList.Count; i++)            &#123;                await Task.Run(() =&gt;                &#123;                    isOver = DownLoadFile(downLoadList[i], localPath + downLoadList[i]);                &#125;                );                if (isOver)                &#123;                    UpdatePro(++downLoadOverNum, downLoadMaxNum);                    tempList.Add(downLoadList[i]);                &#125;            &#125;            //把下载成功的文件名从下载列表中移除            //也可以让倒着遍历下载列表，下载一个就移除一个，就不需要临时列表的辅助            for (int i = 0; i &lt; tempList.Count; i++) downLoadList.Remove(tempList[i]);            downloadNum--;        &#125;        overCallBack(downLoadList.Count == 0);//告诉外部，下载成功    &#125;    private bool DownLoadFile(string fileName, string localPath)    &#123;        try        &#123;            //1.创建FTP连接用于下载            FtpWebRequest req = FtpWebRequest.Create(new Uri(&quot;ftp://127.0.0.1/AB/PC/&quot; + fileName)) as FtpWebRequest;            //2.设置一个通信凭证，这样才能下载            //如果有匿名账号，可以不设置凭证，但实际开发中，不要使用匿名账号，不然有安全隐患            NetworkCredential n = new NetworkCredential(&quot;qwe&quot;, &quot;123000&quot;);            req.Credentials = n;            //3.其他设置            req.Proxy = null;//设置代理为空            req.KeepAlive = false;//请求完毕后，是否关闭控制连接            req.Method = WebRequestMethods.Ftp.DownloadFile;//操作命令-上传            req.UseBinary = true;//指定传输的类型-2进制            //4.下载文件            FtpWebResponse res = req.GetResponse() as FtpWebResponse;            Stream downFileStream = res.GetResponseStream();//ftp的流对象            using (FileStream file = File.Create(localPath))            &#123;                //一点一点下载                byte[] bytes = new byte[2048];                //读取了多少字节                int contentLength = downFileStream.Read(bytes, 0, bytes.Length);                //循环下载文件                while (contentLength != 0)                &#123;                    //写入到本地文件流中                    file.Write(bytes, 0, contentLength);                    //写完再读                    contentLength = downFileStream.Read(bytes, 0, bytes.Length);                &#125;                //循环完毕后，下载完毕                file.Close();                downFileStream.Close();                res.Close();            &#125;            return true;        &#125;        catch (Exception ex)        &#123;            Debug.Log(fileName + &quot;下载失败 &quot; + ex.Message);            return false;        &#125;        return true;    &#125;    private void OnDestroy()    &#123;        instance = null;    &#125;    //AB包信息类    private class ABInfo    &#123;        public string md5;        public string name;        public long size;        public ABInfo(string name, string size, string md5)        &#123;            this.name = name;            this.size = long.Parse(size);            this.md5 = md5;        &#125;    &#125;&#125;\n运行游戏后，可以看到资源对比文件下载成功的信息，以及文件的路径\n\n十、设置默认资源\n选择ArtRes/PC/AB中的文件夹的文件，加入StreamingAssets文件夹(需自己创建)，作为默认资源，并生成本地资源对比文件\n新建脚本MoveABToSA\n完整代码：\nusing System.IO;using UnityEditor;using UnityEngine;public class MoveABToSA&#123;    [MenuItem(&quot;Tool/移动选中资源到StreamingAssets&quot;)]    private static void MoveABToStreamingAssets()    &#123;        //通过Selction类的方法，获取选中的资源        Object[] selectedAssets = Selection.GetFiltered(typeof(Object), SelectionMode.DeepAssets);        if (selectedAssets.Length == 0) return;        string abCompareInfo = &quot;&quot;;        foreach (Object assset in selectedAssets)        &#123;            //通过AssetDatabase类获取资源的路径            string assetPath = AssetDatabase.GetAssetPath(assset);            //截取路径当中的文件名，用于作为StreamingAssets中的文件名            string fileName = assetPath.Substring(assetPath.LastIndexOf(&#x27;/&#x27;));            //判断是否有.符号，如果有，证明有后缀，不处理            if (fileName.IndexOf(&#x27;.&#x27;) != -1) continue;            //利用AssetDatabase类的方法，复制文件到StreamingAssets目录下            AssetDatabase.CopyAsset(assetPath, &quot;Assets/StreamingAssets/&quot; + fileName);            //获取拷贝到StreamingAssets文件下的文件的信息            FileInfo fileInfo = new FileInfo(Application.streamingAssetsPath + &quot;/&quot; + fileName);            abCompareInfo += fileInfo.Name + &quot; &quot; + fileInfo.Length + &quot; &quot; + CreateABCompare.getfileMd5(fileInfo.FullName);            abCompareInfo += &quot;|&quot;;        &#125;        abCompareInfo = abCompareInfo.Substring(0, abCompareInfo.Length - 1);        File.WriteAllText(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;, abCompareInfo);        AssetDatabase.Refresh();    &#125;&#125;\n选中默认资源，然后点击Tool下方的按钮\n\n之后可以在StreamingAssets文件夹下看到移动的文件和生成的本地资源对比文件\n\n十一、默认资源转存问题\n已知：\nStreamingAssetsPath中有默认的AB包资源（只读路径）\npersistentDataPath中有下载的最新AB包资源（可读可写路径）\nAB包的资源管理器的逻辑有两种实现方法：\n\n若资源都从可读写路径中加载，则需要转存，如果默认资源很多的话，会浪费玩家的硬盘存储空间\n若可读写路径中没有资源，则去只读路径中加载，这么做就不会浪费玩家空间\n\n\n进入游戏后热更新流程：\n\n第一次进入游戏，有默认资源：读取默认资源（只读路径里的内容）的对比文件和远端的对比文件，进行对比，下载指定AB包，然后将远端的对比文件存储到可读写路径中\n第一次进入游戏，没有默认资源：将下载所有远端对比文件中的AB包，存储到可读写路径\n非第一次进入游戏：从可读写路径中获取对比文件，与远端的对比文件进行对比，然后更新可读写路径中的文件\n\n\n十二、获取远端对比文件信息\n之前写的获取远端对比文件的代码不够完善，要保证获取资源服务器对比文件信息，但不覆盖本地的资源对比文件，因此需要修改\n有两种做法：\n\n保存到临时文件，待AB包下载完成后，再用该临时文件覆盖本地对比文件\n压根不保存文件，直接通过下载流取出字节数组转为字符串，待AB包下载完后再保存为本地资源对比文件\n这里使用做法1，我们需要修改ABUpdateMgr脚本的DownLoadABCompareFile函数\n\npublic void DownLoadABCompareFile()&#123;    print(Application.persistentDataPath);    //1.从资源服务器下载资源对比文件    DownLoadFile(&quot;ABCompareInfo.txt&quot;, Application.persistentDataPath + &quot;/ABCompareInfo_TMP.txt&quot;);    //2.获取资源对比文件，进行字符串进行拆分    string info = File.ReadAllText(Application.persistentDataPath + &quot;/ABCompareInfo_TMP.txt&quot;);    string[] strs = info.Split(&#x27;|&#x27;);    string[] infos = null;    for (int i = 0; i &lt; strs.Length; i++)    &#123;        infos = strs[i].Split(&#x27; &#x27;);        //记录每一个远端AB包的信息        remoteABInfo.Add(infos[0], new ABInfo(infos[0], infos[1], infos[2]));    &#125;&#125;\n十三、获取本地对比文件信息\n完整代码：\npublic void GetLocalABCompareFileInfo(UnityAction&lt;bool&gt; overCallBack)&#123;    //Application.persistentDataPath;    //Application.streamingAssetsPath;    //如果可读写文件夹中存在对比文件，说明之前下载更新过了    if (File.Exists(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;))    &#123;        StartCoroutine(GetLocalABCompareFileInfo(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;, overCallBack));    &#125;    //只有当可读写文件夹中没有对比文件时，才去读取默认资源文件夹中的对比文件（第一次进入游戏时发生）    else if (File.Exists(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;))    &#123;        StartCoroutine(GetLocalABCompareFileInfo(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;, overCallBack));    &#125;//如果两个都不满足，说明游戏第一次进入，且没有默认资源    else    &#123;        overCallBack(false);    &#125;    //StartCoroutine(GetLocalABCompareFileInfo);&#125;private IEnumerator GetLocalABCompareFileInfo(string filePath, UnityAction&lt;bool&gt; overCallBack)&#123;    //通过UnityWebRequest获取本地的AB对比文件    UnityWebRequest req = UnityWebRequest.Get(filePath);    yield return req.SendWebRequest();    //获取文件成功，继续往下执行    //print(req.downloadHandler.text);    if (req.result == UnityWebRequest.Result.Success)    &#123;        GetABCompareFIleInfo(req.downloadHandler.text, localABInfo);        overCallBack(true);    &#125;    else    &#123;        overCallBack(false);    &#125;&#125;\n根据十一提到的逻辑，获取本地的对比文件。如果可读写文件夹中存在对比文件，说明之前下载更新过了，那么直接获取可读写文件夹内对比文件的信息。\n只有当可读写文件夹中没有对比文件时，说明第一次进入游戏，去读取默认资源文件夹中的对比文件。\nGetABCompareFIleInfo函数的功能是获取对比文件的信息，而是否是远端还是本地，函数内部不做区分。\npublic void GetABCompareFIleInfo(string info, Dictionary&lt;string, ABInfo&gt; ABInfo)&#123;    //2.获取资源对比文件，进行字符串进行拆分    string[] strs = info.Split(&#x27;|&#x27;);    string[] infos = null;    for (int i = 0; i &lt; strs.Length; i++)    &#123;        infos = strs[i].Split(&#x27; &#x27;);        //记录每一个远端AB包的信息        ABInfo.Add(infos[0], new ABInfo(infos[0], infos[1], infos[2]));    &#125;&#125;\nDownLoadABCompareFile函数原本分为第一步：从资源服务器下载资源对比文件，和第二步：获取资源对比文件，进行字符串进行拆分。\nGetABCompareFIleInfo函数已经负责实现了第二步，因此DownLoadABCompareFile函数的逻辑需要进行修改。\npublic async void DownLoadABCompareFile(UnityAction&lt;bool&gt; overCallBack)&#123;    //1.从资源服务器下载资源对比文件    // www UnityWebRequest ftp相关api    print(Application.persistentDataPath);    bool isOver = false;    int reDownLoadMaxNum = 5;    //不能在子线程中访问Unity主线程的 Application 所以 在外面声明    string localPath = Application.persistentDataPath;    while (!isOver &amp;&amp; reDownLoadMaxNum &gt; 0)    &#123;        await Task.Run(() =&gt;        &#123;            isOver = DownLoadFile(&quot;ABCompareInfo.txt&quot;, localPath + &quot;/ABCompareInfo_TMP.txt&quot;);        &#125;);        --reDownLoadMaxNum;    &#125;    //告诉外部成功与否    overCallBack?.Invoke(isOver);&#125;\n接着，我们新建一个函数CheckUpdate，用于外部调用，外部只需要调用这个函数即可完成热更新。\npublic void CheckUpdate(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; updateInfoCallBack)&#123;    DownLoadABCompareFile((isOver1) =&gt;    &#123;        updateInfoCallBack(&quot;开始更新资源&quot;);        if (isOver1)        &#123;            //1.加载远端资源对比文件            updateInfoCallBack(&quot;对比文件下载结束&quot;);            string remoteInfo = File.ReadAllText(Application.persistentDataPath + &quot;/ABCompareInfo_TMP.txt&quot;);            updateInfoCallBack(&quot;解析远端对比文件&quot;);            GetABCompareFIleInfo(remoteInfo, remoteABInfo);            updateInfoCallBack(&quot;解析远端对比文件完成&quot;);            //2.加载本地资源对比文件            GetLocalABCompareFileInfo((isOver2) =&gt;            &#123;                if (isOver2)                &#123;                    updateInfoCallBack(&quot;解析本地对比文件完成&quot;);                    //3.对比两个文件，进行AB包的下载                &#125;                else                &#123;                    overCallBack(false);                &#125;            &#125;);        &#125;        else        &#123;            overCallBack(false);        &#125;    &#125;);&#125;\n同时，我们在Main脚本中进行修改\nusing UnityEngine;public class Main : MonoBehaviour&#123;    // Start is called before the first frame update    private void Start()    &#123;        ABUpdateMgr.Instance.CheckUpdate((isOver) =&gt;        &#123;            if (isOver)            &#123;                print(&quot;检测更新结束&quot;);            &#125;            else            &#123;                print(&quot;网络出错&quot;);            &#125;        &#125;, (str) =&gt;        &#123;            print(str);        &#125;);    &#125;    // Update is called once per frame    private void Update()    &#123;    &#125;&#125;\n游戏开始时，挂载在空物体上的Main脚本会运行Start函数，然后运行ABUpdateMgr单例类的CheckUpdate函数，进行热更新。\n十四、进行本地对比文件信息与远端对比文件信息之间的对比\n热更新的内容已经基本完成，接下来，我们还需要处理远端对比文件信息和本地对比文件信息之间的比较，然后根据比较的信息，下载需要更新的AB包。\n我们已经有了类型为Dictionary&lt;string, ABInfo&gt;的两个字典，remoteABInfo和localABInfo，分别存储远端对比文件信息和本地对比文件信息。\n需要进行三个步骤：\n\n判断哪些资源是新的，记录，之后用于下载；\n判断哪些资源需要更新，记录，然后用于下载；\n判断哪些资源需要删除\n\n我们需要修改DownLoadABFile函数\n这个函数的功能是根据downList列表来下载AB包\npublic async void DownLoadABFile(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; UpdatePro)&#123;    //1.遍历字典的键，根据文件名，下载AB包到本地    /*    foreach (string name in remoteABInfo.Keys)    &#123;        downLoadList.Add(name);    &#125;*/    //本地存储路径，由于多线程不能访问Unity相关的一些内容，所以放在外部    string localPath = Application.persistentDataPath + &quot;/&quot;;    //记录下载成功的文件名的列表    List&lt;string&gt; tempList = new List&lt;string&gt;();    //是否下载成功    bool isOver = false;    //重新下载的最大次数    int downloadNum = 5;    //下载成功的文件数量    int downLoadOverNum = 0;    //这一次需要下载的文件总数量    int downLoadMaxNum = downLoadList.Count;    while (downLoadList.Count &gt; 0 &amp;&amp; downloadNum &gt; 0)    &#123;        for (int i = 0; i &lt; downLoadList.Count; i++)        &#123;            await Task.Run(() =&gt;            &#123;                isOver = DownLoadFile(downLoadList[i], localPath + downLoadList[i]);            &#125;            );            if (isOver)            &#123;                UpdatePro(++downLoadOverNum + &quot;/&quot; + downLoadMaxNum);                tempList.Add(downLoadList[i]);            &#125;        &#125;        //把下载成功的文件名从下载列表中移除        //也可以让倒着遍历下载列表，下载一个就移除一个，就不需要临时列表的辅助        for (int i = 0; i &lt; tempList.Count; i++) downLoadList.Remove(tempList[i]);        downloadNum--;    &#125;    overCallBack(downLoadList.Count == 0);//告诉外部，下载成功&#125;\n接下来我们补充CheckUpdate函数的内容\npublic void CheckUpdate(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; updateInfoCallBack)&#123;    remoteABInfo.Clear();    localABInfo.Clear();    downLoadList.Clear();    DownLoadABCompareFile((isOver1) =&gt;    &#123;        updateInfoCallBack(&quot;开始更新资源&quot;);        if (isOver1)        &#123;            //1.加载远端资源对比文件            updateInfoCallBack(&quot;对比文件下载结束&quot;);            string remoteInfo = File.ReadAllText(Application.persistentDataPath + &quot;/ABCompareInfo_TMP.txt&quot;);            updateInfoCallBack(&quot;解析远端对比文件&quot;);            GetABCompareFIleInfo(remoteInfo, remoteABInfo);            updateInfoCallBack(&quot;解析远端对比文件完成&quot;);            //2.加载本地资源对比文件            GetLocalABCompareFileInfo((isOver2) =&gt;            &#123;                if (isOver2)                &#123;                    updateInfoCallBack(&quot;解析本地对比文件完成&quot;);                    //3.对比两个文件，进行AB包的下载                    updateInfoCallBack(&quot;开始对比&quot;);                    foreach (var abName in remoteABInfo.Keys)                    &#123;                        //3.1判断哪些资源是新的，记录，之后用于下载                        //如果本地没有对应的AB包，则加入待下载列表                        if (!localABInfo.ContainsKey(abName))                        &#123;                            downLoadList.Add(abName);                        &#125;                        //3.2判断哪些资源需要更新，记录，然后用于下载                        //本地有同名的AB包，判断是否需要更新                        else                        &#123;                            //如果本地有对应的AB包，则对比MD5值                            if (localABInfo[abName].md5 != remoteABInfo[abName].md5)                            &#123;                                downLoadList.Add(abName);                            &#125;                            //3.3判断哪些资源需要删除                            localABInfo.Remove(abName);//把已经对比过的，从本地字典中移除，剩下的就是需要删除的                        &#125;                    &#125;                    updateInfoCallBack(&quot;对比完成，删除无用的AB包文件&quot;);                    //对比完后，先删除没用的内容                    foreach (var abName in localABInfo.Keys)                    &#123;                        if (File.Exists(Application.persistentDataPath + &quot;/&quot; + abName))                        &#123;                            File.Delete(Application.persistentDataPath + &quot;/&quot; + abName);                        &#125;                    &#125;                    updateInfoCallBack(&quot;下载和更新AB包文件&quot;);                    DownLoadABFile((isOver3) =&gt;                    &#123;                        if (isOver3)                        &#123;                            //在下载完AB包后                            //把本地的AB包对比文件更新为最新                            //把之前读取的远端信息写到文件                            File.WriteAllText(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;, remoteInfo);                        &#125;                        overCallBack(isOver3);                    &#125;, updateInfoCallBack);                &#125;                else                &#123;                    overCallBack(false);                &#125;            &#125;);        &#125;        else        &#123;            overCallBack(false);        &#125;    &#125;);&#125;\nDownLoadABFile函数也做了修改，将UnityAction&lt;int,int&gt;改为了UnityAction &lt; string &gt; ，用来显示下载进度\npublic async void DownLoadABFile(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; UpdatePro)&#123;    //1.遍历字典的键，根据文件名，下载AB包到本地    /*    foreach (string name in remoteABInfo.Keys)    &#123;        downLoadList.Add(name);    &#125;*/    //本地存储路径，由于多线程不能访问Unity相关的一些内容，所以放在外部    string localPath = Application.persistentDataPath + &quot;/&quot;;    //记录下载成功的文件名的列表    List&lt;string&gt; tempList = new List&lt;string&gt;();    //是否下载成功    bool isOver = false;    //重新下载的最大次数    int downloadNum = 5;    //下载成功的文件数量    int downLoadOverNum = 0;    //这一次需要下载的文件总数量    int downLoadMaxNum = downLoadList.Count;    while (downLoadList.Count &gt; 0 &amp;&amp; downloadNum &gt; 0)    &#123;        for (int i = 0; i &lt; downLoadList.Count; i++)        &#123;            await Task.Run(() =&gt;            &#123;                isOver = DownLoadFile(downLoadList[i], localPath + downLoadList[i]);            &#125;            );            if (isOver)            &#123;                UpdatePro(++downLoadOverNum + &quot;/&quot; + downLoadMaxNum);                tempList.Add(downLoadList[i]);            &#125;        &#125;        //把下载成功的文件名从下载列表中移除        //也可以让倒着遍历下载列表，下载一个就移除一个，就不需要临时列表的辅助        for (int i = 0; i &lt; tempList.Count; i++) downLoadList.Remove(tempList[i]);        downloadNum--;    &#125;    overCallBack(downLoadList.Count == 0);//告诉外部，下载成功&#125;\n到此，热更新的主要逻辑已经完成。\n十五、完整代码\nUnity里的内容如下：\n\nCreateABCompare.cs\n创建AB对比文件\nusing System.IO;using System.Security.Cryptography;using System.Text;using UnityEditor;using UnityEngine;public class CreateABCompare&#123;    [MenuItem(&quot;Tool/创建AB包对比文件&quot;)]    public static void CreateABCompareFile()    &#123;        //获取文件夹信息        DirectoryInfo directory = Directory.CreateDirectory(            Application.dataPath + &quot;/ArtRes/AB/PC&quot;);        //获取该目录下所有文件        FileInfo[] files = directory.GetFiles();        //用于存储信息的字符串        string abCompareInfo = &quot;&quot;;        foreach (FileInfo file in files)        &#123;            //没有后缀的是AB包            if (file.Extension == &quot;&quot;)            &#123;                abCompareInfo += file.Name + &quot; &quot; + file.Length + &quot; &quot; + getfileMd5(file.FullName);                abCompareInfo += &quot;|&quot;;            &#125;        &#125;        //循环完毕后，截取最后一个“|”        abCompareInfo = abCompareInfo.Substring(0, abCompareInfo.Length - 1);        //存储信息        File.WriteAllText(Application.dataPath + &quot;/ArtRes/AB/PC/ABCompareInfo.txt&quot;, abCompareInfo);        AssetDatabase.Refresh();    &#125;    public static string getfileMd5(string filePath)    &#123;        //将文件以流的形式打开        using (FileStream file = new FileStream(filePath, FileMode.Open))        &#123;            MD5 md5 = new MD5CryptoServiceProvider();//声明一个MD5对象            byte[] md5Info = md5.ComputeHash(file);//获得数据MD5码 16个字节的数组            //关闭文件流            file.Close();            StringBuilder sb = new StringBuilder();            for (int i = 0; i &lt; md5Info.Length; i++)            &#123;                sb.Append(md5Info[i].ToString(&quot;x2&quot;));//转换成16进制字符串            &#125;            return sb.ToString();        &#125;    &#125;&#125;\nMoveABToSA.cs\n将AB包移动StreamingAssets文件夹作为默认资源\nusing System.IO;using UnityEditor;using UnityEngine;public class MoveABToSA&#123;    [MenuItem(&quot;Tool/移动选中资源到StreamingAssets&quot;)]    private static void MoveABToStreamingAssets()    &#123;        //通过Selction类的方法，获取选中的资源        Object[] selectedAssets = Selection.GetFiltered(typeof(Object), SelectionMode.DeepAssets);        if (selectedAssets.Length == 0) return;        string abCompareInfo = &quot;&quot;;        foreach (Object assset in selectedAssets)        &#123;            //通过AssetDatabase类获取资源的路径            string assetPath = AssetDatabase.GetAssetPath(assset);            //截取路径当中的文件名，用于作为StreamingAssets中的文件名            string fileName = assetPath.Substring(assetPath.LastIndexOf(&#x27;/&#x27;));            //判断是否有.符号，如果有，证明有后缀，不处理            if (fileName.IndexOf(&#x27;.&#x27;) != -1) continue;            //利用AssetDatabase类的方法，复制文件到StreamingAssets目录下            AssetDatabase.CopyAsset(assetPath, &quot;Assets/StreamingAssets/&quot; + fileName);            //获取拷贝到StreamingAssets文件下的文件的信息            FileInfo fileInfo = new FileInfo(Application.streamingAssetsPath + &quot;/&quot; + fileName);            abCompareInfo += fileInfo.Name + &quot; &quot; + fileInfo.Length + &quot; &quot; + CreateABCompare.getfileMd5(fileInfo.FullName);            abCompareInfo += &quot;|&quot;;        &#125;        abCompareInfo = abCompareInfo.Substring(0, abCompareInfo.Length - 1);        File.WriteAllText(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;, abCompareInfo);        AssetDatabase.Refresh();    &#125;&#125;\nUploadAB.cs\n上传AB包到资源服务器\nusing System;using System.IO;using System.Net;using System.Threading.Tasks;using UnityEditor;using UnityEngine;public class UploadAB&#123;    [MenuItem(&quot;Tool/上传AB包和对比文件&quot;)]    private static void UploadAllABFile()    &#123;        //获取文件夹信息        DirectoryInfo directory = Directory.CreateDirectory(            Application.dataPath + &quot;/ArtRes/AB/PC&quot;);        //获取该目录下所有文件        FileInfo[] files = directory.GetFiles();        foreach (FileInfo file in files)        &#123;            //Debug.Log(file.Name + &quot; &quot; + file.Extension);            if (file.Extension == &quot;&quot; || file.Extension == &quot;.txt&quot;)            &#123;                FtpUploadFile(file.FullName, file.Name);            &#125;        &#125;    &#125;    private static async void FtpUploadFile(string filePath, string fileName)    &#123;        //异步处理，在上传文件时，不会卡住主线程        await Task.Run(() =&gt;        &#123;            try            &#123;                //1.创建FTP连接用于上传                FtpWebRequest req = FtpWebRequest.Create(new Uri(&quot;ftp://127.0.0.1/AB/PC/&quot; + fileName)) as FtpWebRequest;                //2.设置一个通信凭证，这样才能上传                NetworkCredential n = new NetworkCredential(&quot;qwe&quot;, &quot;123000&quot;);                req.Credentials = n;                //3.其他设置                req.Proxy = null;//设置代理为空                req.KeepAlive = false;//请求完毕后，是否关闭控制连接                req.Method = WebRequestMethods.Ftp.UploadFile;//操作命令-上传                req.UseBinary = true;//指定传输的类型-2进制                //4.上传文件                Stream upLoadStream = req.GetRequestStream();//ftp的流对象                                                             //读取文件信息，写入该流对象                using (FileStream file = File.OpenRead(filePath))                &#123;                    //一点一点上传                    byte[] bytes = new byte[2048];                    //读取了多少字节                    int contentLength = file.Read(bytes, 0, bytes.Length);                    //循环上传文件                    while (contentLength != 0)                    &#123;                        //写入到上传流中                        upLoadStream.Write(bytes, 0, contentLength);                        //写完再读                        contentLength = file.Read(bytes, 0, bytes.Length);                    &#125;                    //循环完毕后，上传完毕                    file.Close();                    upLoadStream.Close();                &#125;            &#125;            catch (Exception ex)            &#123;                Debug.Log(&quot;上传失败 &quot; + ex.Message);            &#125;            Debug.Log(fileName + &quot;上传成功&quot;);        &#125;        );    &#125;&#125;\nABUpdateMgr.cs\n单例类，完成热更新的逻辑\nusing System;using System.Collections;using System.Collections.Generic;using System.IO;using System.Net;using System.Threading.Tasks;using UnityEngine;using UnityEngine.Events;using UnityEngine.Networking;public class ABUpdateMgr : MonoBehaviour&#123;    private static ABUpdateMgr instance;    private Dictionary&lt;string, ABInfo&gt; remoteABInfo = new Dictionary&lt;string, ABInfo&gt;();//存储远端AB包信息的字典    private Dictionary&lt;string, ABInfo&gt; localABInfo = new Dictionary&lt;string, ABInfo&gt;();//存储本地AB包信息的字典    private List&lt;string&gt; downLoadList = new List&lt;string&gt;();//待下载的AB包文件名字列表    public static ABUpdateMgr Instance    &#123;        get        &#123;            if (instance == null)            &#123;                GameObject obj = new GameObject(&quot;ABUpdateMgr&quot;);                instance = obj.AddComponent&lt;ABUpdateMgr&gt;();            &#125;            return instance;        &#125;    &#125;    public void CheckUpdate(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; updateInfoCallBack)    &#123;        remoteABInfo.Clear();        localABInfo.Clear();        downLoadList.Clear();        DownLoadABCompareFile((isOver1) =&gt;        &#123;            updateInfoCallBack(&quot;开始更新资源&quot;);            if (isOver1)            &#123;                //1.加载远端资源对比文件                updateInfoCallBack(&quot;对比文件下载结束&quot;);                string remoteInfo = File.ReadAllText(Application.persistentDataPath + &quot;/ABCompareInfo_TMP.txt&quot;);                updateInfoCallBack(&quot;解析远端对比文件&quot;);                GetABCompareFIleInfo(remoteInfo, remoteABInfo);                updateInfoCallBack(&quot;解析远端对比文件完成&quot;);                //2.加载本地资源对比文件                GetLocalABCompareFileInfo((isOver2) =&gt;                &#123;                    if (isOver2)                    &#123;                        updateInfoCallBack(&quot;解析本地对比文件完成&quot;);                        //3.对比两个文件，进行AB包的下载                        updateInfoCallBack(&quot;开始对比&quot;);                        foreach (var abName in remoteABInfo.Keys)                        &#123;                            //3.1判断哪些资源是新的，记录，之后用于下载                            //如果本地没有对应的AB包，则加入待下载列表                            if (!localABInfo.ContainsKey(abName))                            &#123;                                downLoadList.Add(abName);                            &#125;                            //3.2判断哪些资源需要更新，记录，然后用于下载                            //本地有同名的AB包，判断是否需要更新                            else                            &#123;                                //如果本地有对应的AB包，则对比MD5值                                if (localABInfo[abName].md5 != remoteABInfo[abName].md5)                                &#123;                                    downLoadList.Add(abName);                                &#125;                                //3.3判断哪些资源需要删除                                localABInfo.Remove(abName);//把已经对比过的，从本地字典中移除，剩下的就是需要删除的                            &#125;                        &#125;                        updateInfoCallBack(&quot;对比完成，删除无用的AB包文件&quot;);                        //对比完后，先删除没用的内容                        foreach (var abName in localABInfo.Keys)                        &#123;                            if (File.Exists(Application.persistentDataPath + &quot;/&quot; + abName))                            &#123;                                File.Delete(Application.persistentDataPath + &quot;/&quot; + abName);                            &#125;                        &#125;                        updateInfoCallBack(&quot;下载和更新AB包文件&quot;);                        DownLoadABFile((isOver3) =&gt;                        &#123;                            if (isOver3)                            &#123;                                //在下载完AB包后                                //把本地的AB包对比文件更新为最新                                //把之前读取的远端信息写到文件                                File.WriteAllText(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;, remoteInfo);                            &#125;                            overCallBack(isOver3);                        &#125;, updateInfoCallBack);                    &#125;                    else                    &#123;                        overCallBack(false);                    &#125;                &#125;);            &#125;            else            &#123;                overCallBack(false);            &#125;        &#125;);    &#125;    public async void DownLoadABCompareFile(UnityAction&lt;bool&gt; overCallBack)    &#123;        //1.从资源服务器下载资源对比文件        // www UnityWebRequest ftp相关api        print(Application.persistentDataPath);        bool isOver = false;        int reDownLoadMaxNum = 5;        //不能在子线程中访问Unity主线程的 Application 所以 在外面声明        string localPath = Application.persistentDataPath;        while (!isOver &amp;&amp; reDownLoadMaxNum &gt; 0)        &#123;            await Task.Run(() =&gt;            &#123;                isOver = DownLoadFile(&quot;ABCompareInfo.txt&quot;, localPath + &quot;/ABCompareInfo_TMP.txt&quot;);            &#125;);            --reDownLoadMaxNum;        &#125;        //告诉外部成功与否        overCallBack?.Invoke(isOver);    &#125;    public void GetABCompareFIleInfo(string info, Dictionary&lt;string, ABInfo&gt; ABInfo)    &#123;        //2.获取资源对比文件，进行字符串进行拆分        string[] strs = info.Split(&#x27;|&#x27;);        string[] infos = null;        for (int i = 0; i &lt; strs.Length; i++)        &#123;            infos = strs[i].Split(&#x27; &#x27;);            //记录每一个远端AB包的信息            ABInfo.Add(infos[0], new ABInfo(infos[0], infos[1], infos[2]));        &#125;    &#125;    public void GetLocalABCompareFileInfo(UnityAction&lt;bool&gt; overCallBack)    &#123;        //Application.persistentDataPath;        //Application.streamingAssetsPath;        //如果可读写文件夹中存在对比文件，说明之前下载更新过了        if (File.Exists(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;))        &#123;            StartCoroutine(GetLocalABCompareFileInfo(Application.persistentDataPath + &quot;/ABCompareInfo.txt&quot;, overCallBack));        &#125;        //只有当可读写文件夹中没有对比文件时，才去读取默认资源文件夹中的对比文件（第一次进入游戏时发生）        else if (File.Exists(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;))        &#123;            StartCoroutine(GetLocalABCompareFileInfo(Application.streamingAssetsPath + &quot;/ABCompareInfo.txt&quot;, overCallBack));        &#125;//如果两个都不满足，说明游戏第一次进入，且没有默认资源        else        &#123;            overCallBack(false);        &#125;        //StartCoroutine(GetLocalABCompareFileInfo);    &#125;    private IEnumerator GetLocalABCompareFileInfo(string filePath, UnityAction&lt;bool&gt; overCallBack)    &#123;        //通过UnityWebRequest获取本地的AB对比文件        UnityWebRequest req = UnityWebRequest.Get(filePath);        yield return req.SendWebRequest();        //获取文件成功，继续往下执行        //print(req.downloadHandler.text);        if (req.result == UnityWebRequest.Result.Success)        &#123;            GetABCompareFIleInfo(req.downloadHandler.text, localABInfo);            overCallBack(true);        &#125;        else        &#123;            overCallBack(false);        &#125;    &#125;    //存储远端AB包，之后和本地进行对比    public async void DownLoadABFile(UnityAction&lt;bool&gt; overCallBack, UnityAction&lt;string&gt; UpdatePro)    &#123;        //1.遍历字典的键，根据文件名，下载AB包到本地        /*        foreach (string name in remoteABInfo.Keys)        &#123;            downLoadList.Add(name);        &#125;*/        //本地存储路径，由于多线程不能访问Unity相关的一些内容，所以放在外部        string localPath = Application.persistentDataPath + &quot;/&quot;;        //记录下载成功的文件名的列表        List&lt;string&gt; tempList = new List&lt;string&gt;();        //是否下载成功        bool isOver = false;        //重新下载的最大次数        int downloadNum = 5;        //下载成功的文件数量        int downLoadOverNum = 0;        //这一次需要下载的文件总数量        int downLoadMaxNum = downLoadList.Count;        while (downLoadList.Count &gt; 0 &amp;&amp; downloadNum &gt; 0)        &#123;            for (int i = 0; i &lt; downLoadList.Count; i++)            &#123;                await Task.Run(() =&gt;                &#123;                    isOver = DownLoadFile(downLoadList[i], localPath + downLoadList[i]);                &#125;                );                if (isOver)                &#123;                    UpdatePro(++downLoadOverNum + &quot;/&quot; + downLoadMaxNum);                    tempList.Add(downLoadList[i]);                &#125;            &#125;            //把下载成功的文件名从下载列表中移除            //也可以让倒着遍历下载列表，下载一个就移除一个，就不需要临时列表的辅助            for (int i = 0; i &lt; tempList.Count; i++) downLoadList.Remove(tempList[i]);            downloadNum--;        &#125;        overCallBack(downLoadList.Count == 0);//告诉外部，下载成功    &#125;    private bool DownLoadFile(string fileName, string localPath)    &#123;        try        &#123;            //1.创建FTP连接用于下载            FtpWebRequest req = FtpWebRequest.Create(new Uri(&quot;ftp://127.0.0.1/AB/PC/&quot; + fileName)) as FtpWebRequest;            //2.设置一个通信凭证，这样才能下载            //如果有匿名账号，可以不设置凭证，但实际开发中，不要使用匿名账号，不然有安全隐患            NetworkCredential n = new NetworkCredential(&quot;qwe&quot;, &quot;123000&quot;);            req.Credentials = n;            //3.其他设置            req.Proxy = null;//设置代理为空            req.KeepAlive = false;//请求完毕后，是否关闭控制连接            req.Method = WebRequestMethods.Ftp.DownloadFile;//操作命令-上传            req.UseBinary = true;//指定传输的类型-2进制            //4.下载文件            FtpWebResponse res = req.GetResponse() as FtpWebResponse;            Stream downFileStream = res.GetResponseStream();//ftp的流对象            using (FileStream file = File.Create(localPath))            &#123;                //一点一点下载                byte[] bytes = new byte[2048];                //读取了多少字节                int contentLength = downFileStream.Read(bytes, 0, bytes.Length);                //循环下载文件                while (contentLength != 0)                &#123;                    //写入到本地文件流中                    file.Write(bytes, 0, contentLength);                    //写完再读                    contentLength = downFileStream.Read(bytes, 0, bytes.Length);                &#125;                //循环完毕后，下载完毕                file.Close();                downFileStream.Close();                res.Close();            &#125;            return true;        &#125;        catch (Exception ex)        &#123;            Debug.Log(fileName + &quot;下载失败 &quot; + ex.Message);            return false;        &#125;    &#125;    private void OnDestroy()    &#123;        instance = null;    &#125;    //AB包信息类    public class ABInfo    &#123;        public string md5;        public string name;        public long size;        public ABInfo(string name, string size, string md5)        &#123;            this.name = name;            this.size = long.Parse(size);            this.md5 = md5;        &#125;    &#125;&#125;\nMain.cs\nusing UnityEngine;public class Main : MonoBehaviour&#123;    // Start is called before the first frame update    private void Start()    &#123;        ABUpdateMgr.Instance.CheckUpdate((isOver) =&gt;        &#123;            if (isOver)            &#123;                print(&quot;检测更新结束&quot;);            &#125;            else            &#123;                print(&quot;网络出错&quot;);            &#125;        &#125;, (str) =&gt;        &#123;            print(str);        &#125;);    &#125;    // Update is called once per frame    private void Update()    &#123;    &#125;&#125;\n参考内容\nhttps://www.bilibili.com/video/BV1VP411G7w2?spm_id_from=333.788.videopod.sections&amp;vd_source=5ddeed13107206194ba5b740648582d3\n","categories":["Unity"]},{"title":"黑板模式","url":"/2025/12/30/BlackBoardMode/","content":"简单介绍\n黑板是一个共享数据的系统，进行游戏系统的不同模块之间的通信，比起将越来越多的变量存在Player类中，不如集中存在一个地方进行集中管理。\n下面的代码是一些我在之前的课程项目中实现的黑板，目的是存储敌人ai的技能cd。\n当ai使用完技能后，就会调用黑板里面的函数，让技能能否使用的布尔变量变为false，并在一段时间后变为true。\n这是比较简单的黑板，如果要实现更复杂的功能，就需要自己写出对应的实现。\n完整代码\n[Serializable]private class BlackBoardTimer&#123;    public float Timer;    public string Key;    public mData Value;    public BlackBoardTimer(float timer, string key, mData value)    &#123;        Timer = timer;        Key = key;        Value = value;    &#125;&#125;[Serializable]private class mData&#123;    public enum Type    &#123; Int, Float, Bool, String, Vector3, Transform &#125;;    public string name;    public Type type;    public int intValue;    public float floatValue;    public bool boolValue;    public string stringValue;    public Vector3 vector3Value;    public Transform transformValue;    public mData(string key, int value)    &#123;        name = key;        type = Type.Int;        intValue = value;    &#125;    public mData(string key, float value)    &#123;        name = key;        type = Type.Float;        floatValue = value;    &#125;    public mData(string key, bool value)    &#123;        name = key;        type = Type.Bool;        boolValue = value;    &#125;    public mData(string key, string value)    &#123;        name = key;        type = Type.String;        stringValue = value;    &#125;    public mData(string key, Vector3 value)    &#123;        name = key;        type = Type.Vector3;        vector3Value = value;    &#125;    public mData(string key, Transform value)    &#123;        name = key;        type = Type.Transform;        transformValue = value;    &#125;&#125;[SerializeField] private SerializedDictionary&lt;string, mData&gt; mDatas = new SerializedDictionary&lt;string, mData&gt;();[SerializeField] private List&lt;BlackBoardTimer&gt; mTimers = new List&lt;BlackBoardTimer&gt;();// 设置数据public void SetValue(string key, bool value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, bool value, float expiredTime, bool expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, int value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, int value, float expiredTime, int expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, float value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, float value, float expiredTime, float expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    SetValue(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, string value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Vector3 value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Vector3 value, float expiredTime, Vector3 expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    mDatas[key] = new mData(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;public void SetValue(string key, Transform value)&#123;    mDatas[key] = new mData(key, value);&#125;public void SetValue(string key, Transform value, float expiredTime, Transform expiredValue)&#123;    foreach (var timer in mTimers)    &#123;        if (timer.Key == key) return;    &#125;    mDatas[key] = new mData(key, value);    mTimers.Add(new BlackBoardTimer(expiredTime, key, new mData(key, expiredValue)));&#125;// 访问数据public int GetInt(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Int)    &#123;        return value.intValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not an int.&quot;);&#125;public float GetFloat(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Float)    &#123;        return value.floatValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a float.&quot;);&#125;public bool GetBool(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Bool)    &#123;        return value.boolValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a bool.&quot;);&#125;public string GetString(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.String)    &#123;        return value.stringValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a string.&quot;);&#125;public Vector3 GetVector3(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Vector3)    &#123;        return value.vector3Value;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a Vector3.&quot;);&#125;public Transform GetTransform(string key)&#123;    if (mDatas.TryGetValue(key, out var value) &amp;&amp; value.type == mData.Type.Transform)    &#123;        return value.transformValue;    &#125;    throw new KeyNotFoundException($&quot;Key &#x27;&#123;key&#125;&#x27; not found or not a Transform.&quot;);&#125;private void Update()&#123;    for (int i = mTimers.Count - 1; i &gt;= 0; i--)    &#123;        var timer = mTimers[i];        timer.Timer -= Time.deltaTime / Time.timeScale;        if (timer.Timer &lt;= 0.0f)        &#123;            mDatas[timer.Key] = timer.Value;            mTimers.RemoveAt(i);        &#125;    &#125;&#125;\n参考内容\nhttps://www.cnblogs.com/KillerAery/p/10054558.html\n","categories":["Unity"]},{"title":"行为树","url":"/2025/12/30/BehaviorTree/","content":"完整代码\n一、Base部分\n\nBehaviorTree.cs\n\npublic class BehaviorTree&#123;    public bool HaveRoot =&gt; root != null;    private BtBehaviour root;//根节点    public BehaviorTree(BtBehaviour root)    &#123;        this.root = root;    &#125;    public void Tick()    &#123;        root.Tick();    &#125;    public void SetRoot(BtBehaviour root)    &#123;        this.root = root;    &#125;&#125;\n\nBtActionNode.cs\n\npublic class BtActionNode : BtBehaviour&#123;    protected EnemyController enemyController;    protected Func&lt;EStatus&gt; action;    public BtActionNode(EnemyController enemyController, Func&lt;EStatus&gt; action)    &#123;        this.enemyController = enemyController;        this.action = action;    &#125;    protected override EStatus OnUpdate()    &#123;        return action();    &#125;&#125;\n\nBtBehaviour.cs\n\npublic enum EStatus&#123;    //失败，成功，运行中，中断，无效    Failure, Success, Running, Aborted, Invalid&#125;public abstract class BtBehaviour&#123;    public bool IsTerminated =&gt; IsSuccess || IsFailure;//是否运行结束    public bool IsSuccess =&gt; status == EStatus.Success;//是否成功    public bool IsFailure =&gt; status == EStatus.Failure;//是否失败    public bool IsRunning =&gt; status == EStatus.Running;//是否正在运行    protected EStatus status;//运行状态    public BtBehaviour()    &#123;        status = EStatus.Invalid;    &#125;    protected virtual void OnInitialize()    &#123; &#125;    protected abstract EStatus OnUpdate();    protected virtual void OnTerminate()    &#123; &#125;    public EStatus Tick()    &#123;        if (!IsRunning)            OnInitialize();        status = OnUpdate();        if (!IsRunning)            OnTerminate();        return status;    &#125;    public virtual void AddChild(BtBehaviour child)    &#123; &#125;    public void Reset()    &#123;        status = EStatus.Invalid;    &#125;    public void Abort()    &#123;        OnTerminate();        status = EStatus.Aborted;    &#125;&#125;\n\nBtComposite.cs\n\npublic abstract class BtComposite : BtBehaviour&#123;    protected LinkedList&lt;BtBehaviour&gt; children;    public BtComposite()    &#123;        children = new LinkedList&lt;BtBehaviour&gt;();    &#125;    //移除指定子节点    public virtual void RemoveChild(BtBehaviour child)    &#123;        children.Remove(child);    &#125;    public void ClearChildren()//清空子节点列表    &#123;        children.Clear();    &#125;    public override void AddChild(BtBehaviour child)//添加子节点    &#123;        //默认是尾插入，如：0插入「1，2，3」中，就会变成「1，2，3，0」        children.AddLast(child);    &#125;&#125;\n\nBtDecorator.cs\n\npublic abstract class BtDecorator : BtBehaviour&#123;    protected BtBehaviour child;    public override void AddChild(BtBehaviour child)    &#123;        this.child = child;    &#125;&#125;\n二、Composite\n\nBtActiveSelector.cs\n\npublic class BtActiveSelector : BtSelector&#123;    protected override EStatus OnUpdate()    &#123;        var prev = currentChild;        base.OnInitialize();//注意这里，currentChild 会被赋值为 children.First        var res = base.OnUpdate();//按Selector的OnUpdate执行，顺序遍历选择        /*        只要不是遍历结束或可执行节点不变，都应该中断上一次执行的节点，无论优先是高是低。        因为如果当前优先级比之前的高，理应中断之前的；        而如果比之前的低，那就证明之前高优先级的行为无法继续了，        否则怎么会等到现在的低优先级的行为呢？所以也应中断它。        */        if (prev != null &amp;&amp; currentChild != prev)            prev.Value.Abort();        return res;    &#125;&#125;\n\nBtFilter.cs\n\n  public class BtFilter : BtSequence&#123;    public BtFilter(BtBehaviour condition)    &#123;        AddCondition(condition);    &#125;    public BtFilter(BtBehaviour condition1, BtBehaviour condition2)    &#123;        AddCondition(condition1);        AddCondition(condition2);    &#125;    public BtFilter()    &#123;    &#125;    public void AddCondition(BtBehaviour condition)//添加条件，就用头插入    &#123;        children.AddFirst(condition);    &#125;    public void AddAction(BtBehaviour action)//添加动作，就用尾插入    &#123;        children.AddLast(action);    &#125;&#125;\n\nBtMonitor.cs\n\npublic class BtMonitor : BtParallel&#123;    public BtMonitor(Policy mSuccessPolicy, Policy mFailurePolicy) : base(mSuccessPolicy, mFailurePolicy)    &#123;    &#125;    public void AddCondition(BtBehaviour condition)    &#123;        children.AddFirst(condition);    &#125;    public void AddAction(BtBehaviour action)    &#123;        children.AddLast(action);    &#125;&#125;\n\nBtParallel.cs\n\npublic class BtParallel : BtComposite&#123;    protected Policy mSuccessPolicy;//成功的标准    protected Policy mFailurePolicy;//失败的标准    /// &lt;summary&gt;    /// Parallel节点成功与失败的要求，是全部成功/失败，还是一个成功/失败    /// &lt;/summary&gt;    public enum Policy    &#123;        RequireOne, RequireAll,    &#125;    //构造函数初始化时，会要求给定成功和失败的标准    public BtParallel(Policy mSuccessPolicy, Policy mFailurePolicy)    &#123;        this.mSuccessPolicy = mSuccessPolicy;        this.mFailurePolicy = mFailurePolicy;    &#125;    protected override EStatus OnUpdate()    &#123;        int successCount = 0, failureCount = 0;//记录执行成功和执行失败的节点数        var b = children.First;//从第一个子节点开始        var size = children.Count;        for (int i = 0; i &lt; size; ++i)        &#123;            var bh = b.Value;            if (!bh.IsTerminated)//如果该子节点还没运行结束，就运行它                bh.Tick();            b = b.Next;            if (bh.IsSuccess)//该子节点运行结束后，如果运行成功了            &#123;                ++successCount;//成功执行的节点数+1                               //如果是「只要有一个」标准的话，那就可以返回结果了                if (mSuccessPolicy == Policy.RequireOne)                    return EStatus.Success;            &#125;            if (bh.IsFailure)//该子节点运行失败的情况同理            &#123;                ++failureCount;                if (mFailurePolicy == Policy.RequireOne)                    return EStatus.Failure;            &#125;        &#125;        //如果是「全都」标准的话，就需要比对当前成功/失败个数与总子节点数        if (mFailurePolicy == Policy.RequireAll &amp;&amp; failureCount == size)            return EStatus.Failure;        if (mSuccessPolicy == Policy.RequireAll &amp;&amp; successCount == size)            return EStatus.Success;        return EStatus.Running;    &#125;    //结束函数，只要简单地把所有子节点设为「中断」就可以了    protected override void OnTerminate()    &#123;        foreach (var b in children)        &#123;            if (b.IsRunning)                b.Abort();        &#125;    &#125;&#125;\n\nBtSelector.cs\n\npublic class BtSelector : BtSequence&#123;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            var s = currentChild.Value.Tick();            if (s != EStatus.Failure)                return s;            currentChild = currentChild.Next;            if (currentChild == null)                return EStatus.Failure;        &#125;    &#125;&#125;\n6.BtSequence.cs\nusing System.Collections.Generic;public class BtSequence : BtComposite&#123;    protected LinkedListNode&lt;BtBehaviour&gt; currentChild;//当前运行的子节点    protected override void OnInitialize()    &#123;        currentChild = children.First;//从第一个子节点开始    &#125;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            var s = currentChild.Value.Tick();//记录子节点运行返回的结果状态            /*            如果子节点运行，还没有成功，就直接返回该结果。            是「运行中」那就表明本节点也是运行中，有记录当前节点，下次还会继续执行；            是「失败」就表明本节点也运行失败了，下次会再经历OnInitialize，从头开始。            */            if (s != EStatus.Success)                return s;            //如果运行成功，就换到下一个子节点            currentChild = currentChild.Next;            //如果全都成功运行完了，就返回「成功」            if (currentChild == null)                return EStatus.Success;        &#125;    &#125;&#125;## 三、Decorator1. BtInverter.cs```C#public class BtInverter : BtDecorator&#123;    protected override EStatus OnUpdate()    &#123;        child.Tick();        if (child.IsFailure)            return EStatus.Success;        if (child.IsSuccess)            return EStatus.Failure;        return EStatus.Running;    &#125;&#125;\n\nBtRepeat.cs\n\npublic class BtRepeat : BtDecorator&#123;    private int conunter;//当前重复次数    private int limit;//重复限度    public BtRepeat(int limit)    &#123;        this.limit = limit;    &#125;    protected override void OnInitialize()    &#123;        conunter = 0;//进入时，将次数清零    &#125;    protected override EStatus OnUpdate()    &#123;        while (true)        &#123;            child.Tick();            if (child.IsRunning)                return EStatus.Running;            if (child.IsFailure)                return EStatus.Failure;            //子节点执行成功，就增加一次计算，达到设定限度才返回成功            if (++conunter &gt;= limit)                return EStatus.Success;        &#125;    &#125;&#125;\n三、BehaviorTreeBuilder.cs(主要使用这个类来构建和控制行为属)\npublic class BehaviorTreeBuilder&#123;    private readonly Stack&lt;BtBehaviour&gt; nodeStack;//构建树结构用的栈    private readonly BehaviorTree bhTree;//构建的树    public BehaviorTreeBuilder()    &#123;        bhTree = new BehaviorTree(null);//构造一个没有根的树        nodeStack = new Stack&lt;BtBehaviour&gt;();//初始化构建栈    &#125;    public BehaviorTreeBuilder AddBehavior(BtBehaviour behavior)    &#123;        if (bhTree.HaveRoot)//有根节点时，加入构建栈        &#123;            nodeStack.Peek().AddChild(behavior);        &#125;        else //当树没根时，新增得节点视为根节点        &#123;            bhTree.SetRoot(behavior);        &#125;        //只有组合节点和修饰节点需要进构建堆        if (behavior is BtComposite || behavior is BtDecorator)        &#123;            nodeStack.Push(behavior);        &#125;        return this;    &#125;    public void TreeTick()    &#123;        bhTree.Tick();    &#125;    public BehaviorTreeBuilder Back()    &#123;        nodeStack.Pop();        return this;    &#125;    public BehaviorTree End()    &#123;        nodeStack.Clear();        return bhTree;    &#125;    //---------包装各节点---------    public BehaviorTreeBuilder Sequence()    &#123;        var tp = new BtSequence();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Seletctor()    &#123;        var tp = new BtSelector();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Filter()    &#123;        var tp = new BtFilter();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Parallel(BtParallel.Policy success, BtParallel.Policy failure)    &#123;        var tp = new BtParallel(success, failure);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Monitor(BtParallel.Policy success, BtParallel.Policy failure)    &#123;        var tp = new BtMonitor(success, failure);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder ActiveSelector()    &#123;        var tp = new BtActiveSelector();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Repeat(int limit)    &#123;        var tp = new BtRepeat(limit);        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder Inverter()    &#123;        var tp = new BtInverter();        AddBehavior(tp);        return this;    &#125;    public BehaviorTreeBuilder DebugNode(string word)    &#123;        var node = new DebugNode(word);        AddBehavior(node);        return this;    &#125;    public void OnDisable()    &#123;        nodeStack.Clear();    &#125;&#125;\n构建行为树和行为树的使用\nprivate void Awake()&#123;    builder = new BehaviorTreeBuilder();    //行为树    BtBehaviour IsFindPlayerCondition = new BtActionNode(this, IsFindPlayer);    BtBehaviour EnterAtkDisCondition = new BtActionNode(this, EnterAtkDis);    BtBehaviour EnterDashDisCondition = new BtActionNode(this, EnterDashDis);    BtBehaviour EnterLAtkDisCondition = new BtActionNode(this, EnterLtkDis);    BtBehaviour EnterObeservehDisCondition = new BtActionNode(this, EnterObeservehDis);    BtBehaviour CanAttackCondition = new BtActionNode(this, CanAttack);    BtBehaviour CanDodgeCondition = new BtActionNode(this, CanDodge);    BtBehaviour CanSkillCondition = new BtActionNode(this, CanSkill);    BtBehaviour CanSkillACondition = new BtActionNode(this, CanSkillA);    BtBehaviour CanSkillBCondition = new BtActionNode(this, CanSkillB);    BtBehaviour BeAttackCondition = new BtActionNode(this, IsBeAttacked);    BtBehaviour NearPlayerAciton = new BtActionNode(this, NearPlayer);    BtBehaviour AttackPlayerAction = new BtActionNode(this, AttackPlayer);    BtBehaviour RollBackwardsAction = new BtActionNode(this, RollBackwards);    BtBehaviour ObservePlayerAction = new BtActionNode(this, ObservePlayer);    BtBehaviour BackOffAction = new BtActionNode(this, BackOff);    BtBehaviour DashSkillAction = new BtActionNode(this, UseDashSkill);    BtBehaviour CloseSkillAction = new BtActionNode(this, UseCloseSkill);    BtBehaviour IdleAction = new BtActionNode(this, Idle);    BtBehaviour BeAttackAcion = new BtActionNode(this, BeAttacked);    builder        .Seletctor()//1            .Sequence()                .AddBehavior(BeAttackCondition)                .AddBehavior(BeAttackAcion)            .Back()            .Sequence()//11                .AddBehavior(IsFindPlayerCondition)//111                    .Seletctor()//112                        .Sequence()//1121                            .Sequence()                                .Inverter()                                .AddBehavior(EnterAtkDisCondition)                                .Back()                            .Back()                            .Seletctor()                                .Sequence()//1121121                                    .AddBehavior(EnterDashDisCondition)                                    .AddBehavior(CanSkillCondition)                                    .AddBehavior(CanSkillACondition)                                    .AddBehavior(DashSkillAction)                                .Back()                                .Seletctor()                                    .Seletctor()                                        .Sequence()                                            .AddBehavior(CanAttackCondition)                                            .AddBehavior(NearPlayerAciton)                                        .Back()                                        .Sequence()                                            .AddBehavior(EnterObeservehDisCondition)                                            .AddBehavior(ObservePlayerAction)                                        .Back()                                    .Back()                                .Back()                            .Back()                        .Back()                        .Sequence()//1122                            .AddBehavior(EnterAtkDisCondition)                                .Seletctor()                                    .Sequence()//是否能够攻击                                        .AddBehavior(CanAttackCondition)                                        .AddBehavior(AttackPlayerAction)                                        .Back()                                    .Seletctor()                                        .Sequence()//能否使用近战技能                                            .AddBehavior(CanSkillCondition)                                            .AddBehavior(CanSkillBCondition)                                            .AddBehavior(CloseSkillAction)                                        .Back()                                        .Seletctor()                                            .Sequence()//翻滚                                                .AddBehavior(CanDodgeCondition)                                                .AddBehavior(RollBackwardsAction)                                            .Back()                                            .AddBehavior(BackOffAction)                                        .Back()                                    .Back()                                .Back()                        .Back()//1122                    .Back()//112            .Back()//11            .Sequence()//12                .Sequence()                    .Inverter()                    .AddBehavior(IsFindPlayerCondition)                    .Back()                .Back()                .AddBehavior(IdleAction)            .Back()//12        .Back()//1    .End();&#125;\n参考内容\nhttps://developer.unity.cn/projects/6569d98aedbc2a0a165f740e\n","categories":["Unity"]},{"title":"摄像机控制脚本","url":"/2025/12/30/CameraController/","content":"简单介绍\n拥有调节灵敏度、检测碰撞、锁定敌人的功能。\n完整代码\nusing UnityEngine;public class CameraMoveController : MonoBehaviour&#123;    private PlayerInputSystem _playerInput;    [SerializeField] private Transform LookAttarGet;    private Transform playerCamera;    [Range(0.1f, 1.0f), SerializeField, Header(&quot;鼠标灵敏度&quot;)] public float mouseInputSpeed;    [SerializeField, Header(&quot;相机对于玩家&quot;)] private float normalRadius;    [SerializeField] private float currentRadius;    private Vector2 ClmpCameraRang = new Vector2(-85f, 70f);    [SerializeField, Header(&quot;锁敌&quot;)] private bool isLockOn = false;    private Transform currentEnemy;    private float escapeDistance;    [SerializeField, Header(&quot;滑轮&quot;)] private float zoomSpeed = 1f;    [SerializeField] private Vector2 minMaxZoom = new Vector2(4f, 7f);    private float zoom = 1f;    [SerializeField, Header(&quot;相机碰撞&quot;)] public LayerMask collisionLayer;    private Vector3 rotationSmoothVelocity;    private float yaw;    private float pitch;    private void Start()    &#123;        normalRadius = 5f;        playerCamera = Camera.main.transform;        _playerInput = LookAttarGet.transform.root.GetComponent&lt;PlayerInputSystem&gt;();    &#125;    private void ControllerCamera()    &#123;        //相机缩放        if (zoom != 0)        &#123;            normalRadius -= zoom * normalRadius;            normalRadius = Mathf.Clamp(normalRadius, minMaxZoom.x, minMaxZoom.y);        &#125;        //相机旋转        if (!isLockOn)        &#123;            Quaternion targetRotation = Quaternion.Euler(new Vector3(pitch, yaw));            transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, 0.4f);            if (pitch &lt; -8f)            &#123;                currentRadius = Mathf.Lerp(currentRadius, normalRadius / 2f, 0.1f);            &#125;            else            &#123;                currentRadius = Mathf.Lerp(currentRadius, normalRadius, 0.1f);            &#125;        &#125;        //相机碰撞检测        Vector3 fanlePos = Vector3.zero;        if (Physics.Linecast(LookAttarGet.position + Vector3.up, playerCamera.position + (-playerCamera.forward.normalized), out var hit, collisionLayer))        &#123;            float currentDistance = Vector3.Distance(hit.point, LookAttarGet.position);            //Debug.Log(&quot;发生碰撞 &quot; + currentDistance);            if (currentDistance &lt;= minMaxZoom.y)            &#123;                currentRadius = currentDistance * 0.95f;            &#125;        &#125;        //相机跟踪        fanlePos = LookAttarGet.position - transform.forward * currentRadius;        transform.position = Vector3.Lerp(transform.position, fanlePos, 0.8f);    &#125;    private void GetCameraControllerInput()    &#123;        if (isLockOn) return;        yaw += _playerInput.cameraLook.x * mouseInputSpeed;        pitch -= _playerInput.cameraLook.y * mouseInputSpeed;        pitch = Mathf.Clamp(pitch, ClmpCameraRang.x, ClmpCameraRang.y);        zoom = Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * zoomSpeed;    &#125;    private void CameraLockOnTarget()    &#123;        if (!isLockOn) return;        Vector3 EnemyDir = ((currentEnemy.position + currentEnemy.transform.up * 0.3f) - transform.position).normalized;        Quaternion lookRotation = Quaternion.LookRotation(EnemyDir.normalized);        transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, 0.2f);    &#125;    private void LockEnemy()    &#123;        if (_playerInput.playerLockEnemy)        &#123;            Debug.Log(&quot;锁定敌人&quot;);            if (currentEnemy == null)            &#123;                Vector3 tempPosition = LookAttarGet.transform.position;                Vector3 center = tempPosition + new Vector3(0, 1.0f, 0) + transform.forward * 5.0f;                Collider[] col = Physics.OverlapBox(center, new Vector3(10f, 5f, 10f), transform.rotation, LayerMask.GetMask(&quot;Enemy&quot;));                if (col.Length != 0)                &#123;                    currentEnemy = col[0].transform;                    isLockOn = true;                &#125;            &#125;            else            &#123;                UnLock();            &#125;        &#125;        //距离太远，自动解除锁定        if (currentEnemy != null)        &#123;            if (Vector3.Distance(LookAttarGet.position, currentEnemy.position) &gt; escapeDistance)            &#123;                UnLock();            &#125;        &#125;    &#125;    private void UnLock()    &#123;        currentEnemy = null;        isLockOn = false;    &#125;    private void OnDrawGizmos()    &#123;        //Vector3 tempPosition = LookAttarGet.transform.position;        //Vector3 center = tempPosition + new Vector3(0, 1.0f, 0) + transform.forward * 5.0f;        //Gizmos.DrawCube(center, new Vector3(10f, 5f, 10f));    &#125;    private void Update()    &#123;        GetCameraControllerInput();//计算        LockEnemy();//选择锁定的敌人    &#125;    private void LateUpdate()    &#123;        ControllerCamera();//移动摄像头        CameraLockOnTarget();//锁定敌人    &#125;&#125;\n","categories":["Unity"]},{"title":"Unity面试可能遇到的问题","url":"/2026/01/04/InterviewUnityQuestions/","content":"MIT许可证的主要要求是：\n在软件的分发副本中必须包含原始版权声明和许可声明。它允许自由使用、修改、分发，包括用于商业用途，且不要求开源修改后的代码。\n什么是“对象池”？在Unity中实现一个简单的对象池需要包含哪些核心功能？\n对象池是一种性能优化设计模式，通过预先创建并复用对象实例，避免运行时频繁的Instantiate和Destroy带来的内存分配与GC开销。\n核心功能包括：\n初始化：预生成一定数量的对象，设为非激活状态。\n获取对象：从池中返回一个可用（非激活）对象，并激活它；若无可用对象，则动态扩容（新建）。\n回收对象：将使用完毕的对象设为非激活，返回到池中备用。\n可选的清理功能：在场景切换或结束时，销毁池中所有对象。\nShadow Pass在视野外会被渲染吗？\n不会，阴影渲染（Shadow Pass）通常基于光源的视锥体和阴影距离设置。若物体不在光源的“可见”范围内或超出阴影距离，则不会渲染其阴影，以节省性能。\n动态链接库（DLL）在程序运行时被加载到内存中，可以被多个程序共享使用\n[InitializeOnLoad] 是编辑器特性，仅在Unity编辑器启动或重新编译脚本后执行，打包后不会执行\nPhysics.Raycast 的结果与 Time.timeScale 的关系\nPhysics.Raycast 属于物理系统，其查询基于物理状态，不受 Time.timeScale 影响\nDevelopment Build 和 Release Build 的代码裁剪行为是完全一致的吗？\n不是，Development Build 默认禁用或减少代码裁剪以便调试，而 Release Build 会进行激进的代码裁剪以减小包体\nRoot Motion 在 FixedUpdate 下会更精确？\n是的，root Motion（根运动）通常与动画和物理交互，在 FixedUpdate 中执行能与物理引擎的固定时间步长更好同步，避免因帧率波动导致位移不精确或“抖动”。\n简述 Unity 中 MonoBehaviour 脚本的生命周期（主要方法执行顺序）\n\n初始化阶段：Awake() → OnEnable() → Start()\nAwake()：脚本实例被创建时调用一次（即使脚本未启用）。\nOnEnable()：每当对象变为激活/启用状态时调用。\nStart()：在第一次 Update 前，且脚本启用时调用一次。\n更新循环阶段（每帧）：FixedUpdate() → Update() → LateUpdate()\nFixedUpdate()：按固定时间步长调用（默认0.02s），用于物理计算。\nUpdate()：每帧调用一次，主要的游戏逻辑入口。\nLateUpdate()：在 Update 和所有动画计算之后调用，常用于摄像机跟随。\n渲染与 GUI 阶段：\nOnGUI ()：处理 GUI 绘制和事件（如按钮点击），调用次数不固定；\nOnRenderObject ()：相机渲染完所有物体后调用，适合自定义渲染逻辑。\n结束/销毁阶段：\nOnDisable()：当对象变为非激活/禁用状态时调用。\nOnDestroy()：对象被销毁前调用。\n\nOnRenderObject()方法的作用\n在场景渲染完成后被调用，可以用于自定义渲染\n请尽可能多地列举在 Unity 中索引或引用 GameObject 的不同方式\nGameObject.Find(string name)：通过名称全局查找（性能差）。\nTransform.Find(string path)：在特定父物体下按路径查找子物体。\nGameObject.FindWithTag() / GameObject.FindGameObjectsWithTag()：通过标签查找。\nGameObject.FindObjectOfType() / FindObjectsOfType()：通过组件类型查找。\nGetComponent() / GetComponentInChildren() / GetComponentInParent()：获取组件，间接引用其挂载的GameObject。\n序列化字段：在Inspector面板中拖拽赋值（public GameObject target; 或 [SerializeField] private GameObject target;）。\n资源加载：通过 Resources.Load(path) 或 AssetBundle/Addressables 加载预制体实例化。\n父子层级遍历：通过 transform.GetChild(index) 访问子物体。\n发送消息/Broadcast：使用 SendMessage 或事件系统间接通信。\n请写出一种可以完整构造 Mesh 的数据结构\npublic class MeshData &#123;    public Vector3[] vertices;      // 顶点位置    public int[] triangles;         // 三角形索引（每3个一组）    public Vector2[] uv;            // 纹理坐标（可选）    public Vector3[] normals;       // 法线（可选，可自动计算）    public Color[] colors;          // 顶点颜色（可选）&#125;\n把struct改成class，bug消失了你怎么看？\nstruct在作为参数传递或赋值时是拷贝，对副本的修改不影响原始数据。改为class后，传递的是引用，修改会生效。\nUnity 有几种坐标系\n世界坐标系（World Space）：场景全局坐标系，物体的绝对位置；\n局部坐标系（Local Space）：物体自身坐标系，子物体相对于父物体的位置；\n屏幕坐标系（Screen Space）：以像素为单位，原点在左下角（UI 系统常用）；\n视口坐标系（Viewport Space）：归一化坐标系（0-1 范围），适配不同分辨率。\n你怎么管理游戏内存的\n资源管理：AB 包（AssetBundle）分包策略（按场景 / 资源类型分包）、异步加载（避免卡顿）、无用资源及时 Unload；\n对象管理：对象池（Object Pool）复用频繁创建的物体（如子弹、敌人），减少 GC；\n代码层面：减少装箱拆箱、避免频繁创建临时对象、合理使用值类型。\nUnity渲染管线\n\n内置渲染管线（Built-in Render Pipeline）\nUnity 传统的默认渲染管线，属于固定功能管线（早期）+ 有限可编程管线\n优点：上手快、配置简单，无需额外安装包，适合新手和快速原型开发；对旧项目兼容性好。\n缺点：可定制化程度低，无法灵活调整渲染流程；优化空间有限，不支持光线追踪、体积雾等现代渲染特性；多平台适配时性能难以精细化控制。\n适用场景：小型独立游戏、快速 Demo 验证、老项目维护。\n通用渲染管线（Universal Render Pipeline，URP）\n定位：Unity 主推的 轻量化、跨平台可编程渲染管线（SRP），前身是 LWRP（轻量级渲染管线）。\n核心特点\n优点：可高度定制渲染路径（支持前向渲染、延迟渲染），能根据项目需求开关特性；性能可控，针对移动端、低配 PC 做了深度优化；支持 SRP 合批、光照探针、阴影分级等实用功能；体积小，接入成本低。\n缺点：不支持光线追踪等高端特效，渲染上限低于 HDRP。\n适用场景：移动端手游、2D 游戏、中小型 3D 游戏（面试高频，必须结合项目）\n高清渲染管线（High Definition Render Pipeline，HDRP）\n面向 主机、高性能 PC 的高端可编程渲染管线，主打次世代视觉效果。\n核心特点\n优点：支持光线追踪、体积雾、屏幕空间反射（SSR）、高动态范围（HDR）光照、次表面散射等 3A 级特效；渲染质量极致，光影表现逼真；可定制化程度最高，能满足顶级视觉需求。\n缺点：性能消耗大，对硬件要求高；不适合移动端；接入和调试成本高。\n适用场景：3A 级别主机 / PC 游戏、影视级演示项目、视觉特效（VFX）项目。\n\n\n","categories":["Unity"]},{"title":"数据持久化-PlayerPrefs","url":"/2026/01/04/DataPersistence/","content":"一、什么是数据持久化\n数据持久化是将内存中的数据模型转换为存储模型，以及将存储模型转换为内存中的数据模型的统称。\n说人话：将游戏数据存储到硬盘，硬盘中数据读取到游戏中，也就是传统意义上的存盘。\n二、PlayerPrefs是什么\nPlayerPrefs是Unity提供的可以用于存储玩家数据的公共类。\n三、PlayerPrefs存储相关\nPlayerPrefs的数据存储，类似于键值对存储，一个键对应一个值。\n键：string\n值：int float string\n//直接调用Set相关方法，只会把数据存到内存里//当游戏结束时，Unity会自动把数据存到硬盘里PlayerPrefs.SetInt(&quot;myAge&quot;,18);PlayerPrefs.SetFloat(&quot;myHight&quot;,177f);PlayerPrefs.SetString(&quot;myName&quot;,&quot;xxx&quot;);//如果游戏不是正常结束，而是崩溃，数据不会存到硬盘里的//因此我们可以调用该方法，将数据存储到硬盘中PlayerPrefs.Save();//使用不同类型，用同一键名，就会覆盖PlayerPrefs.SetFloat(&quot;myAge&quot;,20f);\n四、PlayerPrefs读取相关\n运行时，只要使用了set，及时没有save，也可以读取信息。\nint age = GetFloat(&quot;myAge&quot;);//如果找不到myAge对应的值，就会返回函数的第二个参数，默认值age = PlayerPrefs.GetInt(&quot;myAge&quot;,100);//判断数据是否存在if(PlayerPrefs.HasKey(&quot;myName&quot;))&#123;&#125;\n五、PlayerPrefs删除相关\n//删除指定键值对PlayerPrefs.DeleteKey(&quot;myAge&quot;);//删除所有存储信息PlayerPrefs.DeleteAll();**\n六、PlayerPrefs存储的数据在哪里\nWindows：计算机\\HKEY_CURRENT_USER\\SOFTWARE\\Unity\\UnityEditor[公司名][产品名]\nAndroid：/data/data/包名/shared_prefs/pkg-name.xml\nIOS：/Library/Preferences/[应用ID].plist\n七、PlayerPrefs数据唯一性\nPlayerPrefs数据唯一性是由key决定的，不同的key决定了不同的数据。\n同一项目中，如果不同数据key相同，就会造成数据丢失。\n要保证数据不丢失就必须保证key唯一的原则。\n","categories":["Unity"]},{"title":"如何建立一个博客","url":"/2025/12/29/HowBuildBlog/","content":"一、安装Hexo并初始化博客\n1.安装Hexo\n在安装Hexo之前，需要安装Git，Node.js，具体过程可以直接看https://hexo.io/zh-cn/docs/\n然后在终端中执行命令\nnpm install -g hexo-cli\n2.初始化博客\n\n新建一个文件夹作为博客根目录（我的是D:!myths\\blog）\n在终端中输入命令进入根目录\ncd D:\\!myths\\blog\n执行初始化命令\nnpx hexo init\n安装依赖包\nnpm install\n做完上述步骤后，D:!myths\\blog文件夹中出现以下文件夹：\n\n\n_config.yml：Hexo 全局配置文件（核心，用于配置博客标题、主题、部署信息等）；\nsource/：存放博客原始内容，_posts/ 文件夹用于存放所有博客文章（Markdown 格式）；\nthemes/：存放博客主题，默认主题为 landscape；\npublic/：Hexo 生成的静态网页文件（部署时需上传该目录内容）；\nscaffolds/：文章模板文件，新建文章时会基于模板生成。\n3.本地预览博客\n\n生成静态网页文件\nnpx hexo generate\n或者\nnpx hexo g\n启动本地服务器\nnpx hexo server\n或者\nnpx hexo s\n打开浏览器，访问http://localhost:4000\n\n4.创作博客文章\n\n新建博客文章\nnpx hexo new &quot;blog name&quot;\n使用命令后，文章会生成在source/_posts/目录下\n编辑博客文章\n用Markdown编辑器打开_posts下的md文件\n编辑后执行命令npx hexo clean &amp;&amp; npx hexo generate &amp;&amp; npx hexo deploy，博客里面的内容就会改变\n\n二、在github上配置SSH\n\n打开git bash\n\n\n\n生成秘钥对\nssh-keygen -t rsa -C &quot;你的github邮箱@xxx.com&quot;\n一路回车即可\n查看公钥内容，复制到剪切板上\ncat ~/.ssh/id_rsa.pub\n打开github，新建一个仓库，仓库名为你的名字.github.io\n在上方导航栏点开仓库的Setting，在左侧导航栏找到Deploy keys\n\n\n\n在Deploy Keys界面点击Add deploy key按钮\n\n\n\nTitle随便填，将之前复制的公钥内容粘贴到Key里面，然后点击Add key\n\n\n\n在git bash中输入命令ssh -T git@github.com，如果出现successfully的信息，就代表成功了。\n\n\n三、部署Hexo博客到Github Pages上\n\n记录仓库的SSH地址\n如果上述步骤都没问题的话，那么SSH地址应该是git@github.com:你的github的名字/你的github的名字.github.io.git\n安装Hexo部署插件\n在之前建立的博客根目录中在终端中执行命令\nnpm install hexo-deployer-git\n编辑部署信息\n打开根目录中的_config.yml文件，找到deploy配置项\n\n\n在repo填上仓库的SSH地址，要注意冒号后面有个空格\n\n部署博客到github\n在终端执行命令：\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n之后访问https://你的用户名.github.io，即可公网访问你的博客\n\n四、常用命令\n新建文章：npx hexo new &quot;文章名&quot;\n生成静态文件：npx hexo generate\n启动服务器：npx hexo server\n部署网站：npx hexo deploy\n清除缓存文件：npx hexo clean\n参考资料\nhttps://blog.csdn.net/qq_37294163/article/details/103099424\nhttps://blog.csdn.net/weixin_73527660/article/details/156200825\n","categories":["其他"]},{"title":"对象池","url":"/2026/01/04/ObjectPool/","content":"ObjectPool.cs\npublic Queue&lt;GameObject&gt; poolQueue = new();public int maxNum = 100;private string prefabPath;private GameObject prefab;public ObjectPool(string prefabsPath)&#123;    this.prefabPath = prefabsPath;&#125;public void ReturnObject(GameObject obj)&#123;    if(poolQueue.Count &gt; maxNum)&#123;        GameObject.Destroy(obj);        return;    &#125;    poolQueue.Enqueue(obj);&#125;public GameObject GetObject()&#123;    if(poolQueue.Count &gt; 0)&#123;        return poolQueue.Dequeue();    &#125;    else&#123;        if(prefab == null)&#123;            prefab = Resources.Load(prefabPath) as GameObject;        &#125;        return GameObject.Instantiate(prefab);    &#125;&#125;\nGameManager.cs\nusing UnityEngine;class GameManager: MonoBehaviour&#123;    public static ObjectPool bulletOP = new(&quot;Prefab/Bullet&quot;);    public static GameObject GetBullet()&#123;        GameObject bullet = bulletOP.GetObjcet();        bullet.SetActive(true);        return bullet;    &#125;    public static void ReturnBullet(GameObject bullet)&#123;        //重置子弹状态        bullet.GetComponent&lt;Bullet&gt;().Reset();        bulletOP.ReturnObject(bullet);    &#125;&#125; ","categories":["Unity"]},{"title":"单例模式的实现","url":"/2025/12/30/SingletonMode/","content":"完整代码\nusing UnityEngine;public class ClassName : MonoBehaviour&#123;    private static ClassName instance;    public static ClassName Instance    &#123;        get        &#123;            if (instance == null)            &#123;                GameObject obj = new GameObject(&quot;ClassName&quot;);                instance = obj.AddComponent&lt;ClassName&gt;();            &#125;            return instance;        &#125;    &#125;    private void OnDestroy()    &#123;        instance = null;    &#125;&#125;\n如果需要普通类的单例模式，只需要将简单修改即可\npublic class ClassName&#123;    private static ClassName instance;    public static ClassName Instance    &#123;        get        &#123;            if (instance == null)            &#123;                instance =  new ClassName();            &#125;            return instance;        &#125;    &#125;&#125;\n在以上代码的基础上，可以进行一些进阶处理\npublic class Singleton&lt;T&gt; where T : class, new()&#123;    private static T m_instance;    private static readonly object syslock = new object();    public static T Instance    &#123;        get        &#123;            if (m_instance == null)            &#123;                lock (syslock)                &#123;                    if (m_instance == null)                    &#123;                        m_instance = new T();                    &#125;                &#125;            &#125;            return m_instance;        &#125;    &#125;&#125;\n","categories":["Unity"]},{"title":"UI系统","url":"/2025/12/30/UISystem/","content":"完整代码\n\nBasePanel.cs\n\nusing UnityEngine;public class BasePanel : MonoBehaviour&#123;    protected bool isRemove = false;    protected new string name;    public virtual void OpenPanel(string name)    &#123;        this.name = name;        gameObject.SetActive(true);    &#125;    public virtual void ClosePanel()    &#123;        isRemove = true;        gameObject.SetActive(false);        Destroy(gameObject);        if (UIManager.Instance.panelDict.ContainsKey(name))        &#123;            UIManager.Instance.panelDict.Remove(name);        &#125;    &#125;&#125;\n\nUIManager.cs\n\npublic class UIConst&#123;    public const string MainMenuPanel = &quot;MainMenuPanel&quot;;    public const string SettingPanel = &quot;SettingPanel&quot;;    public const string PlayerStatePanel = &quot;PlayerStateBar&quot;;    public const string EnemyStatePanel = &quot;EnemyStateBar&quot;;    public const string DialoguePanel = &quot;DialoguePanel&quot;;&#125;public class UIManager&#123;    private static UIManager _instance;    private Transform _uiRoot;    private Dictionary&lt;string, string&gt; pathDict;    private Dictionary&lt;string, GameObject&gt; prefabsDict;    public Dictionary&lt;string, BasePanel&gt; panelDict;    public static UIManager Instance    &#123;        get        &#123;            if (_instance == null)            &#123;                _instance = new UIManager();            &#125;            return _instance;        &#125;    &#125;    public Transform UIRoot    &#123;        get        &#123;            if (_uiRoot == null)            &#123;                if (GameObject.Find(&quot;Canvas&quot;))                &#123;                    _uiRoot = GameObject.Find(&quot;Canvas&quot;).transform;                &#125;                else                &#123;                    _uiRoot = new GameObject(&quot;Canvas&quot;).transform;                &#125;            &#125;            return _uiRoot;        &#125;    &#125;    private UIManager()    &#123;        InitDicts();    &#125;    private void InitDicts()    &#123;        prefabsDict = new Dictionary&lt;string, GameObject&gt;();        panelDict = new Dictionary&lt;string, BasePanel&gt;();        pathDict = new Dictionary&lt;string, string&gt;()        &#123;            &#123; UIConst.MainMenuPanel ,UIConst.MainMenuPanel&#125;,            &#123; UIConst.SettingPanel ,UIConst.SettingPanel&#125;,            &#123; UIConst.PlayerStatePanel ,UIConst.PlayerStatePanel&#125;,            &#123; UIConst.EnemyStatePanel ,UIConst.EnemyStatePanel&#125;,            &#123; UIConst.DialoguePanel ,UIConst.DialoguePanel&#125;        &#125;;    &#125;    public BasePanel OpenPanel(string name)    &#123;        BasePanel panel = null;        if (panelDict.TryGetValue(name, out panel))        &#123;            Debug.Log(&quot;界面已打开&quot;);            return null;        &#125;        string path = &quot;&quot;;        if (!pathDict.TryGetValue(name, out path))        &#123;            Debug.Log(&quot;界面名称错误，或未配置路径 &quot; + name);            return null;        &#125;        GameObject panelPrefab = null;        if (!prefabsDict.TryGetValue(name, out panelPrefab))        &#123;            string realPath = &quot;Prefabs/UI/&quot; + path;//需在Resources/Prefabs/UI文件夹下放置UI的预制体            panelPrefab = Resources.Load&lt;GameObject&gt;(realPath) as GameObject;            prefabsDict.Add(name, panelPrefab);        &#125;        GameObject panelObject = GameObject.Instantiate(panelPrefab, UIRoot, false);        panelObject.transform.position = UIRoot.position;        panel = panelObject.GetComponent&lt;BasePanel&gt;();        panelDict.Add(name, panel);        panel.OpenPanel(name);        return panel;    &#125;    public bool ClosePanel(string name)    &#123;        BasePanel panel = null;        if (!panelDict.TryGetValue(name, out panel))        &#123;            Debug.Log(&quot;界面未打开&quot; + name);            return false;        &#125;        panel.ClosePanel();        return true;    &#125;&#125;","categories":["Unity"]},{"title":"大纲示例","url":"/2026/01/02/OutlineExample/","content":"样例参考1\n一句话故事：拥有死亡回溯能力的公爵之子罗恩，因为不论重生几次，都会因灭世魔女引发的战争在二十岁时死去，于是为求自保，罗恩决意拯救魔女，阻止其灭世。\n简介\n第一百次被魔女斩杀后，罗恩终于发现，想活过二十岁生日，得先教会灭世魔女谈恋爱。\n拥有死亡回溯能力的他，每让命定之女心情变好，就能获得一次存档重生的机会，本以为从此掌握主角剧本，幸福无限，可当他无数次轮回仍败倒魔女裙下，罗恩才惊觉无限读档的恐怖之处。\n被病娇女仆长关在密室，整整七个轮回受折磨至死；\n被傲娇皇女吃醋逼婚，光是逃离她的闺房就花了不下五条命；\n更有邪恶的帝国公主，将罗恩视作换装玩偶，数十次的重生都难以挣脱她的梦魇。\n但这一切，都比不过图书馆里那个怯生生的黑发少女。\n当罗恩发现她就是灭世魔女的人间体，迄今为止积攒的存档都化为了乌有。\n“你是说，必须让这个三无少女相信爱情，世界才不会爆炸？”\n“而且这个三无魔女的本体，被人类关在异次元牢狱，发誓要毁灭世界复仇？”\n“魔女大人……你要不直接杀了我算了，我只想安静地摆烂啊！”\n……\n《魔女日记》节选\n【遇见一个奇怪的人。】\n【光是接近我就会染上不幸，可他总是遍体鳞伤地来找我聊天。】\n【从没有人对我这么友善。】\n【为了见我，他冒着必死的风险，我问他值不值得，他却只是傻笑。】\n【书上说，如果一个人愿意为你而死，那一定是因为爱…】\n【他爱我吗？】\n剧情梗概\n主线目标是主角重生异界，获得死亡回溯的金手指，发现自己二十岁那年，必被魔女灭世牵连，为了改变必死结局，主角活用多次轮回后积攒的经验，先和身边的女角色搞好关系，防止其影响自己讨好魔女，将病娇女仆、傲娇皇女、帝国公主等角色一碗水端平，却不料轮回中产生了变数，重女们的反应有时和变得和前世不一样，令主角不得不处理好和各个重女之间的关系，使用金手指化解危机的同时，尝试攻略魔女。\n作品爽点&amp;亮点\n主角利用信息差，运筹帷幄的人设。\n死亡回溯的金手指，凸显主角先知先觉的特殊性，为作品中的危机兜底。\n和魔女的错位攻略，主角只是为了自保，才决定帮助魔女，却被对方以为主角是真的爱自己，倒追形成反差。\n人设\n姓名：罗恩（男主）\n性格：心思缜密，面对各个女主时表面弱势，实则靠信息差在战略上掌握主动权\n主要经历：本是地球一名普通学生，意外重生西幻世界获得死亡回溯金手指，能够通过增加特定女角色的友善度（不是单纯的好感度，而是类似情绪价值，例如，主角安慰女主，女主心情好了一些，可以获得系统代币，送个小礼物，也可以获得系统代币，主角并不认为自己的行为能攻略对方，单纯想处好关系做朋友，但对方却逐渐爱上主角），获得存档机会，存档后即可无限复活，且成功存档也会得到系统奖励，获得特殊能力、道具等，但因不论轮回几次，都会在二十岁时被魔女所害，一度对魔女的存在感到绝望，直到某次轮回中，罗恩机缘巧合避开了所有女主的死亡flag，成为了魔女身边的小白脸苟活，遂决定在之后的轮回中重复该操作，找到成功活到二十一岁的方法。\n姓名：魔女（女主）\n性格：本体三无，人间体胆小怕事，内向怯懦\n主要经历：自出生起便被邪神诅咒，会让任何接近之人遭遇不幸和危险，因此被封印在异次元，对外界充满好奇，因此受邪教蛊惑，分离了一部分力量去往现实，代替本体见证世界，在过往的无数轮回中，都因对世人失望而选择灭世，实则内心一直渴望着爱与关注。\n姓名：女仆（后宫）\n性格：病娇\n主要经历：罗恩家族中前一任女仆长的孩子，世世代代侍奉着主人一族，比罗恩大五岁，在罗恩刚出生时就担任其专属女仆，幼时曾被罗恩袒护错误，从此倾心于他，并逐渐演化成病娇，总是试图独占罗恩。\n姓名：皇女（后宫）\n性格：傲娇\n主要经历：王国长公主，曾被寄养在罗恩家与之成为童年玩伴，在一次人质事件中被罗恩解救，从此成为迷妹并定下婚约，但性格过于傲娇，导致罗恩曾误以为其讨厌自己，最终被女仆设计解除婚约，实则非常在意罗恩。\n姓名：帝国公主（后宫）\n性格：伪娘癖，恋爱脑\n主要经历：帝国派往王国留学的交换生，幼时曾与皇女罗恩一同结为玩伴，并在罗恩穿越者身份的影响下觉醒了伪娘癖，痴迷于将罗恩打扮成女孩子养作男宠。\n大纲 第一卷\n主角：拥有死亡回溯能力的贵族\n主线目标：自保\n主角的行动：攻略魔女\n核心问题：主角能否得到魔女的好感\n阻碍：二十岁时世界必定毁灭/灭世魔女、病娇女仆、傲娇皇女/正常人的良心\n结果：与魔女关系更进一步\n开场\n用前史或者序章开篇，开幕是罗恩战败被俘，受魔女淫威屈服当她的小白脸。\n介绍男女主基本信息和世界观。\n魔女先天被诅咒，缺爱偏执反社会，实力强大，罗恩则是穿越者，拥有和特定女性搞好关系，就能获得存档无限重生的金手指。\n此前，罗恩已经无数次被魔女杀害，这是唯一一次，罗恩成功在魔女身边存活，因此罗恩迫切地希望和魔女搞好关系，以获得存档的机会。\n为了让魔女对自己产生好感，罗恩忍辱负重，承受了不少单方面羞辱，并在相处过程中，通过一些小习惯判断出魔女的喜好和部分心理。\n于是在某次互动中，罗恩铤而走险，强吻对方后向其告白，希望打动魔女，但却错判了魔女的真实喜好，最终被魔女杀死，回到上一个存档重生。\n铺垫\n重生后，罗恩因为之前对魔女心态判断失误，丢失了存档机会，只能回到十五岁时的第一个存档，此时正好被女仆给单方面调戏。\n应付完女仆后，罗恩做出总结，上一世成功在魔女身边苟活，是因为避开了所有女主的死亡flag，遂打算复刻前世，寻找面对魔女的求生之法。\n此时确立主线，找到成为灭世魔头之前的魔女，想办法和她搞好关系，并引入前期的两个主要支线，病娇女仆和皇女退婚。\n原来服侍公爵家多年的女仆长，是隐藏极深的病娇，幼时受主角帮助后芳心暗许，潜伏至今就是为了将罗恩占为己有，并且设计让罗恩和帝国公主接触后留下证据，使本和罗恩订婚的皇女心生罅隙，逼罗恩退婚，最终让父母颜面尽失被扫地出门，被女仆终身囚禁。\n理清当前的困局后，罗恩假意顺从女仆，和帝国公主接触后，利用多次轮回得到的知识，成功说服对方(暂定是帝国公主是伪娘控，罗恩假装自己喜欢女装骗取同情)成为自己的助力，之后静待退婚事件发生。\n激励\n罗恩与帝国公主幽会的证据被女仆告密给皇女，后者果然前来兴师问罪。\n皇女和罗恩曾是幼时玩伴，但长大后变成了傲娇，虽然喜欢罗恩却不知如何表现，于是利用退婚，想让罗恩明白两人间的关系，重归于好。\n在原来的时间线中，罗恩被女仆蒙蔽，导致两人真的取消婚约，而这一次，罗恩则活用皇女的好感维持婚约(暂定为扮演雄小鬼杀傲娇)，并在皇女的帮助下，获得入学魔法学院的资格，因为根据前世的情报，在魔法学院有魔女的线索。\n进展\n罗恩与皇女再续婚约一事不胫而走，罗恩本以为面对皇女，女仆会收敛对自己的病娇心理，却不料在一次独处时，女仆公然将自己关进密室，打算把他养成禁脔。\n意识到自己低估了女仆的决心，罗恩赶忙补救，经过好言相劝，被折磨了数天才被女仆放过，并将她想独占自己的欲望，引导成对皇女的敌视。\n另一边，罗恩为了防止女仆再对自己下黑手，通过讨好帝国公主，获得了第二个入学魔法学院的资格，最终在入学当天，把满心期待和罗恩一起上学的皇女，安排成了和女仆同行，罗恩自己则和帝国公主成为陪读，顺利入校。\n转折\n入学测试，罗恩和从小就被他锻炼的女仆一路扮猪吃虎，技惊四座，让想在罗恩面前显摆的皇女又气又恼，质问罗恩，不是说好结伴入学，为何他却跟帝国公主在一起？\n罗恩谎称自己刚和皇女重新订婚，再一起上学难免被人视作眼中钉，最终说服皇女，开始寻找魔女的踪迹，却一无所获，直到在图书馆查阅魔女相关资料时，遇到一个很像魔女的内向女孩。\n两人都在查找魔女的资料，罗恩假装纯良接近，成功从对方处获得觐见魔女的仪式，随后道别。\n女孩实际上就是魔女的人间体，她的本体被封印在另一个次元，对罗恩能这么友好的与她沟通一直念念不忘，但想到不可能有人使用那个仪式，就又心灰意冷，与邪恶团体碰头。\n另一边，罗恩开始研究仪式，发现其类似灵魂出窍，会让受试者的意识传送到其他次元，为搞清魔女灭世的真相，罗恩决定以身犯险，期间和女主之一(待定)搞好关系，获得存档机会后，罗恩进入了异次元。\n最终在封印之地，罗恩成功与魔女会面，通过不断的读档重生，摸索出接近的方法，发现魔女的样子和图书馆见到的内向女孩完全一样。\n再转\n罗恩找到内向女孩，询问真相，后者原本不信，但在罗恩给出大量关于异次元的细节后终于折服，打算对罗恩开诚布公，然而两人的见面却被其他女主屡次打断。\n此处穿插修罗场剧情。\n风波平息后，两人本欲继续，却遭遇了女仆的围杀。\n原来在罗恩进行仪式时，醋意爆表的女仆就发现了端倪，加之罗恩先前的种种行为，都和她的印象不符，女仆遂认为罗恩出轨，要将魔女杀害，却不料，三人的冲突引发了邪恶团体的警觉，最终被强大存在齐齐抓获。\n此时真相揭晓，魔女先天背负诅咒被世人厌弃封印，人间体则是她的分身，出于对世间的好奇被分离而出，代替封印的本体见识世界，但人间体却引起了邪教的觊觎，打算用她召唤邪神，没想到被罗恩坏了好事，眼下只好提前开始献祭。\n为了拯救魔女和女仆，罗恩自杀，回到了上一个存档点。\n高潮\n重新回到进入异次元的仪式前，罗恩利用轮回的信息差，尝试和此时起疑的女仆交涉，以免之后她的追杀引动邪教。\n然而缺少前置剧情，女仆并不能理解罗恩的转变，再次化身病娇，欲把罗恩囚禁，千钧一发之际，罗恩只得坦白，自己做的一切都是为了保护他和女仆，最终说服女仆，协助他重新进入异次元，见到了魔女的本体。\n罗恩告诉魔女，自己一定会救她出来，所以请不要失去对世界的希望云云，成功得到魔女信任，并获得魔女的祝福，随后通过展示该祝福，官方势力得知邪教欲召唤邪神，成功将组织一网打尽，将魔女的人间体保了下来。\n尾声\n数日后，图书馆，皇女、帝国公主、女仆、罗恩等人齐聚一堂，交流着平平无奇的校园生活。\n此时一个身影路过，罗恩站起来主动向她打招呼，此人正是魔女的人间体，虽然因为读档失去了和罗恩共患难的记忆，但因为和本体的联系，依然对罗恩抱有好感，于是谦逊地回礼，引起一众女主们的好奇。\n样例参考2\n能不能别复活我了，我的病娇爱徒\n主线\n一句话故事：寿终正寝却被长生种弟子复活的勇者罗恩，发现自己来到了千年后的世界，而该世界因为长生种弟子的改造，已经变成人间炼狱，罗恩对此感到绝望，认为这是当初教育的失职，于是选择站在了弟子的对立面，试图用自己的死亡让失去人性的弟子醒悟，然而罗恩死后，却发现自己回到了过去，为了避免重蹈覆辙，罗恩决定认真当弟子们的老师，给予其最正确的教育。\n简介\n罗恩寿终正寝了。\n作为勇者，他的一生波澜壮阔，但其中最令他感到骄傲的，莫过于自己的一众长生种徒弟。\n有精灵被当成奴隶贩卖，被罗恩救于水火；\n有恶龙被人类狩猎，是罗恩给了她一个新家；\n亦有自以为是的血族被族群抛弃，但罗恩的怀抱永远向她开放。\n如今，这些徒弟都已成为顶天立地的大人物，罗恩也满足地撒手人寰。\n然后罗恩就醒了。\n一千前后的世界？\n死后觉得太寂寞所以把我复活？\n靠！\n我只想教书育人，没想真的和你们育人啊！\n剧情梗概\n主线目标是主角作为勇者收了许多长生种为徒，死后因徒弟们念念不忘而被复活，获得了不死不灭的能力，并发现徒弟们有违师训，为了争夺他的所有权，成为了肆虐一方的魔王，主角遂以死相逼，试图靠抛弃不死能力令弟子醒悟，却在死后再次复活，发现自己回到了千年前刚刚成为勇者时，但实际上，这只是弟子们伪造出的骗局，原来在主角以死相逼后，众女因抱憾终身陷入了混乱，最终达成协议，人工复原最初跟主角相遇的情景，假装一切都未发生。\n作品爽点&amp;亮点\n缝的是番茄的这两本《死后一千年，我被魔王妻子复活了》《别想拉我回去当反派》。\n前期靠寿命论开篇吸睛，中间抱憾终身，后期楚门的世界，之后让主角识破骗局，追夫火葬场。\n主要卖点是通过读者和角色的信息差，引发观众对女主身份败露后的期待，以及主角被倒追而不自知，反而一本正经收徒带娃的反差，还有女主们被识破后的追夫火葬场。\n人设\n姓名：罗恩（男主）\n性格：刚正不阿，乃至有些愚直，但在重生后懂得如何变通\n主要经历：曾是拯救世界的勇者，但因成名后孤直顽固，恪守心中的正义，导致为人处世不够圆滑，在与奴隶制对抗的过程中败给了守旧势力，从伟大的英雄沦落成十恶不赦的罪犯，可即便如此依然坚信与人为善，收养了许多不受人类待见的异族为徒，却不料对徒弟的溺爱无形中将她们养成了重女，在罗恩死后一千年复活了他。\n姓名：弟子A精灵（后宫）\n性格：类似芙莉莲，因长生而对一切都很淡漠迟钝，唯独对主角抱有热情\n主要经历：幼时曾被奴隶贩子与亲人一同捉走，后因罗恩的愚直导致亲人全部离世，但也自此成为罗恩的迷妹，最早和罗恩相依为命，也是第一个提出要复活罗恩的人。\n姓名：弟子B魔龙（后宫）\n性格：乖张暴戾，辣妹风格的少女\n主要经历：魔龙一族的公主，自幼娇生惯养目中无人，因此被敌国利用，得罪了不少厉害的种族，最终导致整个族群被人类消灭，因此痛恨人类，成为肆虐一方的魔龙，直到濒死时被罗恩收养，才伪装为异族的恨意。\n姓名：弟子C血族（后宫）\n性格：我行我素，欺软怕硬\n主要经历：血族女皇的初拥对象，自恃身份特殊常惹是非，实则只是血族为了制造一场灾祸准备的替罪羊，在被女皇抛弃时被罗恩找到。\n姓名：弟子D树精（后宫）\n性格：严谨认真，天然呆\n主要经历：罗恩自幼携带的种子护身符凝结成灵性生物，也是最理解罗恩的人，在罗恩第一次与魔王交手即将战败时，护身符意外掉落成长为树精，帮助罗恩打败魔王，但自身也受到重创，自此一直在养病，罗恩寿终正寝时坚定地阻止复活派却无济于事。\n大纲 第一卷\n主角：溺爱弟子的勇者\n主线目标：矫正弟子的三观\n主角的行动：自尽\n核心问题：主角能否意识到被弟子欺骗\n阻碍：楚门的世界/曾经的弟子/勇者的正义\n结果：即使被欺骗也依然爱弟子\n开场\n病床上，罗恩两鬓斑白，垂垂老矣，眼看就要寿终正寝。\n病榻附近则围满了他作为勇者曾经收下的徒弟。\n此处简单介绍主角和弟子们的身世和经历，突出这些长生种弟子都不是省油的灯，例如：近乎永生的精灵情感迟钝做事从不顾及他人，霸道的龙族傲慢尊大经常挑起战端，慵懒的血族视人命如草芥稍不注意就会引发灾祸等。\n但这些对人类社会影响深远的长生种，在罗恩面前都表现得十分乖巧，乃至对他的死无比伤心。\n对此罗恩十分坦然，直言教导弟子已经让他度过完美的一生，让众人不必难过，随后溘然长逝。\n然而，罗恩死后却再次恢复意识，发现自己的身体竟然回到了壮年时期，随后罗恩遇见了长生种弟子，得知此时已经是他死后一千年，他的弟子们终于找到了复活他的方法。\n铺垫\n尽管对复活一事颇有微词，但罗恩狠不下心打击弟子的热情，只好接受。\n此处介绍参与复活的一众弟子，与罗恩进行互动，主要表现为千年未见，对罗恩抱以侵略性的热情，如强吻、拥抱、痛哭等，甚至隐隐有为争抢主角开战的迹象，之后从罗恩视角给出弟子们与千年前的差异，并暂时得出，每个人都有遵照他当年的教诲好好成长的结论。\n之后逐一展示千年后世界的便利，为罗恩制造太平盛世的假象。\n激励\n短暂的天伦之乐结束，弟子提议带罗恩见证千年后世界的繁荣。\n起初，罗恩被世界的巨大变化震惊，但在一段时间的探索后，却发现这个世界并不像弟子们描述的那般和平，而是充斥着暴政和战争。\n弟子对此解释为，罗恩死后，魔王再度复活，战争一直持续了千年，弟子是为了应对战争不得不采取高压统治，直到罗恩偶遇另一名曾经的弟子D，才得知真相。\n原来主角死后，弟子们围绕主角的后事发生了争执，一派认为应该让主角入土为安，另一派则不愿接受主角的死，试图将其复活，双方的争斗引发毁灭世界的战乱，最终复活派获胜。\n而这名偶遇的弟子D，正是为了解救罗恩的反对派。\n罗恩对复活派大为失望，但复活派弟子却对此无动于衷，原来千年的时光早已让她们忘却了当初的教诲，她们确实喜欢罗恩，但不代表喜欢罗恩同族的人类，如今更是觉得替人类和反对派求情的罗恩聒噪，于是将其软禁，罗恩成为了弟子们争相斗趣的玩具。\n进展\n至此，罗恩依然对复活派弟子抱有一丝侥幸，希望说服对方不要一错再错。\n但复活派弟子本就对罗恩爱得深沉，故而无视罗恩的劝说，行为也越发乖张。\n最终，罗恩彻底失望，利用当初反对派弟子提出的情报，与对方里应外合的同时，在双方大战时，主动抛弃了永恒的生命，试图通过自己的死让复活派弟子醒悟。\n然而，罗恩的死虽然的确令复活派弟子陷入混乱，但极端的她们并未悔过，而是重新收集不死之力，令罗恩又一次复活，只是这一次，她们为了能和罗恩和好如初，选择用长生种的伟力再现千年前的世界，欲使罗恩误以为自己回到了过去。\n转折\n再次苏醒后，罗恩发现自己身处奴隶卖场，眼前的景象是一名可怜兮兮的少女正在被人叫卖。\n目睹此景，罗恩诧异地回想起过去，身为勇者讨伐完魔王后，他隐姓埋名打算回家乡建设，却发现这里还存在落后的奴隶制，于是怒发冲冠，为了拯救奴隶而大打出手。\n但当时的罗恩过于年轻气盛，以为只要有力量就能解决一切，没有料到战斗导致大量奴隶死亡，自己徒弟之一的亲人便在其中，并且因为和奴隶商人公开翻脸，导致国家的黑产也被曝光，自己身为勇者非但没有受到表彰，反而沦为了通缉犯，自此过上了逃亡生活，连带着后续收养的徒弟，都跟他过着有上顿没下顿的贫困生活。\n尽管感到十分不可思议，但有过重生的经验的罗恩还是很快适应，这一次，他没有直接和奴隶商人翻脸，而是买下了奴隶少女，弟子A。\n罗恩带弟子A返回故乡休整，复盘“前世”经历后得出结论，要想防止千年后长生种弟子毁灭世界，自己必须在和她们相处时解开所有心结，并提前获得不死能力，如此才能防止自己死后，弟子们无人看管导致恶堕。\n确立目标后，罗恩凭记忆开始四处搜寻弟子，而另一边，罗恩所在的虚幻世界之外，反对派弟子发现罗恩依然没有死亡，而是被复活派弟子联手欺骗后，派出了一名间谍，占据了复活派弟子的席位，欲告知主角不要沉沦，揭穿复活派的阴谋。\n再转\n为了更好地照顾弟子，罗恩在故乡建起一座道场，并在此陆续收下弟子B和弟子C为徒。\n期间，罗恩获得了关于不死之力的情报，打算带徒弟们外出历练的同时，找寻不死药的材料，但因复活派暂未将相关区域复原到千年前，罗恩只要前去就会发现自己被欺骗，所以疯狂阻挠。\n罗恩不解，将弟子的执着认为是撒娇，仍旧打算前往，眼看要露馅，复活派弟子只好紧急让弟子E进入虚幻世界，但弟子E此时已被间谍弟子D取代，突如其来的召唤术使弟子D唐突被拽入虚幻世界，导致天生异象，恰好和“未来”将要发生的大事件魔王复活吻合。\n罗恩见状，误以为魔王复活提前，遂取消预订的行程，只身前往魔界。\n高潮\n弟子D坠落后，发现自己失去了在外界的力量，并且缺失了一段记忆，整个人的状态仿佛真的回到了千年前，软弱无助，而她所处的地方则是被一比一复原的魔界，魔王城。\n此时的魔王虽然未完全复活，但已初具神智，见弟子D天降，作势就要将她生吞活剥，好在关键时刻，罗恩赶到，从魔王手中救下弟子D，而弟子D见到罗恩，尘封的记忆开始松动，最终在罗恩的邀请下，成为了他的第四名弟子。\n尾声\n再次击败魔王后，罗恩从其口中得知，不死药的材料并非复活派弟子曾告知的清单，罗恩感到十分失望，没想到弟子连这么关键的信息都骗自己，但奇怪的是，弟子D在听闻不死药后，准确地说出了不死药的具体构成和材料出处，就连魔王都感到诧异。\n罗恩感到疑惑，但还是决定相信弟子D，带其返回道场，可弟子D失忆的状态还是引起其他复活派的怀疑，后者决定找机会返回现实，查看真正的弟子E是否安然无恙。\n样例参考3\n主线\n一句话故事：一个死后变成地缚灵的普通人(什么人) 偶然发现继承自己房间的少女有轻生迹象(什么情况) 遂决意帮助少女直面人生(什么目标)\n简介\n栅栏窗格锁住的天空，伸出双手想要捉住彩虹。\n世界给予你的是如此空洞，愿我的祝福能呵护美梦。\n罗浩猝死了，但意外的是，死后他成为了一名地缚灵，并看遍众生百态。\n有人朝九晚五、有人醉生梦死、但在这狭窄逼仄的出租屋，最吸引罗浩注意的，莫过于一名少女，一名……在他面前准备自杀的少女——\n剧本细纲\n身份：喜欢恶作剧的幽灵(负价值：游戏人生)\n欲望：拯救少女\n动作：扮演少女\n核心问题：少女能否得到拯救，敞开心扉，面对现实\n阻碍：少女家庭的冷漠(环境)/校园霸凌(对手)/对生命的漠然(自我)\n结果：成功拯救少女，使其拥有活下去的希望\n正价值：生命宝贵，不可轻视\n负价值：逃避可耻，但却有用\n开场\n(交代信息，引发读者兴趣)\n罗浩全裸着立在房间中央，离他不远处的床边，坐着一名才出浴不久的少女。\n但少女并看不见罗浩，自顾自地宽衣解带，因为罗浩是一名地缚灵——他早就死了。\n多年前，罗浩因加班导致的过度劳累猝死，从此被困在出租屋无法离开。\n死过人的房间很难再被出租，长时间的等待更是让罗浩逐渐心理变态。\n直到，一名如花似玉的少女搬进他曾经的房间，罗浩一成不变的生活才泛起涟漪。\n切入\n(为核心问题的展现铺垫)\n新住户是一对父女，但不知为何，罗浩从没见过这个家庭的母亲。\n作为一名幽灵，罗浩能引发一些轻微的“骚灵”现象。\n比如，在少女沐浴时突然关掉厕所的灯，在她入睡时用窗帘轻抚伸出床沿的手足，又或者，毫无征兆地掀起一阵轻风，让她在父亲面前露出裙底。\n罗浩对此情有独钟，毕竟这是他为数不多的乐趣。\n但令他没想到的是，自己玩闹一般的举动，却是压垮少女心灵的最后一根稻草。\n激励\n(展现核心问题)\n一如既往的深夜，父亲夜班未归，少女守着偌大的空房，靠写作业和自习打发时间。\n可当罗浩照常整蛊后，走出浴室的少女却眼神迷离，当着罗浩的面，拿着刀片在胳膊上来回比划，直到此刻，罗浩才翩然转醒。\n她想自杀！\n不等罗浩反应，少女便在手腕上剌出一个口子。\n但幸运的是，少女很快便吃痛松开刀片，然后哭得歇斯底里。\n罗浩默默看着这一切，为至今为止的所作所为感到自责。\n但罗浩的自责并不能阻止少女，发现自己下不了狠心割腕，女孩便将主意打到了天花板的老式吊扇，欲上吊自杀。\n罗浩见状倍感焦急却无能为力，作为幽灵他无法触碰少女，于是在目睹了女孩口吐白沫的挣扎后，他终于不再做任何施救的举动，而是试探性地，伸手去抚摸女孩那如安祥地沉睡了一般的侧脸。\n也就是在这一刻，一股丢失了许多年的强烈刺激和眩晕感，袭上罗浩脑海。\n转瞬间，床单因支撑不住生命的重量而撕裂，女孩仿佛被神明眷顾一般，从死亡的边缘走了一遭，瘫坐在地疯狂咳嗽。\n重新睁开眼睛的罗浩定了定神，但下一秒，他的视线就再也无法挪动，因为在他面前，一个他曾朝夕相处了许久，一张无比熟悉的面庞，正瞪大眼睛，恐惧地盯着自己。\n那是，少女的灵魂，以一种半透明的形态漂浮在房间上空。\n而罗浩的灵魂……却占据了少女的肉体。\n那一天，罗浩与少女的灵魂，完成了身份互换。\n进展\n(无效动作，通常表现为主角的行为无法真正解决核心问题)\n少女发现身体被顶替后惶恐至极，质问罗浩这是怎么回事，罗浩便道出自己是地缚灵的真相，表示为救少女，才阴差阳错附了她身。\n经过一番苦口婆心的劝诱，少女渐渐打开心扉，告诉罗浩为何要自杀。\n原来她是跟随父亲来外地念书的独生女，父亲在大城市工作，自己省吃俭用，把钱寄回老家，抚养家里老人，而之所以要把女儿一同接来，则是为了给她上城市户口，希望她能好好念书，将来取得一番成就。\n然而，父亲毕竟是个糙汉子，压根儿不懂怎么带孩子。\n那个男人唯一称得上是教育的手段，就只有打骂与呵斥，对女儿的日常生活也毫不关心，将她扔到学校后，除了学习成绩就不管不问，丝毫不知女儿因为人生地不熟，在学校被人霸凌，即使回到家里，也经常见不到每天加班的父亲。\n久而久之，女孩的性格越来越内向，尤其最近一段时间，罗浩还热衷于整蛊，加上在学校少女被同学霸凌也越发严重，她终于承受不住压力，想要一死了之。\n听完这一切，罗浩深感愧疚，可又冥冥中觉得哪里不对，于是再三询问女孩是否隐瞒了真相，并称她就算说谎也没用，现在身体的控制权在他手里，只要他明天去学校，一切都会……\n“不可以！你明天不能去学校！”\n少女突然歇斯底里，而见对方没说实话，罗浩也顺势用回学校要挟，迫使她交代真相。\n原来，少女不仅是被恶霸欺负，她从最开始不会说本地话，就一直无法融入同学们的社交圈，到后来被几个不良当成了饭票和出气包，再到看她不顺眼就肆意打骂，扒衣服，拍视频，还扬言，若是明天她再敢上学，就把视频和照片发布……\n听到这，罗浩两眼直冒火光，这才明白，为何女孩没有向父亲告状，而是一心求死，因为真的没有人在乎过，她内心真实的想法。\n忽然，罗浩发现灵体化的少女，正惊恐地看向他，罗浩不解，一起身才察觉，在他刚刚暴怒时，周围的物体都无视重力悬浮起来。\n罗浩一眼就看出这个现象意味着什么，他附身少女的躯体后，骚灵的能力不仅没有消失，反而获得了增强，理解了这点后，罗浩心中有了决断，他向少女约定，自己会处理好照片的事，而反之，这件事解决后，女孩绝对不能再寻死，要好好地活下去(注：抛出赌注，设置悬念)。\n转折\n(通常表现为用主角的原罪、负价值进行转折，用以应对欲望、环境等的改变，同时，该序列通常是主角的一次虚假胜利，即ta看似解决了核心问题，实则只是将矛盾的爆发延后)\n第二天一早，罗浩厚着脸皮在少女的指导下穿上女装，前往学校。\n令人意外的，少女的灵体居然不受地缚灵的区域限制，可以跟随罗浩一同移动，但也只能在他身边活动，相当于坐标锚定于这具肉体的地缚灵。\n虽然变成灵体是全裸状态，但为了不让罗浩做出有损身体名誉的事，少女还是红着脸跟他一同出门了。\n到了学校，罗浩直观感受到了学生特有的恶意，他发现少女的位置是最角落，而那里离垃圾桶最近，不仅如此，课桌和椅子也是最旧的，而这一切恶意的尽头，如果不是罗浩控制这具身体前来，都将被少女独自承受，光是踏入教室的门口，都教他有一种被扼住喉咙的窒息感。\n面对恶意，罗浩表现强硬，不仅用骚灵能力掀了几个不良的桌子，还强行霸占了其中一人的座位，等到老师上课时，发现两人换位，还恶人先告状，说是对方想在上课聊天，才强行换位。\n诸如此类，罗浩展现出完全不同于少女的气场，将不良们教训得灰头土脸，但少女在一旁观看却觉得天打雷劈，因为她的照片还在那些不良手上。\n对此，罗浩胸有成竹，让少女不要担心，并主动在下课后，邀请那些曾经霸凌过少女们的人前往旧校舍。\n罗浩之所以知道学校有旧校舍，不是因为少女告知，而是他就曾在这所学校就读，早在来学校的路上，他就想好了要怎么整死那帮不良。\n利用强化后的骚灵能力，罗浩将旧校舍打造成了专门惩治恶人的鬼屋，最终，在“金手指”和少女的帮助下，所有恶霸都吓得屁滚尿流，不仅删除了手机里的所有资料，还因为反应过激，导致建筑失火，统统被记大过退学处分，这之后，不再有人敢欺负少女。\n再转\n(铤而走险)\n医院里，罗浩第一次以少女的形式见到父亲。\n那场火灾不仅教训了不良，也让少女曾被霸凌一事浮出水面。\n但和罗浩预想的一样，父亲对女儿被霸凌却不主动告知一事表示不解，且认为就算被霸凌，也不应该忍气吞声，被人拐到火灾现场。\n罗浩心里明白，这并非是父亲不爱女儿，只是两人的观念差异实在太大，以至于父亲即使想要表达关心，说出来的话也会像是在诋毁女儿。\n于是为了调和父女间的矛盾，罗浩强行控制少女的身体，委婉地向父亲表达了自己缺少陪伴，希望父亲能多关注自己，疼爱自己的要求，就比如，询问上一次一起和父亲一起出去玩是什么时候，上一次全家聚在一起是什么时候，等等，凡此种种。\n作为父女俩生活的见证者，罗浩太清楚父亲是多么努力地在养家，而女儿又是多么渴望父亲的陪伴，也正因为他是如此了解，以至于连少女都被他的讲述触动，在内心喃喃自问，到底谁才更像父亲的女儿。\n最终，父亲被“女儿”的坦白感动，决心请假几天，好好陪伴她，当晚，罗浩开心地向少女表示祝贺，称她生活中的危机已经解除，活着总会有好事发生，不像自己，死了就真的什么都没有了，鼓励少女，让她一定要好好地活下去，而少女也向罗浩吐露了更多心声，从自己的童年聊到现在，两人仿佛是相识多年的好友。\n危机\n(主角面对故事中最大考验)\n然而，少女听完罗浩的感慨，尤其是一句“帮助女孩解决麻烦后，自己也差不多应该要在这个世界消失了”时，女孩眼神中闪过一丝落寞。\n夜里，少女如常应和着与罗浩的交谈，然后在他酣然入眠后，悄悄离开。\n导入\n(增加烈度，调动观众情绪)\n少女走了。\n不是因为自暴自弃，而是她觉得，比起自卑的自己，更适应这个社会的罗浩，才更应该活下去，如果没有罗浩，自己早在那天晚上就已经自杀身亡，更不用说，那么发自真心地向父亲坦白自己的需求，关注到父亲为了赚钱养家，有多么不容易，而自己却只关心学校里的三俩破事。\n在罗浩的帮助下，女孩确实解决了生活中的难题，可另一方面，她内心的自卑却越来越重，她开始觉得变成幽灵是一件理所当然的事，像她这样的人，不像罗浩那般开朗乐观，如果能够以自己消失的方式，换来罗浩的重生，或许，不失为一件好事？\n但苏醒后，发现少女灵体消失的罗浩却焦急如焚。\n他找到少女用骚灵之力写下的纸条，开始反思自己表现得太突出了没有照顾少女的心情，以至于让她相形见愧。\n眼下的问题是，罗浩思来想去，也不知道少女会去什么地方，而少女离开身体这个锚点后，相信不要多少时间，就会彻底消失(注：引入倒计时，渲染紧张氛围)。\n高潮\n(核心问题被主角彻底解决)\n罗浩一筹莫展之际，他想起某天晚上，少女曾说过关于母亲的事，从她的语气和神情判断，女孩应当很爱她的母亲，那么她有没有可能去了母亲那？\n有了线索，罗浩马上找到父亲，询问他母亲在何处，谁知男人露出古怪的表情，说母亲早就死了，就葬在某某处。\n罗浩顿时有了答案，立刻赶往墓地，希望再见到女孩，而在一路疾行后，罗浩果真在少女母亲的墓碑前找到了她。\n此时的少女因为长时间脱离锚点，身形已经快要消失，见罗浩寻来，她哭喊着说，明明罗浩比自己要优秀太多，凭什么要因为帮助了自己就不得不消失呢，为什么一定要救她，不能一起好好地活下去？\n听闻此言，罗浩讪然一笑，说自己早就是个死人，留存在世也多半只是因为前世没有做过让他满足的事，可如今，能帮助少女重返正常生活，他已经很满足了，不想再奢求更多，况且少女和自己不一样，她还有家人爱着她，而罗浩自己的家人，早就接受了自己的死，他就算用少女的身体活下去，也代替不了真正的她。\n“自己的人生，一定要自己拼尽全力去度过！哪怕你明天就出意外被车撞死，只要你在昨天拼命地活过，就不存在什么这辈子到底值不值得一说！”\n罗浩暴论着向少女伸手，希望她回来，可即使到了这一步，少女也依然倔强，好比她宁愿自杀，也不愿意坦白的死脑筋，不肯靠近罗浩半步。\n纵使如此，罗浩也早就料到，变成幽灵后他见过太多众生百态，于是，他拿出了那张曾经被少女丢弃的刀片，果断在手腕上划出印记。\n“下一次，这道伤痕会出现在我的脖子，你不是一直想死吗，那我现在就满足你！”\n最后的最后，在罗浩的死亡威胁下，少女冲向了他，两人也再一次，实现了此生唯二的肌肤接触，女孩在未知的力量作用下，重新回到身体之中，而罗浩……\n灿烂的阳光中，墓碑旁的花朵迎风摇曳，女孩注视着母亲的名字，潸然泪下。\n结局\n(核心问题解决后，为观众提供释放情绪的情景)\n多年后，罗浩与女孩曾居住过的房子迎来拆迁。\n但在施工队爆破之前，一名老迈的妇人好说歹说，才让工头破例，允许她进入即将被摧毁的房间之中。\n看着如今破败，却又无比熟悉的场景，老人颤抖着双手合十，发自内心地喃喃道：\n“照你说的，我好好地度过了一生呢，幽灵先生。”\n话音刚落，封闭的室内，窗帘无风自起，阳光透过窗户的缝隙，在地毯上留下一个微笑。\n全文 完\n\n解析\n故事的三要素\n1、人物\n①角色的身份：主角在事件内的形象。\n②角色的欲望：主角在事件中想得到什么。\n③角色的动作：主角为了满足欲望所采取的行动。\n本文中罗浩的身份：喜欢恶作剧(负价值)的幽灵\n罗浩的欲望：不甘寂寞，想获得关注→不想少女自杀，想要拯救她\n罗浩的动作：骚灵现象整蛊少女→进入少女体内，扮演她、代替她解决日常矛盾\n\n2、事件\n①整个故事为了解决怎样的核心问题？\n②在故事中，角色遇到了怎样的阻碍？\n③故事的结果是什么？核心问题有没有得到解决？\n核心问题：少女能否得到拯救，敞开心扉，面对现实\n阻碍：少女父亲的冷漠(环境)，校园霸凌的排挤(对手)，主角对生命的漠然(自我)\n结果：罗浩成功拯救了少女，让她重新拥有活下去的勇气(没有通过整蛊和代替少女生活完成，而是自杀完成——绕过动作，实现欲望)\n\n3、主题\n①故事的正价值：剧本一定要有自己的正义，提供推进故事的动力\n②故事的负价值：与正价值相冲突，提供迟滞故事的阻力\n本文中的正价值：生命宝贵，不可轻视\n本文中的负价值：逃避可耻，但却有用\n\n4、为什么这么设计\n①主角的身份——给人物加上一个含有负价值的定语，用来刻画角色成长\n②主角的欲望——把欲望讲给猴子听，如果连猴子都能因此共情，那么人也可以\n③主角的动作——必须切实可行，得到观众的许可\n④事件的核心问题——保持悬念，吸引力\n⑤事件中的障碍——通常来自于环境、对手、自身\n⑥事件的结果——通常表现为绕过动作实现欲望\n⑦故事的主题——用最俗的词，例如真善美、正义、亲情、救赎等，便于共情\n故事的十序列\n1、开场\n(交代信息，引发读者兴趣)\n以本文为例，开场描写主角全裸着和一名少女共处一室，令观众产生好奇的同时，进一步揭露，主角其实是个幽灵，他不能干涉现实，只能作为旁观者观看他人的生活。\n2、切入\n(为核心问题的展现进行铺垫)\n展现主角的性格，为少女的自杀进行铺垫，并和主角的落井下石形成对比。\n3、激励\n(展现核心问题)\n主角被少女自杀震惊，心生愧疚，故事主题初步展现，主角反省并希望拯救少女。\n4、进展\n(无效动作，通常表现为主角的行为无法真正解决核心问题)\n主角与少女互换身体，但这未能真正解决她的心魔。\n5、转折\n(通常表现为用主角的原罪、负价值进行转折，用以应对欲望、环境等的改变，同时，该序列通常是主角的一次虚假胜利，即他看似解决了问题，却留下许多隐患)\n主角代替少女上学，并通过金手指扫清不良，但却忽视了照顾少女自尊。\n6、再转\n(主角直面与众不同的新生活，并选择铤而走险)\n少女第一次被父亲关心，主角自作主张回应，表面上解决所有矛盾，却让少女更加自卑。\n7、危机\n(主角面对故事中的最大考验)\n少女认为让主角代替自己生活下去，比自己活着更好，黯然离开，少女的生命进入倒计时，主角焦急寻找。\n8、导入\n(增加烈度)\n再次找到少女时，哪怕晓之以情，少女也依然不愿回归，迫不得已，主角自残。\n9、高潮\n(核心问题必须得到解决，且必须由主角进行)\n在主角的以死相逼下，少女放下自尊，答应主角会好好活下去，心魔终于消失。\n10、结局\n(核心问题解决后，为观众提供释放情绪的情景)\n多年后，少女已成老妇，度过了独属于她的一生，故事的主题得到展现，happy end。\n","categories":["写作"]},{"title":"开始写作的第一步","url":"/2026/01/02/StartWriting/","content":"开书基本套路\n\n描述主角原本的生活，让读者了解并共情你的主角\n突发变故，主角原本的生活被打破，主角陷入某种困境\n展示在变故中，主角为了解决突发情况，产生了什么初始目标，也就是主线\n主角朝着初始目标努力的过程中，发现自己的特殊性，也就是金手指\n读者产生主角运用金手指，解决当下困境的期待\n作者在后文中让主角实际运用金手指，解决困境\n满足读者的期待，实现爽点\n\n身份\n快速使你的角色与观众共情。\n\n壮举\n主角初登场就靠某种夸张的行为引人注目，比如开场就被人告白，路明非的红点，遇见想要自杀的人前去阻止，刺杀完总统准备撤退等。\n特殊身份\n譬如，卧底，渣男，西格玛男人，主角女装进女校，猫鼠游戏式的假身份，从没学过高达驾驶，只看一遍说明书就学会操作的高达驾驶员。\n落魄的强者\n主角曾经的强大能为读者提供安全感，让其放心地阅读，多见于各种重生文。\n没头脑和不高兴\n把主角和跟ta性格截然相反的角色凑在一起，比如二次元宅文里经常出现的战败文，强制爱等，他追她逃式的展开天然就吸引人。\n\n困境\n提供一个具体的，可被打败的阻碍，迫使主角离开最初的舒适区。\n\n强大的对手\n主角开局就遇见满级红名，严肃点可以写成《冰海战记》《黑客帝国》，想玩二次元也可以是战败文，各种穿书穿游戏的炮灰主角要面对的剧情杀等。\n赌局\n主角的命运无法被自身掌控，而受限于某种规则，主角必须进行高风险高收益的博弈，赌博默示录了解一下？\n范围巨大的灾难\n黎明之剑的魔潮、黄段子禁止的世界中色色禁止法令、全世界某天只剩下一个男人、灵气复苏。\n解谜\n不单单只是悬疑探案，比如主角重生后得知身边有人也带着前世记忆重生，而ta要把重生者找出来之类的也算。\n\n目标\n爽点的实现。\n\n拯救\n青春猪头少年不会梦见兔女郎学姐，龙族，我的超能力每周刷新。\n履行约定\n影视剧里经常有那种强大的主角护送弱者的桥段，亦或者三年之期已到，恭迎龙王。\n逃离\n严肃点能写成异次元杀阵和大逃杀，也可以是被病娇抓走后成功逃生，却让病娇因此抱憾终身云云。\n复仇\n非常经典的目标，不光是仇杀报复装逼打脸，也可以像政宗君的复仇那样写成轻小说。\n获得报酬\n比如《纸牌屋》，主角想成为总统，《西红市首富》主角想暴富，又或者是主角要参加比赛夺得第一，完成某件事并获取报酬，是经久不衰的爽点。\n\n新人避坑\n\n主角没有魅力&amp;代入过深\n代入自己写出的主角，不仅没有魅力，还不吸引人。因此，我们要设计一个讨喜的主角。\n虐主&amp;主角的选择无法干涉故事走向\n主角必须在故事里有的选。\n主角和观众没有建立共情\n公式：主角拥有一些常见的特质，比如\n执着：《肖申克的救赎》里，主角安迪日复一日地给政府写信，成功帮监狱建成图书馆。\n努力：《喜剧之王》里，尹天仇为了演员梦的坚持。\n被爱：可以是家人朋友的关爱，也可以是恋爱，主角开局就处于一种很幸福的状态，也是很容易让人代入的模板，比如迪士尼的各种经典动画。\n生死危机：电影《活埋》中，主角苏醒在一个棺材里，于是展开自救。\n善良：注意是善良，不是圣母，编剧理论里有个很经典的梗叫救猫咪，个人印象比较深的是《纸牌屋》的开篇，主角开场看似在搭救一只受伤的小狗，但实际上是直接把小狗杀了，结束它的痛苦，这其实就是一种“救猫咪”式的展开，只不过增添了一层反差，丰富了人物形象。\n幽默：常见于起点上各种“贱人”式的主角，比较考验作者的玩梗能力，不太建议新手选这个作为主角特质，因为很容易变成玩尬的，\n本领：谁能忘记《终结者2》里，施瓦辛格的光屁股开局呢。\n被迫害：装逼打脸文的最爱，本质上是先抑后扬，且最好是那种刁难式的胁迫，轻小说其实也可以用，比如主角开局被重女和病娇包围，或是穿书穿游戏后直接面对BE，不得不想办法扭转局面。\n勇气：我的钻头可是突破天际的钻头.jpg\n喜欢写铺垫和伏笔\n比如光写了一个有趣的开头，可不知道后面如何展开，于是反其道而行之，想不出后面的剧情就疯狂脑补角色的前史，然后把还算有趣的开头藏到了后面，又写了一个新的开头，导致整个故事节奏拖沓，卖点后置。\n解决方法：故事开场就是冲突，是主角的目标和现状不匹配，并且冲突的过程可以延续和加剧，最终以一个令人意外的形式被合理解决。\n情节和情绪缺乏起伏\n公式：\n\n计划1：主角为了完成主线行动a\n执行：主角用a方法完成\n阻碍1：a方法对行动a无效\n计划2：主角用b方法尝试\n克服阻碍：b方法成功\n收获：主角获得好处和人际关系产生积极的变化\n延续收获：因为有了收获，从而有了下一次行动的机会\n\n\n反派对抗主角的原因无法自圆其说\n要塑造一个优秀的反派。\n\n如何营造期待\n爽点的实现，本质上是矛盾的解决，所有矛盾的解决，都是主角的选择，主角选择的背后，代表着作者本人的思想。\n高潮前置\n将剧情中段的高潮戏，直接放在开头，并且奠定整部作品的基调，之后也绝不能违背。\n金手指\n凸显主角的与众不同，帮助主角克服困难，完备的金手指应当满足以下条件：\n\n能够间接地帮助主角实现欲望：如果金手指自己就能帮主角解决困难，会削弱主角的存在感。\n一定是可升级的、有开发潜力的：力求做到金手指在作品的前中后期，都有用武之地，而不是一成不变。\n一定与故事的世界观相呼应、能够传达故事的主题和价值观\n\n提高赌注\n拉大主角的现状和目标之间的差距，设置高额的报酬和巨大的风险，直接刺激读者的注意力。\n展示目标实现的可能性：在剧情发展的中间阶段，向读者展示目标达成后的效果，以及主角正在如何逐步接近目标。比如安排一个过渡情节，让主角着眼现在，审视过去，展望未来，然后继续前进。\n目标如期实现\n让剧情顺利完成动机→阻碍→实现的整个过程，提供为观众释放情绪的桥段。\n信息不对称\n通过刻意设计，不同人得到或者知道的信息量不一样的状况，来制造悬念、谜团、反转。\n比如所谓的迪化，就是很常见的信息不对称，一个非常出名且正是运用信息不对称的拉期待的案例就是《诡秘之主》，主角克莱恩拥有神秘的灰雾，虽然实力弱小，但是拥有神灵般的气场和位格，于是通过收集罗塞塔日记获得其他人无法了解的知识，靠信息差实现其他角色对主角的迪化，与各种先知先觉的布局制造爽感。\n信息不对称其实可以适用任何小说，比如主角穿越进游戏，拥有大量游戏经验和游戏知识，形成对游戏世界角色的信息差；又比如主角拥有某种系统，通过做一些别人眼中会利益受损的事牟利，导致别人以为主角品德高尚或者脑子有坑，实则主角靠系统赚得盆满钵满，比如《西虹市首富》《亏成首富从游戏开始》都是典型。\n常见格式\n\n主角有坚定的目标想要达成\n个人认为最适合新手尝试的开书套路，大致模式如下：主角遭遇某种变故后，萌生了自认为一定正确的人生准则，并且立志要将其完成——比如，复仇、变强、求生、求财&amp;赚取利益、甚至是获得某个角色的爱，然而，在主角追求这个目标的过程中，却阴差阳错获得了许多美少女的好感乃至爱慕，可主角对目标的追求近乎魔怔，对这些倾心于她的美少女都不管不问，于是美少女为了得到主角的青睐，只能主动地去倒追。\n主角陷入和美少女的复杂关系\n轻小说不得不品的一环，就是主角被各类美少女争抢，大致模式如下：主角开局就困扰于和美少女的相处，可以是一对一，也可以是一对多，但必须强调的是，主角与美少女的互动并不使他享受，而是感到不适，并打算主动终结这种关系，但美少女却出于对主角的爱，选择靠强硬的手段将主角留在身边。\n这个模式的好处是，文章最开始就能点出主角和美少女的关系，比如典中典的战败被俘，其实本质上就是把主角置于弱势地位，然后让主角被动地接受女主们的索取，实现女角色倒追，主角看似吃瘪，但读者暗爽的效果。\n主角被美少女喜爱却不自知\n从这里开始，都是不建议新手尝试的思路了，仅作举例展示，大致模式如下：主角因为特殊原因陷入了某种状态中，比如失意落魄、艰难求生、咸鱼摆烂、甚至被人直接催眠控制意识，主角自己并不觉得这种状态非常不好，可实际上，这种状态就是美少女出于对主角的偏心搞出来的。\n这里以番茄的《妹妹装备白丝后看我的眼神不对劲》为例，这本书的前期的展开就是，主角和妹妹现实中互不对付，但网络上却关系亲密，并且主角制作的卡牌还存在负面效果，妹妹持有后必须和现实这个的主角互动，如此形成反差。\n这个模式的亮点在于，在角色和读者之间建立了一层“信息不对称”，也就是所谓的“高级爽”，即读者有上帝视角，知道剧中角色所不知道的信息，所以能以一种轻松审视全局的俯瞰感，去把玩情节，比如上面举例的这本书，主角自以为妹妹根本不关心自己，而自己也不需要妹妹，实际两人却在网络上双向奔赴，读者就会暗自窃喜，并期待后续两人正式相认。\n主角作为旁观者见证事态的发展\n最后一个模式，其实是很多新人作者都会用，但是却频繁踩坑的重灾区，大致模式如下：开局赋予主角一个特殊身份，且该身份能带给主角极大的便利，随后主角便借助身份优势贯彻己见，或是四处旅行，或是占山为王，或是隐居幕后，然后靠不断引入新角色与主角身份碰撞制造看点，最终让主角在关键时刻出手解决危机。\n\n参考内容\nhttps://shimo.im/docs/gO3odPBdOQtlMqDM\n","categories":["写作"]},{"title":"Unity入门知识总结","url":"/2026/01/06/UnityIntroduction/","content":"一、工程文件夹\n\nAssets：工程资源文件夹（美术资源、脚本等）\nLibrary：库文件夹（Unity自动生成管理）\nLogs：日志文件夹，记录特殊信息（Unity自动生成管理）\nobj：编译产生的中间文件（Unity自动生成管理）\nPackages：包配置信息（Unity自动生成管理）\nProjectSettings：工程设置信息（Unity自动生成管理）\n\n二、Unity的工作机制\n本质上就是利用反射，动态地创建GameObject对象并且关联各种C#脚本对象在其上，让不同的GameObject对象各司其职。\n三、预制体\n预制体本质是某个游戏物体的模板，可以通过预制体来创建游戏物体，并且游戏物体的初始属性等于预制体的属性。\n三、MonoBehavior基类\n\n创建的脚本默认都继承MonoBehavior，继承MonoBehavior才能挂载到GameObject上\n继承了MonoBehavior的脚本不能使用new来创建\n继承了MonoBehavior的脚本不需要写构造函数，因为我们不会去通过new来创建\n继承了MonoBehavior的类可以再次被继承，遵循面向对象继承多态的规则\n\n四、生命周期\n\nAwake():创建时调用，类似于构造函数，一个对象只会调用一次\nOnEnable():依附的GameObject对象每次激活时调用\nStart():被创建出来后，第一次帧更新之前调用，一个对象只会调用一次\nFixedUpdate():物理帧更新，固定间隔时间执行\nUpdate():逻辑帧更新，每帧执行\nLateUpdate():每帧执行，于Update之后执行\nOnDisable():依附的GameObject对象每次被关闭时调用\nOnDestroy():对象销毁时调用，或者依附的GameObject对象被删除时\n\n","categories":["Unity"]}]